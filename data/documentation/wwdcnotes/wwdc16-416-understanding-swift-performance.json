{"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-416-Understanding-Swift-Performance"},"schemaVersion":{"minor":3,"patch":0,"major":0},"sections":[],"sampleCodeDownload":{"kind":"sampleDownload","action":{"identifier":"https:\/\/developer.apple.com\/wwdc16\/416","isActive":true,"type":"reference","overridingTitle":"Watch Video (58 min)"}},"metadata":{"modules":[{"name":"WWDC Notes"}],"title":"Understanding Swift Performance","role":"sampleCode","roleHeading":"WWDC16"},"abstract":[{"type":"text","text":"In this advanced session, find out how structs, classes, protocols, and generics are implemented in Swift. Learn about their relative costs in different dimensions of performance. See how to apply this information to speed up your code."}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","level":2,"anchor":"overview"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Take-away: To write fast Swift code, avoid paying for dynamism that you’re not taking advantage of.","type":"text"}],"type":"strong"}]},{"type":"paragraph","inlineContent":[{"text":"Dimensions of Performance:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Allocation"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"ARC"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Method dispatch","type":"text"}]}]}]},{"type":"heading","text":"1. Allocation","level":2,"anchor":"1-Allocation"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Stack allocation is very fast; the cost of assigning an integer."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Heap is more dynamic but less efficient, O(log n). Also needs to protect integrity by checking for thread safety which is lots of overhead."}]}]}]},{"type":"heading","text":"Example: Creating a point struct.","level":3,"anchor":"Example-Creating-a-point-struct"},{"type":"codeListing","syntax":"swift","code":["struct Point {","  var x, y: Double","  func draw() { ... }","}","","let point1 = Point(x: 0, y: 0)","var point2 = point1","","\/\/ Since `Point` is a struct, this creates a copy. Modifying `point1` does not change `point2`.","point2.x = 5"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Note that ","type":"text"},{"code":"point2 = point1","type":"codeVoice"},{"text":" creates a copy since these are structs, which use value semantics. They are different.","type":"text"}]}]}]},{"type":"heading","text":"Example: Creating a point class.","level":3,"anchor":"Example-Creating-a-point-class"},{"type":"codeListing","syntax":"swift","code":["class Point {","  var x, y: Double","  func draw() { ... }","}","","let point1 = Point(x: 0, y: 0)","var point2 = point1","","\/\/ Since `Point` is a class, this adds a new reference to the same block of memory on the heap.","\/\/ The value of `x` is `5` for both references after this assignment.","point2.x = 5"]},{"type":"heading","text":"Example to make the background balloon in a chat application. This function is called a lot, so how can we make it fast?","level":3,"anchor":"Example-to-make-the-background-balloon-in-a-chat-application-This-function-is-called-a-lot-so-how-can-we-make-it-fast"},{"type":"codeListing","syntax":"swift","code":["enum Color {","  case blue, green, gray","}","","enum Orientation {","  case left, right","}","","enum Tail {","  case none, tail, bubble","}","","\/\/ Never construct something more than once; if you need it again, it’s already here.","var cache = [String: UIImage]()","","func makeBalloon(_ color: Color, orientation: Orientation, tail: Tail) -> UIImage {","  \/\/ Add","  let key = “\\(color):\\(orientation):\\(tail)”","  if let image = cache[key] {","    return image","  }","","  \/\/ If not cached, make a new balloon...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What’s bad?"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A string is almost limitless in terms of the values it can represent. It’s not a strong key. You could put the name of your dog as a key."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A string stores the contents of its characters indirectly on the heap. Even if you get a cache hit, you’re still incurring a heap allocation when you construct the key."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"How can you make this better?"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Represent the key as a struct of its 3 attributes. They are first class types and can be used as a key in the dictionary."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"It’s a lot safer and a lot faster."}],"type":"paragraph"}]}]},{"type":"codeListing","syntax":"swift","code":["enum Color {","  case blue, green, gray","}","","enum Orientation {","  case left, right","}","","enum Tail {","  case none, tail, bubble","}","","struct Attributes: Hashable {","  var color: Color","  var orientation: Orientation","  var tail: Tail","}","","var cache = [Attribute: UIImage]()","","func makeBalloon(_ color: Color, orientation: Orientation, tail: Tail) -> UIImage {","  let key = Attributes(color: color, orientation: orientation, tail: tail)","  if let image = cache[key] {","    return image","  }","","  \/\/ If not cached, make a new balloon...","}"]},{"type":"heading","text":"2. ARC","level":2,"anchor":"2-ARC"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"To know when it’s safe to deallocate an instance on the heap, Swift uses reference counting. If no one is pointing to it, Swift deallocates it."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"ARC is more expensive than just incrementing\/decrementing"}],"type":"strong"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"There’s a lot of indirection and thread safety checks. Need to do this atomically, and the cost adds up.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Back to the point class example. This is what’s actually happening behind the scenes.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class Point {","  var refCount: Int","  var x, y: Double","  func draw() { ... }","}","","\/\/ Initialization assigns `refCount` to `1`.","let point1 = Point(x: 0, y: 0)","","var point2 = point1","retain(point2)  \/\/ Increment `refCount`.","point2.x = 5","","\/\/ Use `point1`.","release(point1)  \/\/ Decrement `refCount`.","","\/\/ Use `point2`.","release(point2)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What about the point struct? There’s no reference counting overhead; the code is exactly the same."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, let’s consider a more complicated struct:"}]},{"type":"codeListing","syntax":"swift","code":["struct Label {","  var text: String  \/\/ Remember, `String` stores its characters on the heap.","  var font: UIFont  \/\/ `UIFont` is a class. This is also tracked on the heap.","  func draw() { ... }","}","","\/\/ `Label` is declared on the stack, but its attributes have 2 pointers to the heap.","let label1 = Label(text: \"hi\", font: font)","","\/\/ Since structs are value types and are copied, this means there are 2 *more* pointers","\/\/ to the same String and UIFont memory on the heap, causing 2x the overhead!","let label2 = label1"]},{"type":"paragraph","inlineContent":[{"text":"Behind the scenes, this code is:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Label {","  var text: String","  var font: UIFont","  func draw() { ... }","}","","let label1 = Label(text: \"hi\", font: font)","let label2 = label1","","retain(label2.text._storage)","retain(label2.font)","","\/\/ Use `label1`...","","release(label1.text._storage)","release(label1.font)","","\/\/ Use `label2`...","","release(label2.text._storage)","release(label2.font)"]},{"type":"paragraph","inlineContent":[{"text":"The take-away: structs are only advantageous in terms of ARC if they have 0 or 1 reference types as attributes.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Instead of "},{"code":"uuid: String","type":"codeVoice"},{"type":"text","text":", use Foundation’s built-in "},{"code":"UUID","type":"codeVoice"},{"type":"text","text":" type."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of strings, use enums."}]}]}]},{"type":"heading","text":"3. Method Dispatch","level":1,"anchor":"3-Method-Dispatch"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There’s static dispatch and dynamic dispatch."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If Swift can tell which method to execute at compile time, then that’s called static dispatch and you can jump straight into that code at run-time. The compiler can also optimize it aggressively into the surrounding code, either by inlining (literally copying and pasting the function body where the call is) or other tricks. This helps avoid new stack frames, etc. You can collapse a chain of static dispatches into the code that you actually want."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Otherwise, you use dynamic dispatch, which has the overhead of figuring out which method to call before you even get to the code and you give up compiler optimizations which is the main drawback."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Why use dynamic dispatch? Inheritance-based polymorphism gives you more flexibility in your code, but you give up static dispatching."}]},{"type":"heading","text":"Written By","level":2,"anchor":"Written-By"},{"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"type":"image","identifier":"https:\/\/avatars.githubusercontent.com\/u\/8892223?v=4"}],"type":"paragraph"}]},{"size":4,"content":[{"type":"heading","anchor":"Sarthak-Khillon","level":3,"text":"Sarthak Khillon"},{"type":"paragraph","inlineContent":[{"isActive":true,"overridingTitle":"Contributed Notes","type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}]},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/skhillon"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/x.com\/SarthakKhillon"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/"}]}]}],"numberOfColumns":5},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"isActive":true,"type":"reference","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing"}]},{"type":"heading","text":"Related Sessions","level":2,"anchor":"Related-Sessions"},{"type":"links","style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10648-Unsafe-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-403-Swift-API-Design-Guidelines","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-419-Protocol-and-Value-Oriented-Programming-in-UIKit-Apps"]},{"type":"small","inlineContent":[{"type":"strong","inlineContent":[{"text":"Legal Notice","type":"text"}]}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc16-416-understanding-swift-performance"]}],"kind":"article","references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10648-Unsafe-Swift":{"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc20-10648-unsafe-swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10648-Unsafe-Swift","abstract":[{"text":"What exactly makes code “unsafe”? Join the Swift team as we take a look at the programming language’s safety precautions — and when you might need to reach for unsafe operations. We’ll take a look at APIs that can cause unexpected states if not used correctly, and how you can write code more specifically to avoid undefined behavior. Learn how to work with C APIs that use pointers and the steps to take when you want to use Swift’s unsafe pointer APIs.","type":"text"}],"type":"topic","kind":"article","title":"Unsafe Swift"},"https://x.com/SarthakKhillon":{"type":"link","title":"X\/Twitter","url":"https:\/\/x.com\/SarthakKhillon","identifier":"https:\/\/x.com\/SarthakKhillon","titleInlineContent":[{"type":"text","text":"X\/Twitter"}]},"https://wwdcnotes.github.io/WWDCNotes/documentation/wwdcnotes/contributing":{"type":"link","title":"Contributions are welcome!","url":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}]},"https://avatars.githubusercontent.com/u/8892223?v=4":{"type":"image","identifier":"https:\/\/avatars.githubusercontent.com\/u\/8892223?v=4","variants":[{"url":"https:\/\/avatars.githubusercontent.com\/u\/8892223?v=4","traits":["1x","light"]}],"alt":"Profile image of Sarthak Khillon"},"skhillon.jpeg":{"type":"image","identifier":"skhillon.jpeg","variants":[{"url":"\/images\/skhillon.jpeg","traits":["1x","light"]}],"alt":null},"doc://WWDCNotes/documentation/WWDCNotes/skhillon":{"abstract":[{"type":"text","text":"No Bio on GitHub"}],"kind":"article","images":[{"identifier":"skhillon.jpeg","type":"card"},{"identifier":"skhillon.jpeg","type":"icon"}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","url":"\/documentation\/wwdcnotes\/skhillon","role":"sampleCode","title":"Sarthak Khillon (19 notes)"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC16-419-Protocol-and-Value-Oriented-Programming-in-UIKit-Apps":{"abstract":[{"text":"Building on last year’s Protocol-Oriented Programming and Building Better Apps with Value Types sessions, this year’s session will highlight tips and tricks for building better Swift apps. See how you can incorporate these design approaches into a real MVC-based Cocoa Touch app, especially in the view and controller layers, where you might not have thought of using these techniques before.","type":"text"}],"role":"sampleCode","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc16-419-protocol-and-value-oriented-programming-in-uikit-apps","kind":"article","title":"Protocol and Value Oriented Programming in UIKit Apps","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-419-Protocol-and-Value-Oriented-Programming-in-UIKit-Apps"},"https://www.linkedin.com/in/sarthakkhillon/":{"type":"link","title":"Blog","url":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","titleInlineContent":[{"type":"text","text":"Blog"}]},"WWDCNotes.png":{"type":"image","identifier":"WWDCNotes.png","variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}],"alt":null},"doc://WWDCNotes/documentation/WWDCNotes/WWDC16":{"abstract":[{"type":"text","text":"Xcode 8, Swift 3.0, iOS 10, macOS 10.12 (Sierra), tvOS 10, watchOS 3."}],"type":"topic","role":"collectionGroup","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"title":"WWDC16","url":"\/documentation\/wwdcnotes\/wwdc16","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16"},"https://developer.apple.com/wwdc16/416":{"type":"download","url":"https:\/\/developer.apple.com\/wwdc16\/416","identifier":"https:\/\/developer.apple.com\/wwdc16\/416","checksum":null},"doc://WWDCNotes/documentation/WWDCNotes":{"type":"topic","title":"WWDC Notes","kind":"symbol","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"url":"\/documentation\/wwdcnotes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"role":"collection"},"https://github.com/skhillon":{"type":"link","title":"GitHub","url":"https:\/\/github.com\/skhillon","identifier":"https:\/\/github.com\/skhillon","titleInlineContent":[{"type":"text","text":"GitHub"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC16-403-Swift-API-Design-Guidelines":{"role":"sampleCode","title":"Swift API Design Guidelines","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-403-Swift-API-Design-Guidelines","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc16-403-swift-api-design-guidelines","kind":"article","abstract":[{"type":"text","text":"Swift 3 introduces new API Design Guidelines specifically crafted to the unique character of Swift for clear, concise code. This talk will explore the philosophy behind the Swift API Design Guidelines and their application throughout the Swift Standard Library and the Cocoa and Cocoa Touch APIs. See how this API transformation will affect your Swift code and learn how to ensure a smooth transition to Swift 3. Learn how Swift 3 imports Objective-C APIs and how to expose rich Swift interfaces for existing Objective-C libraries."}]}}}