{"metadata":{"modules":[{"name":"WWDC Notes"}],"roleHeading":"WWDC21","role":"sampleCode","title":"Discover concurrency in SwiftUI"},"kind":"article","sampleCodeDownload":{"kind":"sampleDownload","action":{"overridingTitle":"Watch Video (22 min)","identifier":"https:\/\/developer.apple.com\/wwdc21\/10019","isActive":true,"type":"reference"}},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc21-10019-discover-concurrency-in-swiftui"]}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21"]]},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10019-Discover-concurrency-in-SwiftUI","interfaceLanguage":"swift"},"schemaVersion":{"minor":3,"major":0,"patch":0},"abstract":[{"text":"Discover how you can use Swift’s concurrency features to build even better SwiftUI apps. We’ll show you how concurrent workflows interact with your ObservableObjects, and explore how you can use them directly in your SwiftUI views and models. Find out how to use await to make your app run smoothly on the SwiftUI runloop, and learn how to fetch remote images quickly with the AsyncImage API. And we’ll take you through the process of enabling additional asynchronous flows in your custom views.","type":"text"}],"sections":[],"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","text":"ObservableObject + @MainActor","anchor":"ObservableObject-+-MainActor"},{"type":"paragraph","inlineContent":[{"text":"Imagine a view with the following class as a dependency:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class Photos: ObservableObject { ","  @Published var items: [SpacePhoto] = [] ","","  func updateItems() { ","    let fetched = \/* fetch new items *\/ ","    items = fetched ","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When we assign to "},{"code":"items","type":"codeVoice"},{"type":"text","text":" (second row in "},{"code":"updateItems()","type":"codeVoice"},{"type":"text","text":"):"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"an "},{"type":"codeVoice","code":"objectWillChange"},{"type":"text","text":" event will trigger"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"then the new data will be stored in "},{"type":"codeVoice","code":"items"},{"type":"text","text":"’s storage"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"When SwiftUI receives an ","type":"text"},{"code":"objectWillChange","type":"codeVoice"},{"text":" event:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it takes a snapshot of the object ("},{"type":"strong","inlineContent":[{"text":"before","type":"text"}]},{"type":"text","text":" its storage is updated)."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"once the storage is updated, SwiftUI compares the previous snapshot with the current value"}]}]},{"content":[{"inlineContent":[{"text":"if the values are different, SwiftUI will update the view (and all other views depending on this ","type":"text"},{"type":"codeVoice","code":"Photos"},{"text":" object)","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"This flow works great as long as we are on the main thread\/loop. If we assign to ","type":"text"},{"code":"items","type":"codeVoice"},{"text":" in another thread, both SwiftUI snapshots might be taken before the ","type":"text"},{"code":"items","type":"codeVoice"},{"text":" storage is actually updated, meaning that the snapshot comparison will find unchanged values, thus not updating our views.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"New in Swift 5.5, we can declare our "},{"type":"codeVoice","code":"ObservableObject"},{"type":"text","text":" class with swift’s "},{"type":"codeVoice","code":"@MainActor"},{"type":"text","text":" attribute and, instead of asynchronous callbacks, use the new "},{"type":"codeVoice","code":"await"},{"type":"text","text":" syntax to makes sure all operations are executed in the main thread."}]},{"level":2,"type":"heading","text":"New SwiftUI features","anchor":"New-SwiftUI-features"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/emptyview\/task(_:)","type":"reference"},{"text":" is a new view modifier that lets you run a task for the view lifetime","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it starts when the view appears (similar to "},{"type":"codeVoice","code":"onAppear"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"it gets cancelled when the view disappears (similar to ","type":"text"},{"code":"onDisappear","type":"codeVoice"},{"text":")","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"text":"use ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/asyncimage","type":"reference"},{"text":" to asynchronously load and display an image","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["AsyncImage(url: photo.url) { image in","  image","    .resizable()","    .aspectRatio(contentMode: .fill)","} placeholder: {","  ProgressView()","}",".frame(minWidth: 0, minHeight: 400)"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"use ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/view\/refreshable(action:)","isActive":true,"type":"reference"},{"text":" to add pull to refresh capabilities in your views","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"as the ","type":"text"},{"code":"action","type":"codeVoice"},{"text":" parameter expects an ","type":"text"},{"code":"async","type":"codeVoice"},{"text":" closure, the refresh indicator stays visible for the duration of the awaited operation","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"level":2,"type":"heading","text":"Written By","anchor":"Written-By"},{"type":"row","numberOfColumns":5,"columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"identifier":"zntfdr","type":"image"}]}]},{"size":4,"content":[{"text":"Federico Zanetello","anchor":"Federico-Zanetello","type":"heading","level":3},{"inlineContent":[{"overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitle":"Contributed Notes","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/zntfdr","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/zntfdr.dev","type":"reference","isActive":true}],"type":"paragraph"}]}]},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","isActive":true}]},{"level":2,"type":"heading","text":"Related Sessions","anchor":"Related-Sessions"},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10142-Efficiency-awaits-Background-tasks-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10018-Whats-new-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10022-Demystify-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10294-Meet-MusicKit-for-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10040-Data-Essentials-in-SwiftUI"],"type":"links","style":"list"},{"type":"small","inlineContent":[{"type":"strong","inlineContent":[{"text":"Legal Notice","type":"text"}]}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}]}],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10294-Meet-MusicKit-for-Swift":{"abstract":[{"type":"text","text":"MusicKit makes it easy to integrate Apple Music into your app. Explore the Swift-based framework: We’ll take you through the basic process of using MusicKit — including how to find, request, and play content — and show you how you can incorporate music subscription workflows into your app if someone hasn’t yet signed up to Apple Music."}],"role":"sampleCode","title":"Meet MusicKit for Swift","type":"topic","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc21-10294-meet-musickit-for-swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10294-Meet-MusicKit-for-Swift"},"https://github.com/zntfdr":{"url":"https:\/\/github.com\/zntfdr","titleInlineContent":[{"type":"text","text":"GitHub"}],"identifier":"https:\/\/github.com\/zntfdr","title":"GitHub","type":"link"},"https://developer.apple.com/documentation/swiftui/view/refreshable(action:)":{"url":"https:\/\/developer.apple.com\/documentation\/swiftui\/view\/refreshable(action:)","type":"link","title":"refreshable(action:)","identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/view\/refreshable(action:)","titleInlineContent":[{"code":"refreshable(action:)","type":"codeVoice"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10018-Whats-new-in-SwiftUI":{"title":"What’s new in SwiftUI","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10018-Whats-new-in-SwiftUI","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10018-whats-new-in-swiftui","abstract":[{"type":"text","text":"There’s never been a better time to develop your apps with SwiftUI. Discover the latest updates to the UI framework — including lists, buttons, and text fields — and learn how these features can help you more fully adopt SwiftUI in your app. Find out how to create beautiful, visually-rich graphics using the canvas view, materials, and enhancements to symbols. Explore multi-column tables on macOS, refinements to focus and keyboard interaction, and the multi-platform search API. And we’ll show you how to take advantage of features like Swift concurrency, a brand new AttributedString, format styles, localization, and so much more."}],"type":"topic","kind":"article"},"zntfdr":{"identifier":"zntfdr","variants":[{"url":"\/images\/WWDCNotes\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image","alt":"Profile image of Federico Zanetello"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-10142-Efficiency-awaits-Background-tasks-in-SwiftUI":{"type":"topic","abstract":[{"type":"text","text":"Background Tasks help apps respond to system events and keep time-sensitive data up to date. Learn how you can use the SwiftUI Background Tasks API to handle tasks succinctly. We’ll show you how to use Swift Concurrency to handle network responses, background refresh, and more — all while preserving performance and power."}],"role":"sampleCode","title":"Efficiency awaits: Background tasks in SwiftUI","url":"\/documentation\/wwdcnotes\/wwdc22-10142-efficiency-awaits-background-tasks-in-swiftui","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10142-Efficiency-awaits-Background-tasks-in-SwiftUI"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10133-Protect-mutable-state-with-Swift-actors":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","title":"Protect mutable state with Swift actors","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10133-protect-mutable-state-with-swift-actors","abstract":[{"text":"Data races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug.","type":"text"}],"type":"topic","kind":"article"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10134-Explore-structured-concurrency-in-Swift":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","title":"Explore structured concurrency in Swift","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10134-explore-structured-concurrency-in-swift","abstract":[{"type":"text","text":"When you have code that needs to run at the same time as other code, it’s important to choose the right tool for the job. We’ll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We’ll also provide guidance on when you may want to use unstructured tasks."}],"type":"topic","kind":"article"},"WWDC21.jpeg":{"identifier":"WWDC21.jpeg","variants":[{"url":"\/images\/WWDCNotes\/WWDC21.jpeg","traits":["1x","light"]}],"type":"image","alt":null},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","url":"\/documentation\/wwdcnotes","type":"topic","title":"WWDC Notes","images":[{"type":"icon","identifier":"WWDCNotes.png"}]},"https://zntfdr.dev":{"url":"https:\/\/zntfdr.dev","type":"link","title":"Blog","identifier":"https:\/\/zntfdr.dev","titleInlineContent":[{"text":"Blog","type":"text"}]},"WWDCNotes.png":{"identifier":"WWDCNotes.png","variants":[{"url":"\/images\/WWDCNotes\/WWDCNotes.png","traits":["1x","light"]}],"type":"image","alt":null},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"title":"Federico Zanetello (332 notes)","kind":"article","url":"\/documentation\/wwdcnotes\/zntfdr","role":"sampleCode","images":[{"type":"card","identifier":"zntfdr.jpeg"},{"type":"icon","identifier":"zntfdr.jpeg"}],"abstract":[{"type":"text","text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more."}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","type":"link"},"https://developer.apple.com/wwdc21/10019":{"type":"download","checksum":null,"identifier":"https:\/\/developer.apple.com\/wwdc21\/10019","url":"https:\/\/developer.apple.com\/wwdc21\/10019"},"https://developer.apple.com/documentation/swiftui/asyncimage":{"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/asyncimage","title":"AsyncImage","url":"https:\/\/developer.apple.com\/documentation\/swiftui\/asyncimage","type":"link","titleInlineContent":[{"type":"codeVoice","code":"AsyncImage"}]},"zntfdr.jpeg":{"variants":[{"url":"\/images\/WWDCNotes\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image","alt":null,"identifier":"zntfdr.jpeg"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency":{"type":"topic","abstract":[{"type":"text","text":"Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We’ll take you through Swift’s approach to eliminating data races and its effect on app architecture. We’ll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system."}],"role":"sampleCode","title":"Eliminate data races using Swift Concurrency","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","url":"\/documentation\/wwdcnotes\/wwdc22-110351-eliminate-data-races-using-swift-concurrency"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10022-Demystify-SwiftUI":{"url":"\/documentation\/wwdcnotes\/wwdc21-10022-demystify-swiftui","abstract":[{"text":"Peek behind the curtain into the core tenets of SwiftUI philosophy: Identity, Lifetime, and Dependencies. Find out about common patterns, learn the principles that drive the framework, and discover how you can use them to guarantee correctness and performance for your app.","type":"text"}],"role":"sampleCode","type":"topic","title":"Demystify SwiftUI","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10022-Demystify-SwiftUI"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10132-Meet-asyncawait-in-Swift":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","kind":"article","abstract":[{"text":"Swift now supports asynchronous functions — a pattern commonly known as async\/await. Discover how the new syntax can make your code easier to read and understand. Learn what happens when a function suspends, and find out how to adapt existing completion handlers to asynchronous functions.","type":"text"}],"role":"sampleCode","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10132-meet-asyncawait-in-swift","title":"Meet async\/await in Swift"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10040-Data-Essentials-in-SwiftUI":{"type":"topic","kind":"article","abstract":[{"text":"Data is a complex part of any app, but SwiftUI makes it easy to ensure a smooth, data-driven experience from prototyping to production. Discover @State and @Binding, two powerful tools that can preserve and seamlessly update your Source of Truth. We’ll also show you how ObservableObject lets you connect your views to your data model. Learn about some tricky challenges and cool new ways to solve them — directly from the experts!","type":"text"}],"title":"Data Essentials in SwiftUI","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10040-Data-Essentials-in-SwiftUI","url":"\/documentation\/wwdcnotes\/wwdc20-10040-data-essentials-in-swiftui","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21":{"type":"topic","title":"WWDC21","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21","images":[{"type":"icon","identifier":"WWDC21-Icon.png"},{"type":"card","identifier":"WWDC21.jpeg"}],"url":"\/documentation\/wwdcnotes\/wwdc21","kind":"article","abstract":[{"type":"text","text":"Xcode 13, Swift 5.5, iOS 15, macOS 12 (Monterey), tvOS 15, watchOS 8."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"MusicKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"DocC"},{"type":"text","text":", "},{"type":"codeVoice","code":"StoreKit 2"},{"type":"text","text":", and more."}],"role":"collectionGroup"},"https://developer.apple.com/documentation/swiftui/emptyview/task(_:)":{"url":"https:\/\/developer.apple.com\/documentation\/swiftui\/emptyview\/task(_:)","titleInlineContent":[{"code":"task(_:)","type":"codeVoice"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/emptyview\/task(_:)","title":"task(_:)","type":"link"},"WWDC21-Icon.png":{"identifier":"WWDC21-Icon.png","variants":[{"url":"\/images\/WWDCNotes\/WWDC21-Icon.png","traits":["1x","light"]}],"type":"image","alt":null}}}