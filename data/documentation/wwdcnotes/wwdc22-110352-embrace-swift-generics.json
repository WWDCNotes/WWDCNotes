{"kind":"article","sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc22-110352-embrace-swift-generics"]}],"abstract":[{"text":"Generics are a fundamental tool for writing abstract code in Swift. Learn how you can identify opportunities for abstraction as your code evolves, evaluate strategies for writing one piece of code with many behaviors, and discover language features in Swift 5.7 that can help you make generic code easier to write and understand.","type":"text"}],"schemaVersion":{"minor":3,"major":0,"patch":0},"primaryContentSections":[{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"overview"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For the purpose of this talk, imagine to have an "},{"type":"codeVoice","code":"Animal"},{"type":"text","text":" protocol"}]}],"name":"Note","type":"aside"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Generics are here to abstract away the details of a specific type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"if you find yourself writing overloads with repetitive implementations, it might be a sign to that you need to generalize"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Start with concrete types, generalize when needed"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Polymorphism","level":2,"text":"Polymorphism","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"ability of abstract code to behave differently for different concrete types"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"allows one piece of code to have many behaviors depending on how the code is used"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Different forms:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"ad-hoc polymorphism"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"the same function call can mean different things depending on the argument type"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Swift function overloading","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"subtype polymorphism"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"code operating on a supertype can have different behavior based on the specific subtype the code is using at runtime","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Subclassing in Swift, where a class "},{"type":"codeVoice","code":"override"},{"type":"text","text":"s a method of their superclass"}]}]}]}]},{"content":[{"inlineContent":[{"text":"parametric polymorphism","type":"text"},{"text":" - achieved using generics","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Generic code uses type parameters to allow writing one piece of code that works with different types, and concrete types themselves are used as arguments","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","level":2,"text":"`protocol`","anchor":"protocol"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"interface that represents capabilities","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"separates ideas from implementation details"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"abstraction tool that describes the functionality of conforming types"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"separates ideas from implementation details"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"each capability maps to a protocol requirement","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the name of the protocol should represent the category of types we‚Äôre describing"}]}]}]},{"type":"heading","level":3,"text":"`associatedtype`","anchor":"associatedtype"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"serves as a placeholder for a concrete type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"associated types depend on the specific type that conforms to the protocol","type":"text"}]}]}]},{"type":"heading","level":2,"text":"Opaque type vs. underlying type","anchor":"Opaque-type-vs-underlying-type"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Opaque type","type":"text"},{"text":" - abstract type that represents a placeholder for a specific concrete type","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"underlying type","type":"text"},{"text":" - specific concrete type that is substituted in the opaque type","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"For values with opaque type, the underlying type is fixed for the scope of the value","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"generic code using the value is guaranteed to get the same underlying type each time the value is accessed"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"opaque type can be used both for inputs and outputs","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"Opaque types in Swift:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"some Animal","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"<T: Animal>"}],"type":"paragraph"}]}]},{"type":"heading","level":2,"text":"Tips on writing generic interfaces (protocols or not)","anchor":"Tips-on-writing-generic-interfaces-protocols-or-not"},{"type":"heading","level":3,"text":"`some`","anchor":"some"},{"type":"paragraph","inlineContent":[{"text":"Swift 5.6 and earlier:","type":"text"}]},{"type":"codeListing","code":["func feed<A>(_ animal: A) where A: Animal","","\/\/ üëÜüèªüëáüèª Equivalents","","func feed<A: Animal>(_ animal: A)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift 5.7 and later:"}]},{"type":"codeListing","code":["func feed(_ animal: some Animal)"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"we can express an abstract type in terms of the protocol conformance by writing "},{"type":"codeVoice","code":"some xxx"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"all three declarations above are identical, but the newer one is much easier to read and understand"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"the "},{"code":"some","type":"codeVoice"},{"type":"text","text":" keyword can be used in parameter and result types"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"with "},{"type":"codeVoice","code":"some"},{"type":"text","text":", there is a specific underlying type that cannot vary"}],"type":"paragraph"}]}]},{"type":"heading","level":3,"text":"`any`","anchor":"any"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"if we need to express an arbitrary type a protocol, for example to store multiple into an array, we can use "},{"code":"any","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"with "},{"type":"codeVoice","code":"any"},{"type":"text","text":", the underlying type can vary at runtime"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"any xxx"},{"text":" is a single static type that has the capability to store any concrete ","type":"text"},{"type":"codeVoice","code":"X"},{"text":"-conforming type dynamically, which allows us to use subtype polymorphism with value types","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"to allow for "},{"code":"any","type":"codeVoice"},{"type":"text","text":" required flexible storage, the "},{"code":"any X","type":"codeVoice"},{"type":"text","text":" type has a special representation in memory"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"you can think of this representation as a fixed box:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"if the concrete type can fit within the box, it will be stored there"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"the box will store a pointer to the instance otherwise","type":"text"}],"type":"paragraph"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"the static type ","type":"text"},{"type":"codeVoice","code":"any X"},{"text":" that can dynamically store any concrete ","type":"text"},{"type":"codeVoice","code":"X"},{"text":" type is called an ","type":"text"},{"text":"existential type","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the strategy of using the same representation for different concrete types is called "},{"type":"text","text":"type erasure"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the concrete type is said to be "},{"type":"emphasis","inlineContent":[{"text":"erased","type":"text"}]},{"type":"text","text":" at compile time, and the concrete type is only known at runtime"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"type erasure eliminates the type-level distinction between different "},{"code":"X","type":"codeVoice"},{"type":"text","text":"-conforming instances, which allows us to use values with different dynamic types interchangeably as the same static type"}],"type":"paragraph"}]}]},{"type":"heading","level":2,"text":"`some` vs. `any`","anchor":"some-vs-any"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"the compiler can convert an instance of ","type":"text"},{"type":"codeVoice","code":"any X"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"some x"},{"text":" by unboxing the underlying value and passing it directly to the ","type":"text"},{"type":"codeVoice","code":"some X"},{"text":" parameter","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"new in Swift 5.7","type":"text"}]}]}],"type":"unorderedList"}]}]},{"type":"table","header":"row","rows":[[[{"type":"paragraph","inlineContent":[{"code":"some","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"any"}]}]],[[{"type":"paragraph","inlineContent":[{"text":"holds a fixed concrete type","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"holds an arbitrary concrete type","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"guarantees type relationships"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"erases type relationships"}]}]]]},{"type":"paragraph","inlineContent":[{"text":"Guidelines:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"use "},{"code":"some","type":"codeVoice"},{"type":"text","text":" by default"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"change to ","type":"text"},{"code":"any","type":"codeVoice"},{"text":" when you need to store arbitrary values (arbitrary concrete types instances)","type":"text"}]}]}]},{"type":"heading","level":2,"text":"Written By","anchor":"Written-By"},{"columns":[{"content":[{"inlineContent":[{"identifier":"Jeehut","type":"image"}],"type":"paragraph"}],"size":1},{"content":[{"type":"heading","level":3,"text":"Cihat G√ºnd√ºz","anchor":"Cihat-G√ºnd√ºz"},{"type":"paragraph","inlineContent":[{"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"isActive":true,"overridingTitle":"Contributed Notes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/Jeehut","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/Jeehut","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/x.com\/Jeehut","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/fline.dev","type":"reference"}]}],"size":4}],"type":"row","numberOfColumns":5},{"columns":[{"size":1,"content":[{"inlineContent":[{"identifier":"zntfdr","type":"image"}],"type":"paragraph"}]},{"size":4,"content":[{"text":"Federico Zanetello","level":3,"type":"heading","anchor":"Federico-Zanetello"},{"inlineContent":[{"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"isActive":true,"overridingTitle":"Contributed Notes"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/zntfdr","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/zntfdr.dev","isActive":true}],"type":"paragraph"}]}],"type":"row","numberOfColumns":5},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","isActive":true,"type":"reference"}]},{"type":"heading","level":2,"text":"Related Sessions","anchor":"Related-Sessions"},{"type":"links","style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10168-Generalize-APIs-with-parameter-packs","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110353-Design-protocol-interfaces-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110354-Whats-new-in-Swift"]},{"type":"small","inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright ¬© 2012 ‚Äì 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"metadata":{"role":"sampleCode","title":"Embrace Swift generics","modules":[{"name":"WWDC Notes"}],"roleHeading":"WWDC22"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22"]]},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110352-Embrace-Swift-generics","interfaceLanguage":"swift"},"sampleCodeDownload":{"action":{"identifier":"https:\/\/developer.apple.com\/wwdc22\/110352","type":"reference","overridingTitle":"Watch Video (27 min)","isActive":true},"kind":"sampleDownload"},"references":{"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"images":[{"type":"card","identifier":"zntfdr.jpeg"},{"type":"icon","identifier":"zntfdr.jpeg"}],"type":"topic","role":"sampleCode","title":"Federico Zanetello (332 notes)","abstract":[{"type":"text","text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more."}],"url":"\/documentation\/wwdcnotes\/zntfdr","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"Jeehut.jpeg":{"variants":[{"url":"\/images\/Jeehut.jpeg","traits":["1x","light"]}],"type":"image","alt":null,"identifier":"Jeehut.jpeg"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22","title":"WWDC22","images":[{"identifier":"WWDC22-Icon.png","type":"icon"},{"identifier":"WWDC22.jpeg","type":"card"}],"url":"\/documentation\/wwdcnotes\/wwdc22","role":"collectionGroup","type":"topic","kind":"article","abstract":[{"text":"Xcode 14, Swift 5.7, iOS 16, macOS 13 (Ventura), tvOS 16, watchOS 9.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"type":"codeVoice","code":"WeatherKit"},{"text":", ","type":"text"},{"type":"codeVoice","code":"ScreenCaptureKit"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Swift Regex"},{"text":", and more.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","url":"\/documentation\/wwdcnotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"title":"WWDC Notes","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","images":[{"identifier":"WWDCNotes.png","type":"icon"}]},"zntfdr.jpeg":{"variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image","alt":null,"identifier":"zntfdr.jpeg"},"https://github.com/Jeehut":{"titleInlineContent":[{"type":"text","text":"GitHub"}],"url":"https:\/\/github.com\/Jeehut","title":"GitHub","type":"link","identifier":"https:\/\/github.com\/Jeehut"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110354-Whats-new-in-Swift":{"abstract":[{"text":"Join us for an update on Swift. We‚Äôll take you through performance improvements, explore more secure and extensible Swift packages, and share advancements in Swift concurrency. We‚Äôll also introduce you to Swift Regex, better generics, and other tools built into the language to help you write more flexible & expressive code.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110354-Whats-new-in-Swift","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc22-110354-whats-new-in-swift","kind":"article","title":"What‚Äôs new in Swift","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/Jeehut":{"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/Jeehut","type":"topic","title":"Cihat G√ºnd√ºz (56 notes)","abstract":[{"text":"Spatial-first Indie Developer for Ô£ø Platforms. Actively contributing to Open Source since 2011!","type":"text"}],"url":"\/documentation\/wwdcnotes\/jeehut","role":"sampleCode","images":[{"identifier":"Jeehut.jpeg","type":"card"},{"identifier":"Jeehut.jpeg","type":"icon"}]},"WWDCNotes.png":{"variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}],"type":"image","alt":null,"identifier":"WWDCNotes.png"},"WWDC22-Icon.png":{"variants":[{"url":"\/images\/WWDC22-Icon.png","traits":["1x","light"]}],"type":"image","alt":null,"identifier":"WWDC22-Icon.png"},"Jeehut":{"variants":[{"url":"\/images\/Jeehut.jpeg","traits":["1x","light"]}],"type":"image","alt":"Profile image of Cihat G√ºnd√ºz","identifier":"Jeehut"},"https://fline.dev":{"titleInlineContent":[{"type":"text","text":"Blog"}],"url":"https:\/\/fline.dev","title":"Blog","type":"link","identifier":"https:\/\/fline.dev"},"zntfdr":{"variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image","alt":"Profile image of Federico Zanetello","identifier":"zntfdr"},"https://github.com/zntfdr":{"titleInlineContent":[{"type":"text","text":"GitHub"}],"url":"https:\/\/github.com\/zntfdr","title":"GitHub","type":"link","identifier":"https:\/\/github.com\/zntfdr"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10168-Generalize-APIs-with-parameter-packs":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10168-Generalize-APIs-with-parameter-packs","role":"sampleCode","abstract":[{"type":"text","text":"Swift parameter packs are a powerful tool to expand what is possible in your generic code while also enabling you to simplify common generic patterns. We‚Äôll show you how to abstract over types as well as the number of arguments in generic code and simplify common generic patterns to avoid overloads."}],"url":"\/documentation\/wwdcnotes\/wwdc23-10168-generalize-apis-with-parameter-packs","kind":"article","title":"Generalize APIs with parameter packs","type":"topic"},"https://x.com/Jeehut":{"titleInlineContent":[{"type":"text","text":"X\/Twitter"}],"url":"https:\/\/x.com\/Jeehut","title":"X\/Twitter","type":"link","identifier":"https:\/\/x.com\/Jeehut"},"https://zntfdr.dev":{"titleInlineContent":[{"type":"text","text":"Blog"}],"url":"https:\/\/zntfdr.dev","title":"Blog","type":"link","identifier":"https:\/\/zntfdr.dev"},"https://developer.apple.com/wwdc22/110352":{"url":"https:\/\/developer.apple.com\/wwdc22\/110352","checksum":null,"type":"download","identifier":"https:\/\/developer.apple.com\/wwdc22\/110352"},"WWDC22.jpeg":{"type":"image","identifier":"WWDC22.jpeg","variants":[{"url":"\/images\/WWDC22.jpeg","traits":["1x","light"]}],"alt":null},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110353-Design-protocol-interfaces-in-Swift":{"type":"topic","title":"Design protocol interfaces in Swift","abstract":[{"type":"text","text":"Learn how you can use Swift 5.7 to design advanced abstractions using protocols. We‚Äôll show you how to use existential types, explore how you can separate implementation from interface with opaque result types, and share the same-type requirements that can help you identify and guarantee relationships between concrete types."}],"url":"\/documentation\/wwdcnotes\/wwdc22-110353-design-protocol-interfaces-in-swift","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110353-Design-protocol-interfaces-in-Swift","role":"sampleCode"}}}