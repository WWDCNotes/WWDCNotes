{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc21-10133-protect-mutable-state-with-swift-actors"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors"},"sections":[],"abstract":[{"text":"Data races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug.","type":"text"}],"metadata":{"modules":[{"name":"WWDC Notes"}],"roleHeading":"WWDC21","role":"sampleCode","title":"Protect mutable state with Swift actors"},"sampleCodeDownload":{"kind":"sampleDownload","action":{"type":"reference","overridingTitle":"Watch Video (28 min)","isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc21\/10133"}},"schemaVersion":{"patch":0,"major":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21"]]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"overview"},{"inlineContent":[{"text":"Data races occur when:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Two (or more) threads concurrently access the same data","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"One of them is a write","type":"text"}]}]}]},{"inlineContent":[{"text":"Shared mutable state in concurrent programs:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Shared mutable state requires synchronization - this synchronization ensures that concurrent use of our shared mutable state won‚Äôt cause data races","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"various primitives exist: atomics, locks, serial dispatch queues"}],"type":"paragraph"}]}]},{"level":2,"text":"Actors","type":"heading","anchor":"Actors"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Actors provide synchronization for shared mutable state","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Actors isolate their state from the rest of the program"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"the only way to access that state is by going through the actor","type":"text"}]}]}]}]}]},{"syntax":"swift","type":"codeListing","code":["actor Counter { \/\/ üëàüèª","  var value = 0","","  \/\/\/ When this method is called, it is guaranteed by the actor that it will ","  \/\/\/ run to completion without any other code executing on the actor.","  func increment() -> Int {","    value = value + 1","    return value","  }","}","","let counter = Counter()","","Task.detached {","  \/\/     üëáüèª Whenever you interact with an actor from the outside, you do so asynchronously","  print(await counter.increment())","}","","Task.detached {","  \/\/     üëáüèª Whenever you interact with an actor from the outside, you do so asynchronously","  print(await counter.increment())","}"]},{"name":"Note","content":[{"inlineContent":[{"text":"Two calls to ","type":"text"},{"code":"counter.increment()","type":"codeVoice"},{"text":" will always bring to the same result, it is guaranteed that we will never encounter an ","type":"text"},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Readers‚Äìwriters_problem","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}],"type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"Actors provide the same capabilities as all of the named types in Swift:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"They can have properties, methods, initializers, subscripts, and so on","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"They can conform to protocols and be augmented with extensions","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"They are reference types; because the purpose of actors is to express shared mutable state","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"The primary distinguishing characteristic of actor types is that they isolate their instance data from the rest of the program and ensure synchronized access to that data. Actor eliminates the potential for data races on the actor‚Äôs state.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Calls within an actor are synchronous","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Synchronous code always runs uninterrupted"}],"type":"paragraph"}]}]},{"syntax":"swift","type":"codeListing","code":["extension Counter {","  func resetSlowly(to newValue: Int) {","    value = 0","    for _ in 0..<newValue {","      increment() \/\/ no need await, as we're already running code within the actor","    }","    assert(value == newValue)","  }","}"]},{"level":2,"text":"Actor reentrancy","type":"heading","anchor":"Actor-reentrancy"},{"inlineContent":[{"type":"text","text":"We are building an image downloader actor:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["actor ImageDownloader {","  private var cache: [URL: Image] = [:]","","  func image(from url: URL) async throws -> Image? {","    if let cached = cache[url] { return cached }","","    let image = try await downloadImage(from: url)","    cache[url] = image \/\/ üëàüèª Potential bug: `cache` may have changed","    return image","  }","}"]},{"inlineContent":[{"text":"Despite running on an actor, we have a bug:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"imagine triggering "},{"type":"codeVoice","code":"image(from:)"},{"type":"text","text":", missing cache and await on "},{"type":"codeVoice","code":"downloadImage(from:)"},{"type":"text","text":", at that point the execution suspends"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"while waiting we trigger ","type":"text"},{"code":"image(from:)","type":"codeVoice"},{"text":" again, with the same url","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"because the first run is suspended, the second will run until it awaits as well on "},{"code":"downloadImage(from:)","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"at some point in the future both calls will return and will write to the same ","type":"text"},{"code":"cache[url]","type":"codeVoice"},{"text":" place","type":"text"}],"type":"paragraph"}]}]},{"name":"Remember","content":[{"inlineContent":[{"type":"text","text":"Actor guarantees that only one flow can run within the actor at any given time, but when an execution suspends, others can run on the same actor."}],"type":"paragraph"}],"type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"The potential bug is on the fact that the backend might have changed image data between the two "},{"type":"codeVoice","code":"downloadImage(from:)"},{"type":"text","text":" calls, making our app return different images between the different calls."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this case, the fix is to replace the image cache only if it is still missing from the cache after the "},{"type":"codeVoice","code":"downloadImage(from:)"},{"type":"text","text":" call:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["actor ImageDownloader {","  private var cache: [URL: Image] = [:]","","  func image(from url: URL) async throws -> Image? {","    if let cached = cache[url] {","      return cached","    }","","    let image = try await downloadImage(from: url)","","    cache[url] = cache[url, default: image] \/\/ üëàüèª","    return cache[url]","  }","}"]},{"inlineContent":[{"text":"A better solution would be to avoid downloading the same image multiple times:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["actor ImageDownloader {","","  private enum CacheEntry {","    case inProgress(Task<Image, Error>)","    case ready(Image)","  }","","  private var cache: [URL: CacheEntry] = [:]","","  func image(from url: URL) async throws -> Image? {","    if let cached = cache[url] {","      switch cached {","        case .ready(let image):","          return image","        case .inProgress(let task):","          return try await task.value","      }","    }","","    let task = Task {","      try await downloadImage(from: url)","    }","","    cache[url] = .inProgress(task)","","    do {","      let image = try await task.value","      cache[url] = .ready(image)","      return image","    } catch {","      cache[url] = nil","      throw error","    }","  }","}"]},{"inlineContent":[{"type":"text","text":"Actor reentrancy prevents deadlocks and guarantees forward progress, but it requires you to check your assumptions across each await."}],"type":"paragraph"},{"inlineContent":[{"text":"Reentrancy tips:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Perform mutation of actor state within synchronous code. Ideally, do it within a synchronous function so all state changes are well-encapsulated"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"State changes can involve temporarily putting our actor into an inconsistent state - make sure to restore consistency before an "},{"code":"await","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Expect that the actor state could change during suspension - all ","type":"text"},{"code":"await","type":"codeVoice"},{"text":"s are potential suspension points","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Check your assumptions after resuming (after an "},{"type":"codeVoice","code":"await"},{"type":"text","text":")"}]}]}]},{"level":2,"text":"Actor isolation","type":"heading","anchor":"Actor-isolation"},{"level":3,"text":"Extensions","type":"heading","anchor":"Extensions"},{"inlineContent":[{"type":"text","text":"Consider the following actor definition and extension:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["actor LibraryAccount {","  let idNumber: Int","  var booksOnLoan: [Book] =[]","}","","extension LibraryAccount: Equatable {","  static func ==(lhs: LibraryAccount, rhs: LibraryAccount) -> Bool {","    lhs.idNumber == rhs.idNumber","  }","}"]},{"inlineContent":[{"text":"The static equality method compares two library accounts based on their ID numbers. Because the method is static, there is no ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" instance and so it is not isolated to the actor. Instead, we have two parameters of actor type, and this static method is outside of both of them. That‚Äôs OK because the implementation is only accessing immutable state (","type":"text"},{"code":"let idNumber","type":"codeVoice"},{"text":") on the actors.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Consider the following extension:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension LibraryAccount: Hashable {","  func hash(into hasher: inout Hasher) {","    hasher.combine(idNumber)","  }","}"]},{"inlineContent":[{"text":"This time it is not ok: conforming to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" this way means that ","type":"text"},{"type":"codeVoice","code":"hash(into:)"},{"text":" could be called from outside the actor, and this method is not ","type":"text"},{"type":"codeVoice","code":"async"},{"text":", so there is no way to maintain actor isolation. To fix this, we can make this method ","type":"text"},{"type":"codeVoice","code":"nonisolated"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension LibraryAccount: Hashable {","  \/\/ üëáüèª","  nonisolated func hash(into hasher: inout Hasher) {","    hasher.combine(idNumber)","  }","}"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"nonisolated"},{"text":" means that this method is treated as being outside the actor, even though it is, syntactically, described on the actor","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This means that it can satisfy the synchronous requirement from the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol"}]}]},{"content":[{"inlineContent":[{"text":"Because ","type":"text"},{"code":"nonisolated","type":"codeVoice"},{"text":" methods are treated as being outside the actor, they cannot reference mutable state on the actor","type":"text"}],"type":"paragraph"}]}]},{"level":3,"text":"Closures","type":"heading","anchor":"Closures"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Like functions, a closure might be actor-isolated or it might be nonisolated"}]}]}]},{"syntax":"swift","type":"codeListing","code":["extension LibraryAccount {","  func readSome(_ book: Book) -> Int { ... }","  ","  func read() -> Int {","    booksOnLoan.reduce(0) { book in","      readSome(book)","    }","  }","}"]},{"level":2,"text":"Sendable types","type":"heading","anchor":"Sendable-types"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Sendable types are types whose values can be safely shared across different actors:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"value types - because each copy is independent"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Actor types - because they synchronize access to their mutable state","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Immutable classes - as they‚Äôre read-only"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Internally-synchronized classes - for example with a lock"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"@Sendable"},{"text":" function types","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"all of your concurrent code should primarily communicate in terms of "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" types"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Sendable"},{"text":" types protect code from data races","type":"text"}]}]}]},{"level":3,"text":"Conforming to `Sendable`","type":"heading","anchor":"Conforming-to-Sendable"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sendable"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Swift will then check to make sure your type makes sense as a "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" type"}],"type":"paragraph"}]}]},{"syntax":"swift","type":"codeListing","code":["struct Book: Sendable {","  var title: String","  var authors: [Author] \/\/ Author is a struct type","}"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"This struct can be "},{"code":"Sendable","type":"codeVoice"},{"type":"text","text":", as all of its stored properties are of "},{"code":"Sendable","type":"codeVoice"},{"type":"text","text":" type"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"Author"},{"type":"text","text":" was a non-"},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" class, then this code would not compile"}]}]}]},{"inlineContent":[{"text":"For generic types, we can use conditional conformance to propagate ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" when it‚Äôs appropriate:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Pair<T, U> {","  var first: T","  var second: U","}","","extension Pair: Sendable where T: Sendable, U: Sendable {}"]},{"inlineContent":[{"code":"@Sendable","type":"codeVoice"},{"text":" functions:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"@Sendable","type":"codeVoice"},{"text":" function types conform to the ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" protocol","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"@Sendable","type":"codeVoice"},{"text":" places restrictions on closures:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"No mutable captures - otherwise it‚Äôd allow data races on the local variable","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Captures must be of ","type":"text"},{"code":"Sendable","type":"codeVoice"},{"text":" type - this makes sure that the closure cannot be used to move non-Sendable types across actor boundaries","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Cannot be both synchronous and actor-isolated - otherwise it‚Äôd allow code to be run on the actor from the outside"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Task.detached(operation:)"},{"type":"text","text":" accepts a "},{"type":"codeVoice","code":"@Sendable"},{"type":"text","text":" closure:"}],"type":"paragraph"}]}]},{"syntax":"swift","type":"codeListing","code":["static func detached(operation: @Sendable () async -> Success) -> Task<Success, Never>"]},{"level":2,"text":"Main actor","type":"heading","anchor":"Main-actor"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"special actor that represents the main thread","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"differs from a normal actor in two ways:"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"the main actor performs all of its synchronization through the main dispatch queue - from a runtime perspective, the main actor is interchangeable with using DispatchQueue.main"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the code and data that needs to be on the main thread is scattered everywhere"}]}]}]}]}]},{"syntax":"swift","type":"codeListing","code":["@MainActor func checkedOut(_ booksOnLoan: [Book]) {","  booksView.checkedOutBooks = booksOnLoan","}","","\/\/ Swift ensures that this code is always run on the main thread.","await checkedOut(booksOnLoan)"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"By marking code that must run on the main thread as being on the main actor, there is no more guesswork about when to use ","type":"text"},{"code":"DispatchQueue.main","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Swift ensures that this code is always executed on the main thread","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"Types can be placed on the main actor:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Implies that all methods and properties of the type are "},{"code":"MainActor","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Opt out individual members with ","type":"text"},{"type":"codeVoice","code":"nonisolated"}]}]}]},{"syntax":"swift","type":"codeListing","code":["@MainActor class MyViewController: UIViewController {","  func onPress(...) { ... } \/\/ implicitly @MainActor","","  nonisolated func fetchLatestAndDisplay() async { ... } ","}"]},{"level":2,"text":"Written By","type":"heading","anchor":"Written-By"},{"columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"identifier":"zntfdr","type":"image"}]}]},{"size":4,"content":[{"text":"Federico Zanetello","anchor":"Federico-Zanetello","level":3,"type":"heading"},{"inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","type":"reference","isActive":true,"overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}]},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/zntfdr","type":"reference","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"https:\/\/zntfdr.dev","type":"reference","isActive":true}],"type":"paragraph"}]}],"type":"row","numberOfColumns":5},{"type":"thematicBreak"},{"inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","isActive":true}],"type":"paragraph"},{"level":2,"text":"Related Sessions","type":"heading","anchor":"Related-Sessions"},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110356-Meet-distributed-actors-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110360-Use-Xcode-for-serverside-development","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10019-Discover-concurrency-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10054-Whats-new-in-AppKit","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10192-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"],"type":"links","style":"list"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"text":"All content copyright ¬© 2012 ‚Äì 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}],"type":"small"}]}],"kind":"article","references":{"WWDC21.jpeg":{"identifier":"WWDC21.jpeg","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC21.jpeg"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21":{"abstract":[{"type":"text","text":"Xcode 13, Swift 5.5, iOS 15, macOS 12 (Monterey), tvOS 15, watchOS 8."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"MusicKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"DocC"},{"type":"text","text":", "},{"type":"codeVoice","code":"StoreKit 2"},{"type":"text","text":", and more."}],"url":"\/documentation\/wwdcnotes\/wwdc21","title":"WWDC21","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21","role":"collectionGroup","kind":"article","images":[{"identifier":"WWDC21-Icon.png","type":"icon"},{"identifier":"WWDC21.jpeg","type":"card"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10254-Swift-concurrency-Behind-the-scenes":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes","abstract":[{"text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We‚Äôll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps.","type":"text"}],"kind":"article","title":"Swift concurrency: Behind the scenes","url":"\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes","type":"topic","role":"sampleCode"},"WWDCNotes.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDCNotes.png"}],"alt":null,"type":"image","identifier":"WWDCNotes.png"},"https://developer.apple.com/documentation/swift/sendable":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sendable","titleInlineContent":[{"type":"codeVoice","code":"Sendable"},{"type":"text","text":" is a protocol"}],"type":"link","title":"Sendable is a protocol","url":"https:\/\/developer.apple.com\/documentation\/swift\/sendable"},"zntfdr.jpeg":{"identifier":"zntfdr.jpeg","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/zntfdr.jpeg"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10194-Swift-concurrency-Update-a-sample-app":{"abstract":[{"text":"Discover Swift concurrency in action: Follow along as we update an existing sample app. Get real-world experience with async\/await, actors, and continuations. We‚Äôll also explore techniques for migrating existing code to Swift concurrency over time.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","title":"Swift concurrency: Update a sample app","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10194-swift-concurrency-update-a-sample-app","kind":"article","type":"topic"},"WWDC21-Icon.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC21-Icon.png"}],"type":"image","identifier":"WWDC21-Icon.png","alt":null},"https://github.com/zntfdr":{"url":"https:\/\/github.com\/zntfdr","title":"GitHub","titleInlineContent":[{"type":"text","text":"GitHub"}],"type":"link","identifier":"https:\/\/github.com\/zntfdr"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110350-Visualize-and-optimize-Swift-concurrency":{"type":"topic","title":"Visualize and optimize Swift concurrency","url":"\/documentation\/wwdcnotes\/wwdc22-110350-visualize-and-optimize-swift-concurrency","kind":"article","abstract":[{"type":"text","text":"Learn how you can optimize your app with the Swift Concurrency template in Instruments. We‚Äôll discuss common performance issues and show you how to use Instruments to find and resolve these problems. Learn how you can keep your UI responsive, maximize parallel performance, and analyze Swift concurrency activity within your app."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes":{"abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"url":"\/documentation\/wwdcnotes","title":"WWDC Notes","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","kind":"symbol","images":[{"type":"icon","identifier":"WWDCNotes.png"}]},"https://developer.apple.com/wwdc21/10133":{"identifier":"https:\/\/developer.apple.com\/wwdc21\/10133","checksum":null,"type":"download","url":"https:\/\/developer.apple.com\/wwdc21\/10133"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10192-Whats-new-in-Swift":{"url":"\/documentation\/wwdcnotes\/wwdc21-10192-whats-new-in-swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10192-Whats-new-in-Swift","kind":"article","role":"sampleCode","type":"topic","title":"What‚Äòs new in Swift","abstract":[{"text":"Join us for an update on Swift. Discover the latest language advancements that make your code easier to read and write. Explore the growing number of APIs available as Swift packages. And we‚Äôll introduce you to Swift‚Äôs async\/await syntax, structured concurrency, and actors.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"kind":"article","url":"\/documentation\/wwdcnotes\/zntfdr","role":"sampleCode","abstract":[{"type":"text","text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more."}],"type":"topic","title":"Federico Zanetello (332 notes)","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","images":[{"type":"card","identifier":"zntfdr.jpeg"},{"type":"icon","identifier":"zntfdr.jpeg"}]},"https://zntfdr.dev":{"titleInlineContent":[{"type":"text","text":"Blog"}],"type":"link","identifier":"https:\/\/zntfdr.dev","title":"Blog","url":"https:\/\/zntfdr.dev"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10134-Explore-structured-concurrency-in-Swift":{"url":"\/documentation\/wwdcnotes\/wwdc21-10134-explore-structured-concurrency-in-swift","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","abstract":[{"type":"text","text":"When you have code that needs to run at the same time as other code, it‚Äôs important to choose the right tool for the job. We‚Äôll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We‚Äôll also provide guidance on when you may want to use unstructured tasks."}],"role":"sampleCode","title":"Explore structured concurrency in Swift","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10054-Whats-new-in-AppKit":{"abstract":[{"text":"Explore the latest advancements in Mac app development with AppKit. We‚Äôll show how you can enhance your app‚Äôs design with new control features and SF Symbols 3, build powerful text experiences using TextKit 2, and harness the latest Swift features in your app.","type":"text"}],"role":"sampleCode","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10054-Whats-new-in-AppKit","title":"What‚Äôs new in AppKit","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc21-10054-whats-new-in-appkit"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110360-Use-Xcode-for-serverside-development":{"url":"\/documentation\/wwdcnotes\/wwdc22-110360-use-xcode-for-serverside-development","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110360-Use-Xcode-for-serverside-development","kind":"article","role":"sampleCode","type":"topic","title":"Use Xcode for server-side development","abstract":[{"text":"Discover how you can create, build, and deploy a Swift server app alongside your pre-existing Xcode projects within the same workspace. We‚Äôll show you how to create your own local app and test endpoints using Xcode, and explore how you can structure and share code between server and client apps to ease your development process","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110356-Meet-distributed-actors-in-Swift":{"url":"\/documentation\/wwdcnotes\/wwdc22-110356-meet-distributed-actors-in-swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110356-Meet-distributed-actors-in-Swift","role":"sampleCode","type":"topic","title":"Meet distributed actors in Swift","abstract":[{"type":"text","text":"Discover distributed actors ‚Äî an extension of Swift‚Äôs actor model that simplifies development of distributed systems. We‚Äôll explore how distributed actor isolation and location transparency can help you avoid the accidental complexity of networking, serialization, and other transport concerns when working with distributed apps and systems."}],"kind":"article"},"zntfdr":{"identifier":"zntfdr","type":"image","alt":"Profile image of Federico Zanetello","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/zntfdr.jpeg"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10132-Meet-asyncawait-in-Swift":{"kind":"article","title":"Meet async\/await in Swift","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","url":"\/documentation\/wwdcnotes\/wwdc21-10132-meet-asyncawait-in-swift","abstract":[{"text":"Swift now supports asynchronous functions ‚Äî a pattern commonly known as async\/await. Discover how the new syntax can make your code easier to read and understand. Learn what happens when a function suspends, and find out how to adapt existing completion handlers to asynchronous functions.","type":"text"}],"type":"topic"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"https://en.wikipedia.org/wiki/Readers‚Äìwriters_problem":{"titleInlineContent":[{"type":"text","text":"Readers‚Äìwriters problem"}],"type":"link","identifier":"https:\/\/en.wikipedia.org\/wiki\/Readers‚Äìwriters_problem","title":"Readers‚Äìwriters problem","url":"https:\/\/en.wikipedia.org\/wiki\/Readers‚Äìwriters_problem"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10019-Discover-concurrency-in-SwiftUI":{"abstract":[{"text":"Discover how you can use Swift‚Äôs concurrency features to build even better SwiftUI apps. We‚Äôll show you how concurrent workflows interact with your ObservableObjects, and explore how you can use them directly in your SwiftUI views and models. Find out how to use await to make your app run smoothly on the SwiftUI runloop, and learn how to fetch remote images quickly with the AsyncImage API. And we‚Äôll take you through the process of enabling additional asynchronous flows in your custom views.","type":"text"}],"role":"sampleCode","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10019-Discover-concurrency-in-SwiftUI","title":"Discover concurrency in SwiftUI","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc21-10019-discover-concurrency-in-swiftui"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency":{"url":"\/documentation\/wwdcnotes\/wwdc22-110351-eliminate-data-races-using-swift-concurrency","title":"Eliminate data races using Swift Concurrency","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","kind":"article","role":"sampleCode","abstract":[{"type":"text","text":"Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We‚Äôll take you through Swift‚Äôs approach to eliminating data races and its effect on app architecture. We‚Äôll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system."}]}}}