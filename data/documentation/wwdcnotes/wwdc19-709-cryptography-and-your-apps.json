{"schemaVersion":{"patch":0,"major":0,"minor":3},"sampleCodeDownload":{"action":{"overridingTitle":"Watch Video (38 min)","identifier":"https:\/\/developer.apple.com\/wwdc19\/709","isActive":true,"type":"reference"},"kind":"sampleDownload"},"variants":[{"paths":["\/documentation\/wwdcnotes\/wwdc19-709-cryptography-and-your-apps"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-709-Cryptography-and-Your-Apps"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19"]]},"kind":"article","abstract":[{"text":"System frameworks encrypt both data at rest and data in transit in a transparent way for you. This functionality is available by simply setting an attribute. However you may want to do more to protect your users‚Äô data. CryptoKit is a new Swift framework that makes it easier and safer than ever to perform cryptographic operations, whether you simply need to compute a hash or are implementing a more advanced authentication protocol.","type":"text"}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Intro","level":2,"anchor":"Intro"},{"type":"heading","text":"Foundation of Apple Security and Privacy Features","level":3,"anchor":"Foundation-of-Apple-Security-and-Privacy-Features"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-foundation"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Security and privacy are core values at Apple.  We built it in all of the features that we work on, and cryptography is a big part of it."},{"type":"text","text":"\n"},{"type":"text","text":"For example, with device integrity we use cryptography to validate the integrity of the software running on the platform to make sure it has not been tampered with and guarantee its security properties are not changed."},{"type":"text","text":"\n"},{"type":"text","text":"We use cryptography across a wide variety of applications users love, use extensively for capturing very personal moments and sharing them. This is a case of Messages, Safari, and iCloud."}]},{"type":"heading","text":"Cryptography is a tool.","level":3,"anchor":"Cryptography-is-a-tool"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Authentication, knowing who sent you a message."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Encryption, knowing that that message can be only be decrypted by you."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Integrity, knowing that no one else could have modified the content of that message before it got to you."}]}]},{"content":[{"inlineContent":[{"text":"Compose primitives into protocols","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","text":"Cryptography Is Hard to Get Right","level":2,"anchor":"Cryptography-Is-Hard-to-Get-Right"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-crypto"}]},{"type":"heading","text":"System Features","level":1,"anchor":"System-Features"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Common Cases Covered in this talk:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Protect data on device"}]}]},{"content":[{"inlineContent":[{"text":"Protect credentials and keys","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Share data across devices and users","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Secure network connections"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Verify remote parties","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","text":"Protect data on device","level":1,"anchor":"Protect-data-on-device"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC19-709-crypto2","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Data protection combines the strengths of the passcode with the hardware technologies in the Secure Enclave to make sure the keys are well secured, and the encrypted data cannot be used to brute-force the passcode."},{"type":"text","text":" "},{"type":"text","text":"Data protection provides post compromise recovery."},{"type":"text","text":" "},{"type":"text","text":"Post compromise recovery, also known as forward secrecy, guarantees that if adversary gets his hand on the keys on the device and the users change the passcode, all the data encrypted after that cannot be recovered from those old keys."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can look at the iOS security white paper to get more information:"}]},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"https:\/\/www.apple.com\/business\/docs\/site\/iOS_Security_Guide.pdf","isActive":true}]},{"type":"paragraph","inlineContent":[{"text":"There is the complete file protection.","type":"text"},{"text":" ","type":"text"},{"text":"Complete file protection means the data is only available after the user unlocks his phone.","type":"text"},{"text":" ","type":"text"},{"text":"As soon as the user locks his phone back, put it back in the pocket or in a bag, the data is secure again.","type":"text"},{"text":" ","type":"text"},{"text":"Here‚Äôs an example.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Make files available only when device is unlocked:"}]},{"code":["\/\/ Write file, available only when device is unlocked ","do { ","  try data.write(to: fileURL, options: .completeFileProtection) ","} ","catch { ","  \/\/ Handle errors ","} "],"syntax":"swift","type":"codeListing"},{"type":"heading","text":"Protect Credentials and Keys","level":1,"anchor":"Protect-Credentials-and-Keys"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There may be more sensitive information that you may want to protect."},{"type":"text","text":" "},{"type":"text","text":"There could be credentials like authentication tokens used to authenticate on services or cryptography keys."},{"type":"text","text":" "},{"type":"text","text":"Please don‚Äôt write them in defaults that you could see on all the platforms."}]},{"type":"paragraph","inlineContent":[{"text":"Instead, there is Keychain.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC19-709-crypto3","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Keychain in the Secitem APIs allows you to write those items as in the local Keychain, which means they stay on that one device or on iCloud Keychain where they synchronize across all of the devices for a seamless experience in the user account.","type":"text"},{"text":" ","type":"text"},{"text":"This requires user accounts with two-factor authentication enabled.","type":"text"},{"text":" ","type":"text"},{"text":"For Keychain, you find very similar protection as for the files that I mentioned before and a few extra ones.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In addition to when a key is cryptographically available, sometimes important for you to know how the user authenticated it and when.","type":"text"},{"text":" ","type":"text"},{"text":"This is why we have LocalAuthentication.","type":"text"},{"text":" ","type":"text"},{"text":"LocalAuthentication allows you to put restrictions as to when an operation can be executed.","type":"text"},{"text":" ","type":"text"},{"text":"For example, you could define that it is required for the user to authenticate with biometrics with Face ID.","type":"text"}]},{"type":"heading","text":"New LocalAuthentication Policies","level":3,"anchor":"New-LocalAuthentication-Policies"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"On macOS","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-crypto4"}]},{"type":"paragraph","inlineContent":[{"text":"On macOS, you‚Äôre used to device authentication properties, and it gives two way for the user to authenticate, the password or biometrics for Macs which support biometrics with Touch ID.","type":"text"},{"text":" ","type":"text"},{"text":"The user can authenticate with Apple Watch and a double-click on Apple Watch.","type":"text"},{"text":" ","type":"text"},{"text":"It‚Äôs a great new experience, which is going to reduce the use of the password and reduce the friction, improves user experience.","type":"text"},{"text":" ","type":"text"},{"text":"Now, with these new capabilities we added two new policies:","type":"text"},{"text":"\n","type":"text"},{"code":"LAPolicyDeviceOwnerAuthenticationWithBiometricsOrWatch","type":"codeVoice"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"text":"To reduce the authentication to biometrics only and Watch.","type":"text"},{"text":"\n","type":"text"},{"text":"And:","type":"text"},{"text":"\n","type":"text"},{"code":"LAPolicyDeviceOwnerAuthenticationwithwatch","type":"codeVoice"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"text":"for the Watch alone.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"code":"LocalAuthentication","type":"codeVoice"},{"type":"text","text":": "},{"code":"LocalAuthentication","type":"codeVoice"},{"type":"text","text":" allows you to put restrictions as to when an operation can be executed. For example, you could define that it is required for the user to authenticate with biometrics with Face ID."}]},{"type":"paragraph","inlineContent":[{"text":"Store credentials and keys in the Keychain (SecItem).","type":"text"}]},{"type":"heading","text":"Share Data Across Devices and Users","level":1,"anchor":"Share-Data-Across-Devices-and-Users"},{"type":"paragraph","inlineContent":[{"text":"There is an easy way to synchronize items across all of the devices of an account. What if you have data? Well, for data we have a great solution too. CloudKit!","type":"text"},{"text":" ","type":"text"},{"text":"Use a Private CloudKit Database to share data across devices and users:","type":"text"},{"text":" ","type":"text"},{"text":"Encrypt assets in Private CloudKit Database:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"No need for application user sign in"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Apple as a trusted party","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"iCloud identities and access control","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC19-709-crypto5","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Here is an example:","type":"text"}]},{"code":["\/\/ Save the contents of a given fileURL to a per-user location","let asset = CKAsset(fileURL: ...)","let record: CKRecord = ...","record[\"AssetField\"] = asset","let database = CKContainer.default().privateCloudDatabase","database.save(record){ ... }"],"syntax":"swift","type":"codeListing"},{"type":"heading","text":"Secure Network Connection","level":1,"anchor":"Secure-Network-Connection"},{"type":"paragraph","inlineContent":[{"text":"What when you want it done on data from your own server for example.","type":"text"},{"text":" ","type":"text"},{"text":"Where for that you want to establish a secure connection.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Transport Layer Security.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-crypto6"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use Network framework with default TLS URLSession with App Transport Security. Our implementation of TLS also use TLS 1.3 by default."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A couple of examples:"}]},{"code":["\/\/ With Network Framework","let conn = NWConnection(host: \"imap.mail.me.com\", port: .imaps, using: .tls) ","conn.start(queue: main)","","\/\/ With URLSession","let url = URL(string: \"https:\/\/www.apple.com\")!","let task = URLSession.shared.dataTask(with: url) { (data, response, error) in","\tif let error = error {","\t\t\/\/ Handle error","\t}","\t\/\/ Operation on data","}","task.resume ()"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"With Network Framework, when you establish a connection, the only thing you need to do is using : "},{"type":"codeVoice","code":".tls"},{"type":"text","text":" providing great security and performance."},{"type":"text","text":"\n"},{"type":"text","text":"For URL Session, the only thing here, it‚Äôs the "},{"type":"codeVoice","code":"https"},{"type":"text","text":" endpoint, and this is it."}]},{"type":"heading","text":"Verify Remote Parties","level":1,"anchor":"Verify-Remote-Parties"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC19-709-crypto7","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In some situation, you may not have the possibility to use TLS."},{"type":"text","text":" "},{"type":"text","text":"For example, if you have trying to secure data through a content delivery network, for example. In this case, you manage those certificates. We have SecTrust for that."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify Remote Parties with SecTrust ("},{"code":"SecTrustEvaluateAsyncWithError","type":"codeVoice"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SecTrust provides you an easy way to validate the certificate against a trust policy. The trust policy may contain information about expiration, revocation, and until certificate has been validated, you know that you can use a key. Note that if using TLS you don‚Äôt have a need to worry about certificate."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, in this release, we‚Äôre happy to introduce a new function in SecTrust. This new function combines two things you were able to do before. On one hand, it‚Äôs a function, which allows to asynchronously through an explicit action, do a certificate validation so that your application can do something else while the certificate is being validated."},{"type":"text","text":"\n"},{"type":"text","text":"But also this function gives you a richer handling. So, as a developer, you know what is going on in case of failure, and you can debug it."}]},{"code":["\/\/ Evaluate a certificate validity asynchronously and with legible errors","SecTrustEvaluateAsyncWithError(trust, queue) { (trust, success, error) in","\tif (success) {","\t\tlet publicKey = SecTrustCopyPublicKey(trust)","\t\t\/\/ Use key...","\t} else {","\t\t\/\/ Handle errors","\t}","}"],"syntax":"swift","type":"codeListing"},{"type":"heading","text":"Apple CryptoKit","level":1,"anchor":"Apple-CryptoKit"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-foundation2"}]},{"type":"paragraph","inlineContent":[{"text":"Apple CryptoKit is new Swift cryptographic API which has been designed to follow the same philosophy as for those features we talked about and give you an easy access to cryptographic functions and hard to misuse functions.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use this framework to perform cryptographic operations securely and efficiently."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are four aspects:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"CryptoKit and Swift.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The curated set of algorithms that is available in CryptoKit.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Secure Enclave and biometric authentication","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Performance.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-cryptoKit"}]},{"type":"heading","text":"Apple CryptoKit and Swift","level":2,"anchor":"Apple-CryptoKit-and-Swift"},{"type":"paragraph","inlineContent":[{"text":"-We have a strongly typed API, and whenever you‚Äôre initializing a value, we are verifying that the data you‚Äôre passing is a strong value for that argument.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Thanks to Swift‚Äôs memory management model, we‚Äôre able to zeroize on release all of the secret values allocated within CryptoKit.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"We perform equitable conformances for values like message authentication code if you‚Äôre familiar with that content so that you‚Äôre able to verify two-message authentication codes in constant time by just using the equals equals operator.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"CryptoKit also defines protocols so that you can write generic code over a hash function H, and if in multiple places of your code base you have to pass different hash functions, you can write the code once and then parametrize the function call on a different hash function."}]}]}]},{"type":"paragraph","inlineContent":[{"text":"In the past, you might have had to write code that looks like this when you were calling into C crypto API from Swift.","type":"text"},{"text":"\n","type":"text"},{"text":"You had to allocate buffers, figure out for each of the buffers what size it had to be, and there were values such as the nonce that you might have to search what the safe value for that value was.","type":"text"},{"text":"\n","type":"text"},{"text":"And then you have all of these nested calls into the encryption function where you‚Äôre passing pointers, and there are no argument labels that help you figure out which pointer needs to go into which argument.","type":"text"}]},{"code":["\/\/ Encrypting with a C crypto API","let status = ciphertext.withUnsafeMutableBytes { (cipherPtr: UnsafeMutableRawBufferPointer) in","\ttag.withUnsafeMutableBytes { (tagPtr: UnsafeMutableRawBufferPointer) in","\t\tnonceData.withUnsafeBytes { (noncePtr: UnsafeRawBufferPointer) in","\t\t\tkey.withUnsafeBytes { (keyPtr: UnsafeRawBufferPointer) in","\t\t\t\tplaintext.withUnsafeBytes { (plaintextPtr: UnsafeRawBufferPointer) in","\t\t\t\t\treturn encrypt(keyPtr, plaintextPtr, noncePtr, keyPtr, cipherPtr, tagPtr)","\t\t\t\t}","\t\t\t}","\t\t}","\t}","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In contrast, with Apple CryptoKit, you can do exactly the same operation with a single line of code."}]},{"code":["\/\/ Encrypting with Apple CryptoKit","let sealed = try AES.GCM.seal(dataToEncrypt, using: symmetricKey)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Something else you might have had to do is generating your own cryptographic key when you were calling into a C crypto API from Swift. And that involved first converting a number of bits and bytes because cryptographic keys are commonly expressed in bits."}]},{"code":["\/\/ Generating and releasing a cryptographic key for a C Crypto API","let keyByteCount = 256\/8"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Then you have to allocate a buffer for that amount of bytes and use the system, random number generator to fill that buffer with cryptographically secure random numbers.","type":"text"}]},{"code":["var key = Array(repeating: 0, count: keyByteCount)","let err = SecRandomCopyBytes(kSecRandomDefault, keyByteCount, &key)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, if an error occurred you had to handle that."}]},{"code":["if (err != errSecSuccess) {","\t\/\/ Safely handle the error","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You‚Äôre then finally ready to use that key, and when you‚Äôre done with that key, you don‚Äôt have to forget to zeroize it to remove it from memory."}]},{"code":["\/\/ Zeroize the key","memset_s(&key, keyByteCount, 0, keyByteCount)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In contrast the CryptoKit, generating a key is just a single line of code. You call the SymmetricKey initializer, and you pass the number of bits you want the key to hold."}]},{"code":["\/\/ Generating and releasing a cryptographic key with Apple CryptoKit","let key = SymmetricKey(size: .bits256)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We‚Äôre able to zeroize this key on release for you because knowing about the auto reference counting of this value whenever it is getting deallocated, we‚Äôre zeroizing that buffer for you."}]},{"type":"heading","text":"Secure Algorithms","level":2,"anchor":"Secure-Algorithms"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We have support for hash functions, message authentication codes, authenticated encryption, key agreement, and signatures."},{"type":"text","text":" "},{"type":"text","text":"Some of these algorithms are algorithms we have supported before in frameworks such as Common Crypto or SecKey, but some of these algorithms are algorithms we‚Äôre supporting for the first time. Those are highlighted in green on the slide."},{"type":"text","text":"\n"},{"type":"text","text":"Note that we also have an insecure module. This module provides algorithms such as MD5 and SHA1 so that you can adopt CryptoKit even if you need to be using some algorithms that no longer meet the best security standards."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC19-709-cryptoKit2","type":"image"}]},{"type":"heading","text":"Hash Functions","level":3,"anchor":"Hash-Functions"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Produces deterministic fixed-size digest","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Collision resistance"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Hash functions produced deterministic fixed-size output that is called a digest, and unlike hashable in Swift, hash functions in CryptoKit provide cryptographic properties such as collision resistance."},{"type":"text","text":" "},{"type":"text","text":"This means that it is hard to find two inputs that will hash to the same digest. In order to compute the hash, it is as easy as calling the hash method on the hash function you want to use, passing the data you want to hash."}]},{"type":"heading","text":"Verifying the Integrity of a File","level":3,"anchor":"Verifying-the-Integrity-of-a-File"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, I have some audio data I want to hash, and I use the SHA256 hash function to compute a digest."}]},{"code":["let audioData = FileManager.default.contents(atPath: filePath)!","let digest = SHA256.hash(data: audioData)"],"syntax":"swift","type":"codeListing"},{"type":"heading","text":"Hashing Data Incrementally","level":3,"anchor":"Hashing-Data-Incrementally"},{"type":"paragraph","inlineContent":[{"text":"If you‚Äôre streaming a file, you might be reading it from an input stream. In that case, you want to compute the digest incrementally.","type":"text"},{"text":" ","type":"text"},{"text":"You start by initializing a hasher by calling the MT initializer on the hash function. You then pass the data you want to hash, and you call the update method one or multiple times in order to do so. And when you want the digest to be computed, you just call the finalize method on the hash for instance, and that will return the digest.","type":"text"}]},{"code":["var hasher = SHA256()","let fileStream = InputStream(fileAtPath: filePath)!","fileStream.open()","let bufferSize = 64000","let buffer = UnsafeMutablePointer<UInt8>.allocate(capacity: bufferSize)","","while fileStream.hasBytesAvailable {","\tlet read = fileStream.read(buffer, maxLength: bufferSize)","\tlet bufferPointer = UnsafeRawBufferPointer(start: buffer, count: read) hasher.update(bufferPointer: bufferPointer)","}","","let digest = hasher.finalize()"],"syntax":"swift","type":"codeListing"},{"type":"heading","text":"Authenticated Encryption","level":3,"anchor":"Authenticated-Encryption"},{"type":"paragraph","inlineContent":[{"text":"As its name suggests, it provides both authentication and encryption.","type":"text"},{"text":" ","type":"text"},{"text":"The lack of authentication in cryptographic protocols can lead to a variety of attacks, and manually combining authentication with encryption can lead to things like padding oracle attacks.","type":"text"},{"text":" ","type":"text"},{"text":"So, instead we‚Äôre really happy to provide it to you as a single API call.","type":"text"}]},{"anchor":"Example-Hiking-app","text":"Example - Hiking app","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"I‚Äôm working on a side project. It‚Äôs a hiking app.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-cryptoKit3"}]},{"type":"paragraph","inlineContent":[{"text":"Most of the content on the app is free, but there‚Äôs additional content you can purchase through the in-app purchase. Once you purchase the content, you can retrieve the additional content. I‚Äôm using a content delivery network in order to keep the downloads fast, as my user base grows.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to obtain the content, I first check with my server if the in-app purchase is valid. Then, the key is retrieved from the server and passed on the phone. I download the encrypted data from the content delivery network, and I use the key in order to decrypt the encrypted content. And if the key is right, and the data wasn‚Äôt tampered with on the content delivery network, I‚Äôm able to retrieve the map data."}]},{"anchor":"Decrypting-Content","text":"Decrypting Content","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Let‚Äôs see how this translates to code.","type":"text"},{"text":" ","type":"text"},{"text":"First, we start by initializing a SymmetricKey from the key data that was retrieved from the server.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Initialize the decryption key","let key = SymmetricKey(data: keyData) "]},{"type":"paragraph","inlineContent":[{"text":"Then we are initializing a sealed box.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Initialize the sealed box","guard let sealedBox = ChaChaPoly.SealedBox(combined: downloadedData) else { throw MapDownloaderError.invalidDownload","}",""]},{"type":"paragraph","inlineContent":[{"text":"In this case, it doesn‚Äôt really matter what‚Äôs in the sealed box, but know that if you‚Äôre working on implementing a specification that requires you to combine the nonce, the cipher text and the tag in a specific way, you can use the sealed box to do that.","type":"text"},{"text":" ","type":"text"},{"text":"If you‚Äôre implementing a protocol that requires you to pass specific nonce values we‚Äôre also able to support that.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, we‚Äôre passing the downloaded data as a combined representation to the sealed box, and now that we have a box, we can simply open it by calling the open method on the cipher. And we‚Äôre passing the key."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Open the sealed box (authenticates + decrypts)","let mapData = try ChaChaPoly.open(sealedBox, using: key)"]},{"anchor":"Signatures","text":"Signatures","type":"heading","level":3},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Authenticates data using a private key","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Verifies data using the associated public key"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Signatures are used to authenticate data using a private key, and using the signature, we are able to verify data using the associated public key.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let‚Äôs take an example where we want to use the signature in order to authorize and operation. The operation here can be a two-factor log-in or some sensitive transaction such as wiring money to another user of the application. In order to do so, we start by generating a private key on the device."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We then retrieve the associated public key. The associated public key is registered with your service, and once we want to perform that operation, we‚Äôre using the private key to generate the signature on the transaction data and then sending over the transaction data and the signature to the server."}]},{"type":"paragraph","inlineContent":[{"text":"The server will verify that the signature is correct, and if the signature is right, it will proceed to doing the operation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Let‚Äôs see what this code looks like.","type":"text"},{"text":" ","type":"text"},{"text":"In order to generate a cryptographically strong private key, we call the PrivateKey initializer.","type":"text"},{"text":" ","type":"text"},{"text":"Then we want to register some public key data on the server.","type":"text"},{"text":" ","type":"text"},{"text":"We start by retrieving the public key by just calling public key on the private key, and then we want to say what representation we want to get from the public key.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Generate private key and register public key with server","let privateKey = P256.Signing.PrivateKey()","let publicKeyData = privateKey.publicKey.compactRepresentation!","\/\/ Store privateKey in Keychain"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Multiple representations of public keys exist, and we have support in CryptoKit for a lot of them."},{"type":"text","text":" "},{"type":"text","text":"In this case, we‚Äôre taking the compact representation."}]},{"type":"paragraph","inlineContent":[{"text":"As always, we‚Äôre storing the private key in the Keychain.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to produce the signature, we are calling the signature method on the private key, and we‚Äôre passing the transaction data we wish to sign, and this returns the signature."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Signing content","let signature = try privateKey.signature(for: transactionData)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, this key that protects these operations is of high value, so we want to give it the best security it can."}]},{"anchor":"Secure-Enclave","text":"Secure Enclave","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Secure Enclave is s hardware-based key manager that‚Äôs isolated from the main processor to provide an extra layer of security."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC19-709-cryptoKit4"}]},{"type":"paragraph","inlineContent":[{"text":"It is used as part of critical system features, such as Touch ID or Face ID. In short, this is the T2 we have in the latest MacBooks.","type":"text"},{"text":" ","type":"text"},{"text":"We can use the Secure Enclave for extra safety, this requires extra steps in when de\/encrypting things.","type":"text"}]},{"anchor":"Using-the-Secure-Enclave","text":"Using the Secure Enclave","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"We start by checking if a Secure Enclave is available on the device."}]},{"type":"paragraph","inlineContent":[{"text":"We do so by calling isAvailable on SecureEnclave.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Check that the device has a Secure Enclave","if !SecureEnclave.isAvailable {","\/\/ Handle devices without Secure Enclave","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And from there, we can use exactly the same code as before in order to produce, to generate the key and produce the signature within the Secure Enclave. Note that in order to do so, we simply prefix or call to the PrivateKey initializer call that generates the key, and we prefix it with Secure Enclave dot."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Generate private key and register public key with server","let privateKey = try SecureEnclave.P256.Signing.PrivateKey() ","let publicKeyData = privateKey.publicKey.compactRepresentation!","","\/\/ Store privateKey in Keychain","...","","\/\/ Producing a signature","let signature = try privateKey.signature(for: transactionData)",""]},{"anchor":"Constraining-Key-Usage","text":"Constraining Key Usage","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"An advantage of using the Secure Enclave is that you can constrain key usage. In this case, we want to say that the key that we‚Äôre generating on the Secure Enclave is only accessible when the device is unlocked and that this key will be available on this device only.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let accessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, [.privateKeyUsage, .userPresence], nil)!","let privateKey = try SecureEnclave.P256.Signing.PrivateKey(accessControl: accessControl)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can further constrain key usage by saying that when we‚Äôre performing an operation with the private key, we want to require user presence."},{"type":"text","text":" "},{"type":"text","text":"Requiring user presence means that the user will either be prompted for biometric authentication or they will be requested for their device password."},{"type":"text","text":" "},{"type":"text","text":"Now that we have composed an access control policy, we are simply passing it to the initializer of the key we‚Äôre generating, and that policy will be enforced."}]},{"anchor":"Customizing-Authentication-Context","text":"Customizing Authentication Context","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"You might want to give some additional context to your users about why they‚Äôre required to authenticate."},{"type":"text","text":" "},{"type":"text","text":"In order to do so, you can pass a LocalAuthentication context."}]},{"syntax":"swift","type":"codeListing","code":["let accessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, [.privateKeyUsage, .userPresence], nil)!","","let authContext = LAContext()","authContext.touchIDAuthenticationAllowableReuseDuration = 10","authContext.localizedReason = \"Authorizing $10 transfer to Bob.\"","","let privateKey = try SecureEnclave.P256.Signing.PrivateKey(accessControl: accessControl authenticationContext: authContext)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, we say that we want the LocalAuthentication context to be valid for ten seconds, so the user will not be required to reauthenticate during that amount of time, and we want to tell the user that they‚Äôre required to authenticate because they‚Äôre authorizing a $10 transfer to Bob."},{"type":"text","text":" "},{"type":"text","text":"In order to use that authentication context, you simply pass it to the key‚Äôs initializer."}]},{"anchor":"Performance","text":"Performance","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"identifier":"WWDC19-709-cryptoKit5","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"CryptoKit is built on top of corecrypto."},{"type":"text","text":" "},{"type":"text","text":"Corecrypto is Apple‚Äôs native cryptographic library that features all of the system frameworks."},{"type":"text","text":" "},{"type":"text","text":"With the help of the team that brought you the Accelerate framework and the CPU design team, corecrypto has hand-tuned assembly code, squeezing every cycle out of each of the support micro architectures."},{"type":"text","text":" "},{"type":"text","text":"In addition to that, because it uses corecrypto, it takes advantage of security mitigations in corecrypto such as side-channel resistance, and because corecrypto is FIPS validated, that means that you can use CryptoKit in the FIPS compliant way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Link to the CryptoKit documentation:"},{"type":"text","text":"\n"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/CryptoKit","type":"reference"}]},{"type":"paragraph","inlineContent":[{"text":"and it comes with Xcode Playground:","type":"text"},{"text":"\n","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/cryptokit\/performing_common_cryptographic_operations","isActive":true,"type":"reference"}]},{"anchor":"Related-Videos","text":"Related Videos","type":"heading","level":1},{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/701","type":"reference","isActive":true}]},{"anchor":"Written-By","text":"Written By","type":"heading","level":2},{"numberOfColumns":5,"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"type":"image","identifier":"zntfdr"}],"type":"paragraph"}]},{"size":4,"content":[{"text":"Federico Zanetello","type":"heading","level":3,"anchor":"Federico-Zanetello"},{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/zntfdr","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/zntfdr.dev","type":"reference"}],"type":"paragraph"}]}]},{"numberOfColumns":5,"type":"row","columns":[{"content":[{"inlineContent":[{"identifier":"multitudes","type":"image"}],"type":"paragraph"}],"size":1},{"content":[{"type":"heading","text":"laurent b","level":3,"anchor":"laurent-b"},{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/multitudes","isActive":true,"overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/multitudes","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/x.com\/wrmultitudes","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/laurentbrusa.hashnode.dev\/","isActive":true,"type":"reference"}]}],"size":4}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}]},{"anchor":"Related-Sessions","text":"Related Sessions","type":"heading","level":2},{"type":"links","style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-701-Advances-in-macOS-Security"]},{"type":"small","inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}]},{"type":"small","inlineContent":[{"text":"All content copyright ¬© 2012 ‚Äì 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}]}]}],"metadata":{"title":"Cryptography and Your Apps","role":"sampleCode","modules":[{"name":"WWDC Notes"}],"roleHeading":"WWDC19"},"sections":[],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC19":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19","role":"collectionGroup","title":"WWDC19","kind":"article","abstract":[{"type":"text","text":"Xcode 11, Swift 5.1, iOS 13, macOS 10.15 (Catalina), tvOS 13, watchOS 6."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"code":"Combine","type":"codeVoice"},{"type":"text","text":", "},{"code":"Core Haptics","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Create ML"},{"type":"text","text":", and more."}],"images":[{"type":"icon","identifier":"WWDC19-Icon.png"},{"type":"card","identifier":"WWDC19.jpeg"}],"type":"topic","url":"\/documentation\/wwdcnotes\/wwdc19"},"WWDC19-709-crypto3":{"variants":[{"url":"\/images\/WWDC19-709-crypto3.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-crypto3","alt":"Keychain","type":"image"},"WWDC19-709-crypto2":{"variants":[{"url":"\/images\/WWDC19-709-crypto2.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-crypto2","alt":"Protect Credentials and Keys","type":"image"},"https://developer.apple.com/documentation/cryptokit/performing_common_cryptographic_operations":{"titleInlineContent":[{"text":"Sample Code - Performing Common Cryptographic Operations","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/cryptokit\/performing_common_cryptographic_operations","url":"https:\/\/developer.apple.com\/documentation\/cryptokit\/performing_common_cryptographic_operations","type":"link","title":"Sample Code - Performing Common Cryptographic Operations"},"WWDC19-709-crypto":{"variants":[{"url":"\/images\/WWDC19-709-crypto.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-crypto","alt":"cryptography is hard","type":"image"},"https://www.apple.com/business/docs/site/iOS_Security_Guide.pdf":{"titleInlineContent":[{"text":"iOS Security White Paper","type":"text"}],"identifier":"https:\/\/www.apple.com\/business\/docs\/site\/iOS_Security_Guide.pdf","url":"https:\/\/www.apple.com\/business\/docs\/site\/iOS_Security_Guide.pdf","type":"link","title":"iOS Security White Paper"},"multitudes.jpeg":{"variants":[{"url":"\/images\/multitudes.jpeg","traits":["1x","light"]}],"identifier":"multitudes.jpeg","alt":null,"type":"image"},"zntfdr.jpeg":{"variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"identifier":"zntfdr.jpeg","alt":null,"type":"image"},"WWDC19-709-cryptoKit5":{"variants":[{"url":"\/images\/WWDC19-709-cryptoKit5.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-cryptoKit5","alt":"Secure Enclave","type":"image"},"WWDC19-709-cryptoKit4":{"variants":[{"url":"\/images\/WWDC19-709-cryptoKit4.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-cryptoKit4","alt":"Secure Enclave","type":"image"},"WWDC19-709-crypto4":{"variants":[{"url":"\/images\/WWDC19-709-crypto4.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-crypto4","alt":"On macOS","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes":{"title":"WWDC Notes","url":"\/documentation\/wwdcnotes","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"kind":"symbol","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","type":"topic"},"WWDC19-709-cryptoKit":{"variants":[{"url":"\/images\/WWDC19-709-cryptoKit.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-cryptoKit","alt":"Apple CryptoKit","type":"image"},"WWDC19-709-crypto6":{"variants":[{"url":"\/images\/WWDC19-709-crypto6.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-crypto6","alt":"Share Data Across Devices and Users","type":"image"},"https://developer.apple.com/videos/play/wwdc2019/701":{"titleInlineContent":[{"text":"Advances in macOS Security - WWDC 2019","type":"text"}],"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/701","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2019\/701","type":"link","title":"Advances in macOS Security - WWDC 2019"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"type":"topic","kind":"article","images":[{"identifier":"zntfdr.jpeg","type":"card"},{"identifier":"zntfdr.jpeg","type":"icon"}],"abstract":[{"text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more.","type":"text"}],"role":"sampleCode","title":"Federico Zanetello (332 notes)","url":"\/documentation\/wwdcnotes\/zntfdr","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr"},"WWDC19-709-foundation2":{"variants":[{"url":"\/images\/WWDC19-709-foundation2.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-foundation2","alt":"Foundation of Apple Security and Privacy Features","type":"image"},"WWDC19-709-cryptoKit3":{"variants":[{"url":"\/images\/WWDC19-709-cryptoKit3.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-cryptoKit3","alt":"Apple CryptoKit Example - Hiking app","type":"image"},"WWDC19-709-cryptoKit2":{"variants":[{"url":"\/images\/WWDC19-709-cryptoKit2.jpg","traits":["1x","light"]}],"identifier":"WWDC19-709-cryptoKit2","alt":"Apple CryptoKit","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-701-Advances-in-macOS-Security":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-701-Advances-in-macOS-Security","kind":"article","abstract":[{"text":"We are on a journey to continuously improve macOS security, with a particular focus on preventing malware and protecting user data. Join us on the next step and learn more about what‚Äôs new in Gatekeeper‚Äîfor keeping malware out of macOS‚Äîas well as new protections that help keep users‚Äô data and activity under their control.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc19-701-advances-in-macos-security","type":"topic","title":"Advances in macOS Security","role":"sampleCode"},"https://zntfdr.dev":{"titleInlineContent":[{"text":"Blog","type":"text"}],"identifier":"https:\/\/zntfdr.dev","url":"https:\/\/zntfdr.dev","type":"link","title":"Blog"},"doc://WWDCNotes/documentation/WWDCNotes/multitudes":{"role":"sampleCode","images":[{"identifier":"multitudes.jpeg","type":"card"},{"identifier":"multitudes.jpeg","type":"icon"}],"kind":"article","url":"\/documentation\/wwdcnotes\/multitudes","abstract":[{"type":"text","text":"student at 42Berlin üê¨ | üçé Swift(UI) app dev  | speciality coffee ‚òïÔ∏è & cycling üö¥üèª‚Äç‚ôÇÔ∏è"}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/multitudes","title":"laurent b (33 notes)"},"multitudes":{"variants":[{"traits":["1x","light"],"url":"\/images\/multitudes.jpeg"}],"identifier":"multitudes","alt":"Profile image of laurent b","type":"image"},"WWDC19-Icon.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-Icon.png"}],"identifier":"WWDC19-Icon.png","alt":null,"type":"image"},"https://developer.apple.com/documentation/CryptoKit":{"titleInlineContent":[{"text":"Apple CryptoKit","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/CryptoKit","url":"https:\/\/developer.apple.com\/documentation\/CryptoKit","type":"link","title":"Apple CryptoKit"},"WWDC19-709-crypto7":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-709-crypto7.jpg"}],"identifier":"WWDC19-709-crypto7","alt":"Share Data Across Devices and Users","type":"image"},"WWDC19.jpeg":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19.jpeg"}],"identifier":"WWDC19.jpeg","alt":null,"type":"image"},"https://x.com/wrmultitudes":{"titleInlineContent":[{"text":"X\/Twitter","type":"text"}],"identifier":"https:\/\/x.com\/wrmultitudes","url":"https:\/\/x.com\/wrmultitudes","type":"link","title":"X\/Twitter"},"https://github.com/multitudes":{"titleInlineContent":[{"text":"GitHub","type":"text"}],"identifier":"https:\/\/github.com\/multitudes","url":"https:\/\/github.com\/multitudes","type":"link","title":"GitHub"},"https://developer.apple.com/wwdc19/709":{"identifier":"https:\/\/developer.apple.com\/wwdc19\/709","url":"https:\/\/developer.apple.com\/wwdc19\/709","type":"download","checksum":null},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","title":"Contributions are welcome!"},"zntfdr":{"variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}],"identifier":"zntfdr","alt":"Profile image of Federico Zanetello","type":"image"},"https://laurentbrusa.hashnode.dev/":{"titleInlineContent":[{"text":"Blog","type":"text"}],"identifier":"https:\/\/laurentbrusa.hashnode.dev\/","url":"https:\/\/laurentbrusa.hashnode.dev\/","type":"link","title":"Blog"},"https://github.com/zntfdr":{"titleInlineContent":[{"text":"GitHub","type":"text"}],"identifier":"https:\/\/github.com\/zntfdr","url":"https:\/\/github.com\/zntfdr","type":"link","title":"GitHub"},"WWDC19-709-foundation":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-709-foundation.jpg"}],"identifier":"WWDC19-709-foundation","alt":"Foundation of Apple Security and Privacy Features","type":"image"},"WWDC19-709-crypto5":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-709-crypto5.jpg"}],"identifier":"WWDC19-709-crypto5","alt":"Share Data Across Devices and Users","type":"image"},"WWDCNotes.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"identifier":"WWDCNotes.png","alt":null,"type":"image"}}}