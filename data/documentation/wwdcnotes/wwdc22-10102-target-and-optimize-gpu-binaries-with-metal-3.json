{"metadata":{"roleHeading":"WWDC22","title":"Target and optimize GPU binaries with Metal 3","role":"sampleCode","modules":[{"name":"WWDC Notes"}]},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22"]]},"abstract":[{"text":"Discover how you can reduce in-app stutters, first launch times, and new level load times when you generate your GPU binaries entirely at project build time with offline compilation. We’ll also show you how to improve total compile time and binary size for larger GPU programs using the “Optimize for size” compiler option.","type":"text"}],"sampleCodeDownload":{"kind":"sampleDownload","action":{"identifier":"https:\/\/developer.apple.com\/wwdc22\/10102","overridingTitle":"Watch Video (13 min)","isActive":true,"type":"reference"}},"kind":"article","schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc22-10102-target-and-optimize-gpu-binaries-with-metal-3"]}],"sections":[],"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10102-Target-and-optimize-GPU-binaries-with-Metal-3","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"text":"Offline Compilation","anchor":"Offline-Compilation","level":1,"type":"heading"},{"inlineContent":[{"type":"text","text":"Offline compilation can help reduce app stutters, first launch, and new level load times. This is accomplished by moving GPU binary generation to project build time."}],"type":"paragraph"},{"text":"Previous Way to Generate GPU Binaries","anchor":"Previous-Way-to-Generate-GPU-Binaries","level":2,"type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Metal library is instantiated from source during runtime using AIR (Apple’s Intermediate Representation) this operation is CPU intensive.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Library generation can be moved to build time by precompiling the source file and instantiating it.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"When the Metal library is in memory, a Pipeline State Descriptor and Pipeline State Object (PSO) are created."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Creating a PSO is CPU intensive.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"After the PSO is created, just-in-time GPU binary generation takes place.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"When PSOs are created, Metal stores the GPU binaries in its file system cache."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Binary archives let users control when and where GPU binaries are cached."}]}]},{"content":[{"inlineContent":[{"text":"PSO creation can become a lightweight operation by using PSO descriptors to cache GPU binaries in an archive.","type":"text"},{"text":" ","type":"text"},{"identifier":"WWDC22-10102-runtime","type":"image"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"What’s New","anchor":"Whats-New","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"Offline binary generation allows for a Metal pipeline script to be specified at project build time. This new artifact is equivalent to a collection of Pipeline State Descriptors in the API. The output provides a binary archive that can be loaded to accelerate PSO creation."},{"type":"text","text":" "},{"type":"image","identifier":"WWDC22-10102-psodescriptor"}],"type":"paragraph"},{"text":"Creating Metal Pipeline Script","anchor":"Creating-Metal-Pipeline-Script","level":3,"type":"heading"},{"inlineContent":[{"text":"A Metal pipeline script is a JSON formatted description of one or more API Pipeline State Descriptors and can be created in a JSON editor or harvested from the binary archives.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Using a JSON Editor"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Specify API Metal library file path."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add API render descriptor function names as render pipeline properties."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Add pipeline state information (such as raster_sample_count or pixel formats)."}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"type":"text","text":"Metal code for generating a render pipeline script"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ An existing Obj-C render pipeline descriptor","NSError *error = nil;","id<MTLDevice> device = MTLCreateSystemDefaultDevice();","","id<MTLLibrary> library = [device newLibraryWithFile:@\"default.metallib\" error:&error];","","MTLRenderPipelineDescriptor *desc = [MTLRenderPipelineDescriptor new];","desc.vertexFunction = [library newFunctionWithName:@\"vert_main\"];","desc.fragmentFunction = [library newFunctionWithName:@\"frag_main\"];","desc.rasterSampleCount = 2;","desc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;","desc.depthAttachmentPixelFormat = MTLPixelFormatDepth32Float;"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"JSON equivalent"}],"type":"paragraph"},{"syntax":"{","code":["  \"\/\/comment\": \"Its equivalent new JSON script\",","  \"libraries\": {","    \"paths\": [","      {","        \"path\": \"default.metallib\"","      }","    ]","  },","  \"pipelines\": {","    \"render_pipelines\": [","      {","        \"vertex_function\": \"vert_main\",","        \"fragment_function\": \"frag_main\",","        \"raster_sample_count\": 2,","        \"color_attachments\": [","          {","            \"pixel_format\": \"BGRA8Unorm\"","          },","        ],","        \"depth_attachment_pixel_format\": \"Depth32Float\"","      }","    ]","  }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Further schema details can be found in Metal’s developer documentation"},{"type":"text","text":" "},{"type":"text","text":"https:\/\/developer.apple.com\/documentation\/metal"}],"type":"paragraph"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Using Metal Runtime"}]}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This is done during runtime"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Create Pipeline Descriptor with state and functions"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Add descriptor to binary archive"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Serialize binary archive to be imported by app"}]}]}],"type":"orderedList"},{"inlineContent":[{"type":"text","text":"Harvesting sample"}],"type":"paragraph"},{"syntax":"\/\/ Create pipeline descriptor","code":["MTLRenderPipelineDescriptor *pipeline_desc = [MTLRenderPipelineDescriptor new];","pipeline_desc.vertexFunction = [library newFunctionWithName:@\"vert_main\"];","pipeline_desc.fragmentFunction = [library newFunctionWithName:@\"frag_main\"];","pipeline_desc.rasterSampleCount = 2;","pipeline_desc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;","pipeline_desc.depthAttachmentPixelFormat = MTLPixelFormatDepth32Float;","","\/\/ Add pipeline descriptor to new archive","MTLBinaryArchiveDescriptor* archive_desc = [MTLBinaryArchiveDescriptor new];","id<MTLBinaryArchive> archive = [device newBinaryArchiveWithDescriptor:archive_desc error:&error];","bool success = [archive addRenderPipelineFunctionsWithDescriptor:pipeline_desc error:&error];","","\/\/ Serialize archive to file system","NSURL *url = [NSURL fileURLWithPath:@\"harvested-binaryArchive.metallib\"];","success = [archive serializeToURL:url error:&error];"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Extracting JSON pipelines script from binary archive can be done to move generation from runtime to build time."}],"type":"paragraph"},{"inlineContent":[{"text":"This can be done by using ","type":"text"},{"type":"codeVoice","code":"metal-source"},{"text":" while specifying buffers and output directory options","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"metal-source -flatbuffers=json harvested-binaryArchive.metallib -o \/tmp\/descriptors.mtlp-json","type":"codeVoice"}],"type":"paragraph"},{"text":"Generating Offline GPU Binaries","anchor":"Generating-Offline-GPU-Binaries","level":3,"type":"heading"},{"inlineContent":[{"text":"Generating GPU binary from source can be done by invoking ","type":"text"},{"code":"metal","type":"codeVoice"},{"text":" with source, pipeline script, and output","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"metal shaders.metal -N descriptors.mtlp-json -o archive.metallib","type":"codeVoice"}],"type":"paragraph"},{"inlineContent":[{"text":"Generating GPU Binary from Metal Library can be done by invoking ","type":"text"},{"code":"metal-tt","type":"codeVoice"},{"text":" with source, pipeline script, and output file","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"metal-tt shaders.metallib descriptors.mtlp-json -o archive.metallib","type":"codeVoice"}],"type":"paragraph"},{"text":"Loading Offline Binaries","anchor":"Loading-Offline-Binaries","level":3,"type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Provide binary archive URL when creating archive descriptor"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use URL to instantiate archive","type":"text"}]}]}],"type":"orderedList"},{"inlineContent":[{"type":"text","text":"For more information regarding API, see last year’s talk."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10229"}],"type":"paragraph"},{"text":"Optimize for Size","anchor":"Optimize-for-Size","level":1,"type":"heading"},{"inlineContent":[{"type":"text","text":"The Metal Compiler optimizes aggressively for runtime performance. These optimizations may expand the GPU program size which may have unexpected costs. Xcode 14 provides a new optimization mode for metal: optimize for size."},{"type":"text","text":" "},{"type":"text","text":"This setting prevents optimizations such as inlining and loop unrolling which should lower application size and compile time. This setting is useful for situations where the user encounters long compilation time. Optimize for size may hurt runtime performance, however it may improve runtime performance if the program was"},{"type":"text","text":" "},{"type":"text","text":"incurring runtime penalties associated with large size."}],"type":"paragraph"},{"text":"Enabling Optimize for Size","anchor":"Enabling-Optimize-for-Size","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"This feature can be enabled in 3 ways:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"In Xcode build settings under Metal Compiler - Build Options by selecting Size [-Os] under Optimization Level"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"In Terminal with option ","type":"text"},{"code":"-Os","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"In Metal Framework setting ","type":"text"},{"type":"codeVoice","code":"MTLLibraryOptimizationLevelSize"},{"text":" in an ","type":"text"},{"type":"codeVoice","code":"MTLCompileOptions"},{"text":" object","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"text":"Written By","anchor":"Written-By","level":2,"type":"heading"},{"inlineContent":[{"text":"@Row(numberOfColumns: 5) {","type":"text"},{"text":" ","type":"text"},{"text":"@Column {","type":"text"},{"text":" ","type":"text"},{"text":"@Image(source: “parjohns”, alt: “Profile image of P”)","type":"text"},{"text":" ","type":"text"},{"text":"}","type":"text"},{"text":" ","type":"text"},{"text":"@Column(size: 4) {","type":"text"},{"text":" ","type":"text"},{"text":"### ","type":"text"},{"isActive":true,"overridingTitle":"P","overridingTitleInlineContent":[{"text":"P","type":"text"}],"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/parjohns"}],"type":"paragraph"},{"syntax":"swift","code":["  [Contributed Notes](<doc:parjohns>)","  |","  [GitHub](https:\/\/github.com\/parjohns)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"https:\/\/","type":"reference","isActive":true},{"type":"text","text":" "},{"type":"text","text":"}"},{"type":"text","text":" "},{"type":"text","text":"}"}],"type":"paragraph"},{"type":"thematicBreak"},{"inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference","isActive":true}],"type":"paragraph"},{"text":"Related Sessions","anchor":"Related-Sessions","level":2,"type":"heading"},{"inlineContent":[{"text":"@Links(visualStyle: list) {","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10124-Bring-your-game-to-Mac-Part-2-Compile-your-shaders","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10127-Optimize-GPU-renderers-with-Metal"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10066-Discover-Metal-3"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10229-Discover-compilation-workflows-in-Metal","type":"reference","isActive":true}]}]},{"content":[{"inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10615-Build-GPU-binaries-with-Metal"},{"type":"text","text":" "},{"type":"text","text":"}"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"@Small {"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Legal Notice"}]}],"type":"paragraph"},{"inlineContent":[{"text":"All content copyright © 2012 – 2025 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"},{"text":" ","type":"text"},{"text":"}","type":"text"}],"type":"paragraph"}]}],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10229-Discover-compilation-workflows-in-Metal":{"title":"Discover compilation workflows in Metal","role":"sampleCode","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10229-Discover-compilation-workflows-in-Metal","abstract":[{"type":"text","text":"The Metal shading language is a powerful C++ based language that allows apps to render stunning effects while maintaining a flexible shader development pipeline. Discover how to more easily build and extend your render pipelines using Dynamic Libraries and Function Pointers. We’ll also show you how to accelerate your shader compilation at runtime with Binary Function Archives, Function Linking, and Function Stitching."}],"url":"\/documentation\/wwdcnotes\/wwdc21-10229-discover-compilation-workflows-in-metal","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10615-Build-GPU-binaries-with-Metal":{"abstract":[{"type":"text","text":"Power up your shader pipeline with enhancements to the Metal shader compilation model — all leading to a dramatic reduction in Pipeline State Object (PSO) loading time, especially upon first launch. Learn about explicit PSO caching and sharing of GPU binaries using Metal binary archives and dynamic libraries. And we’ll detail the toolchain to create libraries and improve your shader compilation workflow."}],"role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10615-Build-GPU-binaries-with-Metal","title":"Build GPU binaries with Metal","url":"\/documentation\/wwdcnotes\/wwdc20-10615-build-gpu-binaries-with-metal","kind":"article","type":"topic"},"https://developer.apple.com/wwdc22/10102":{"identifier":"https:\/\/developer.apple.com\/wwdc22\/10102","url":"https:\/\/developer.apple.com\/wwdc22\/10102","checksum":null,"type":"download"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22":{"type":"topic","role":"collectionGroup","title":"WWDC22","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc22","images":[{"type":"icon","identifier":"WWDC22-Icon.png"},{"type":"card","identifier":"WWDC22.jpeg"}],"abstract":[{"type":"text","text":"Xcode 14, Swift 5.7, iOS 16, macOS 13 (Ventura), tvOS 16, watchOS 9."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"WeatherKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"ScreenCaptureKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"Swift Regex"},{"type":"text","text":", and more."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22"},"doc://WWDCNotes/documentation/WWDCNotes/parjohns":{"type":"topic","abstract":[{"type":"text","text":"No Bio on GitHub"}],"role":"sampleCode","images":[{"identifier":"parjohns.jpeg","type":"card"},{"identifier":"parjohns.jpeg","type":"icon"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/parjohns","title":"P (5 notes)","url":"\/documentation\/wwdcnotes\/parjohns","kind":"article"},"https://":{"type":"link","title":"Blog","url":"https:\/\/","identifier":"https:\/\/","titleInlineContent":[{"text":"Blog","type":"text"}]},"WWDC22.jpeg":{"identifier":"WWDC22.jpeg","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC22.jpeg","traits":["1x","light"]}],"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10124-Bring-your-game-to-Mac-Part-2-Compile-your-shaders":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10124-Bring-your-game-to-Mac-Part-2-Compile-your-shaders","type":"topic","abstract":[{"type":"text","text":"Discover how the Metal shader converter streamlines the process of bringing your HLSL shaders to Metal as we continue our three-part series on bringing your game to Mac. Find out how to build a fast, end-to-end shader pipeline from DXIL that supports all shader stages and allows you to leverage the advanced features of Apple GPUs. We’ll also show you how to reduce app launch time and stutters by generating GPU binaries with the offline compiler."}],"kind":"article","title":"Bring your game to Mac, Part 2: Compile your shaders","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc23-10124-bring-your-game-to-mac-part-2-compile-your-shaders"},"WWDC22-Icon.png":{"alt":null,"type":"image","identifier":"WWDC22-Icon.png","variants":[{"url":"\/images\/WWDCNotes\/WWDC22-Icon.png","traits":["1x","light"]}]},"parjohns.jpeg":{"type":"image","alt":null,"identifier":"parjohns.jpeg","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/parjohns.jpeg"}]},"WWDCNotes.png":{"identifier":"WWDCNotes.png","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDCNotes.png","traits":["1x","light"]}],"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","role":"collection","title":"WWDC Notes","type":"topic","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"url":"\/documentation\/wwdcnotes"},"WWDC22-10102-psodescriptor":{"alt":"psodescriptor","type":"image","identifier":"WWDC22-10102-psodescriptor","variants":[{"url":"\/images\/WWDCNotes\/WWDC22-10102-psodescriptor.JPG","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-10066-Discover-Metal-3":{"abstract":[{"type":"text","text":"Harness the full potential of Apple silicon in your app with Metal 3. We’ll introduce you to the latest features, improvements, and tooling. We’ll also explore how you can use advanced features and compiler tools to load resources faster, compile shader binaries at build time, process complex geometry with mesh shaders, render high-resolution graphics in less time, train machine learning networks faster, and more."}],"role":"sampleCode","kind":"article","type":"topic","title":"Discover Metal 3","url":"\/documentation\/wwdcnotes\/wwdc22-10066-discover-metal-3","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10066-Discover-Metal-3"},"WWDC22-10102-runtime":{"type":"image","alt":"Runtime","identifier":"WWDC22-10102-runtime","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC22-10102-runtime.JPG"}]},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10127-Optimize-GPU-renderers-with-Metal":{"kind":"article","role":"sampleCode","abstract":[{"type":"text","text":"Discover how to optimize your GPU renderer using the latest Metal features and best practices. We’ll show you how to use function specialization and parallel shader compilation to maintain responsive authoring workflows and the fastest rendering speeds, and help you tune your compute shaders for optimal performance."}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10127-Optimize-GPU-renderers-with-Metal","url":"\/documentation\/wwdcnotes\/wwdc23-10127-optimize-gpu-renderers-with-metal","title":"Optimize GPU renderers with Metal"}}}