{"variants":[{"paths":["\/documentation\/wwdcnotes\/wwdc22-110363-improve-app-size-and-runtime-performance"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"role":"sampleCode","modules":[{"name":"WWDC Notes"}],"title":"Improve app size and runtime performance","roleHeading":"WWDC22"},"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22"]]},"abstract":[{"text":"Learn how we’ve optimized the Swift and Objective-C runtimes to help you make your app smaller, quicker, and launch faster. Discover how you can get access to efficient protocol checks, smaller message send calls, and optimized ARC simply when you build your app with Xcode 14 and update your deployment target.","type":"text"}],"kind":"article","identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110363-Improve-app-size-and-runtime-performance","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"anchor":"Protocol-checks","type":"heading","text":"Protocol checks","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Example:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ 👇🏻 Protocol definition","protocol CustomLoggable {","  var customLogString: String { get }","}","","func log(value: Any) {","  if let value = value as? CustomLoggable { \/\/ 👈🏻 protocol check","    ...","  }","}"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Whenever possible, this check is optimized away at build time, in the compiler"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"However, we don’t always have enough information yet, so this check often needs to happen in the runtime, with the help of protocol check metadata"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"With this metadata, the runtime knows whether this particular object really does conform to the protocol"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Part of the metadata is built at compile time, but a lot can only be built at launch time, particularly when using Swift generics","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"on apps that rely heavily in Swift, this could add up to half the launch time"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"New this year:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"protocol checks are pre-computed as part of the dyld closure for the app executable and any dylib it uses at launch (a.k.a. this is done at app installation time)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"enabled even for existing apps when running on iOS 16, tvOS 16, or watchOS 9.","type":"text"}]}]}]},{"anchor":"ObjC-Message-send","type":"heading","text":"(ObjC) Message send","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"with new compilers and linker in Xcode 14,message send calls are up to "},{"type":"text","text":"8 bytes"},{"type":"text","text":" smaller, down from "},{"type":"text","text":"12 bytes"},{"type":"text","text":", on ARM64"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"binaries up to 2% smaller overall","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"enabled by Xcode 14, even when targeting an older OS release as deployment target","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Defaults to balanced performance and size optimization"}]}]},{"content":[{"inlineContent":[{"text":"Opt into optimizing for size only using ","type":"text"},{"code":"-Wl,-objc_stubs_small","type":"codeVoice"},{"text":" linker flag","type":"text"}],"type":"paragraph"}]}]},{"anchor":"How-its-done-Selector-stubs","type":"heading","text":"How it’s done: Selector stubs","level":3},{"type":"paragraph","inlineContent":[{"text":"Prior:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"whenever we interact with objc models, we almost always end up needing an instruction to call "},{"type":"codeVoice","code":"objc_msgSend"},{"type":"text","text":", even when doing property accesses"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"this is because at compile time, we don’t know which method to call, therefore we ask objc runtime using ","type":"text"},{"type":"codeVoice","code":"objc_msgSend"},{"text":" to find the right method","type":"text"}]}]}]},{"type":"codeListing","syntax":"objc","code":["NSCalendar *cal = [self makeCalendar];                              \/\/ 👈🏻 compiler emits bl _objc_msgSend","NSDateComponents* dateComponents = [[NSDateComponents alloc] init]; \/\/ 2x 👈🏻 compiler emits bl _objc_msgSend","dateComponents.year = 2022;                                         \/\/ 👈🏻 compiler emits bl _objc_msgSend","dateComponents.month = 6;                                           \/\/ 👈🏻 compiler emits bl _objc_msgSend","dateComponents.day = 6;                                             \/\/ 👈🏻 compiler emits bl _objc_msgSend","NSDate *theDate = [cal dateFromComponents:dateComponents];          \/\/ 👈🏻 compiler emits bl _objc_msgSend","return theDate;"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"to tell the runtime which method to call, we have to pass a selector to these ","type":"text"},{"code":"objc_msgSend","type":"codeVoice"},{"text":" calls. This needs two more instructions to prepare the selector, each of these instructions takes 4 bytes on ARM64.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Example:","type":"text"}]},{"type":"codeListing","syntax":"objc","code":["\/\/ ObjC","NSDate *theDate = [cal dateFromComponents:dateComponents];","","\/\/ 👇🏻 compiler emits","adrp x1 [selector \"dateFromComponents\"]     \/\/ 👈🏻 4 bytes on ARM 64","ldr  x1 [x1, selector \"dateFromComponents\"] \/\/ 👈🏻 4 bytes on ARM 64","bl _objc_msgSend"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"in conclusion, for each ","type":"text"},{"code":"objc_msgSend","type":"codeVoice"},{"text":" call, we’re using 12 bytes (4B for ","type":"text"},{"code":"_objc_msgSend","type":"codeVoice"},{"text":", 8B for the selector)","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What’s new:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"for any given selector, it’s always the same code, example from above:","type":"text"}]}]}]},{"type":"codeListing","syntax":"objc","code":["adrp x1 [selector \"dateFromComponents\"]     \/\/ 👈🏻 always the same instruction for dateFromComponents","ldr  x1 [x1, selector \"dateFromComponents\"] \/\/ 👈🏻 always the same instruction for dateFromComponents","bl _objc_msgSend"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"we can share this same code and only emit it once "},{"type":"strong","inlineContent":[{"type":"text","text":"per selector"}]},{"type":"text","text":" instead of at every message send"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"we do this via a helper function, and call that function instead","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"this function is called Selector Stub"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Therefore we go from this:","type":"text"}]},{"type":"codeListing","syntax":"objc","code":["\/\/ ObjC","NSDate *theDate = [cal dateFromComponents:dateComponents];","","\/\/ 👇🏻 compiler emits","adrp x1 [selector \"dateFromComponents\"] ","ldr  x1 [x1, selector \"dateFromComponents\"]","bl _objc_msgSend"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"to this:"}]},{"type":"codeListing","syntax":"objc","code":["\/\/ ObjC","NSDate *theDate = [cal dateFromComponents:dateComponents];","","\/\/ 👇🏻 compiler emits","bl _objc_msgSend$dateFromComponents","","\/\/ Where the _objc_msgSend$dateFromComponents Selector stub is defined ONCE per program","\/\/ Selector stub:","_objc_msgSend$dateFromComponents:","adrp x1, [selector \"dateFromComponents\"]","ldr  x1, [x1, selector \"dateFromComponents\"]","b    _objc_msgSend"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However "},{"type":"codeVoice","code":"_objc_msgSend"},{"type":"text","text":" still needs to jump to the actual message send code (the Call stub), therefore we’re doing two jumps in our machine code (one to go to the Selector stub, one to the Call stub)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Based on the optimization that we would like, we can merge the Selector and Call stub (making only one jump), or we can keep them separate. This is the difference between the default behavior (balanced performance and size optimization) and the optimized for size one ("},{"code":"-Wl,-objc_stubs_small","type":"codeVoice"},{"type":"text","text":" linker flag):"}]},{"type":"codeListing","syntax":"objc","code":["\/\/ Separate selector and symbol stubs","\/\/ Optimize for Size","\/\/ Enable using -Wl,-objc_stubs_small","","bl _objc_msgSend$dateFromComponents \/\/ 👈🏻 jump 1","","\/\/ Selector stub","_objc_msgSend$dateFromComponents:","adrp x1, [selector \"dateFromComponents\"]","ldr  x1, [x1, selector \"dateFromComponents\"]","b    _objc_msgSend                  \/\/ 👈🏻 jump 2","","\/\/ Call stub","_objc_msgSend:","adrp ...","ldr  ...","br   ..."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"vs."}]},{"type":"codeListing","syntax":"objc","code":["\/\/ Combined selector and symbol stubs","\/\/ Balanced Size\/Performance","\/\/ Enabled by default","","bl _objc_msgSend$dateFromComponents \/\/ 👈🏻 jump 1","","\/\/ Where the _objc_msgSend$dateFromComponents Selector stub is defined ONCE per program","\/\/ Selector stub:","_objc_msgSend$dateFromComponents:","adrp x1, [selector \"dateFromComponents\"]","ldr  x1, [x1, selector \"dateFromComponents\"]","adrp ...","ldr  ...","br   ..."]},{"anchor":"Retain-and-release","type":"heading","text":"Retain and release","level":2},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"retain\/release calls are now up to 4 bytes smaller, down from 8 on ARM64","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"binaries up to 2% smaller overall","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"enabled by new compilers in Xcode 14"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"requires new runtime support, hence your deployment target must be iOS 16, tvOS 16, or watchOS 9"}],"type":"paragraph"}]}]},{"anchor":"How-its-done","type":"heading","text":"How it’s done","level":3},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"thanks to ARC (automatic reference counting), our code compiles into a lot of retain\/release calls"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"whenever we make a copy of a pointer to an object, we need to increment its retain count to keep it live"}]}]},{"content":[{"inlineContent":[{"text":"we do that by calling into the runtime, using ","type":"text"},{"code":"objc_retain","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"when our variables go out of scope, we then need to decrement the retain count using "},{"code":"objc_release","type":"codeVoice"}]}]}]},{"type":"codeListing","syntax":"objc","code":["NSCalendar *cal = [self makeCalendar];                              \/\/ 👈🏻 bl _objc_retain","NSDateComponents* dateComponents = [[NSDateComponents alloc] init]; \/\/ 👈🏻 bl _objc_retain","dateComponents.year = 2022;                                         ","dateComponents.month = 6;                                           ","dateComponents.day = 6;                                             ","NSDate *theDate = [cal dateFromComponents:dateComponents];          \/\/ 👈🏻 bl _objc_retain","return theDate;","                                                                    \/\/ 👈🏻 bl _objc_release","                                                                    \/\/ 👈🏻 bl _objc_release","                                                                    \/\/ 👈🏻 bl _objc_release"]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"in actuality, the compiler will do some optimizations that will avoid some of these calls"}]}],"name":"Note","style":"note"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"objc_retain","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"objc_release","type":"codeVoice"},{"text":" functions are just plain C functions","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"they take a single argument, the object to be released","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"with ARC, the compiler inserts calls to these C functions, passing the appropriate object pointers","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of that, these calls have to respect the C calling convention, defined by our platform ABI (Application Binary Interface)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"this results in extra "},{"type":"codeVoice","code":"move"},{"type":"text","text":" instructions just for passing the pointer in the right register"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Optimization:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"By specializing retain\/release with a custom calling convention, the system can opportunistically use the right variant depending on where the object pointer already is, meaning we don’t need the extra ","type":"text"},{"code":"move","type":"codeVoice"},{"text":" instructions","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"skipping these "},{"type":"codeVoice","code":"move"},{"type":"text","text":" instructions saves the 4 bytes"}]}]}]},{"anchor":"Quicker-Autorelease-elision","type":"heading","text":"Quicker Autorelease elision","level":2},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"enabled by ObjC runtime changes (automatically happens when running iOS 16, tvOS 16, watchOS 9, or macOS 13)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"with additional compiler changes, the app binary is also smaller (requires deployment target must be iOS 16, tvOS 16)","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"What is Autorelease elision?"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"When we call a method that returns a value, we call ","type":"text"},{"code":"retain","type":"codeVoice"},{"text":" on the returned object","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"on the method’s body, we don’t call ","type":"text"},{"code":"release","type":"codeVoice"},{"text":" on the returned object, as that would release the object from memory","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"instead we call ","type":"text"},{"code":"autorelease","type":"codeVoice"},{"text":", so the method caller can retain it","type":"text"}]}]}]},{"type":"codeListing","syntax":"objc","code":["                                                \/\/ 👇🏻 retain call","myValue = [[someInstance aMethodReturningAValue] retain];","","-(MyType *)aMethodReturningAValue {","  ...","","  return [newValue autorelease]; \/\/ 👈🏻 we don't release, we autorelease, so the caller (above)","                                 \/\/    can retain it before the instance gets released.","}"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"autorelease"},{"type":"text","text":" tells the runtime that we’re returning an object that will immediately be retained"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"thanks to some improvements in both compiler and Objc runtime, "},{"type":"codeVoice","code":"autorelease"},{"type":"text","text":" overhead is now cheaper, and with clever use of pointers is faster as well"}]}]}]},{"anchor":"Written-By","type":"heading","text":"Written By","level":2},{"type":"row","numberOfColumns":5,"columns":[{"size":1,"content":[{"inlineContent":[{"type":"image","identifier":"zntfdr"}],"type":"paragraph"}]},{"size":4,"content":[{"type":"heading","anchor":"Federico-Zanetello","text":"Federico Zanetello","level":3},{"type":"paragraph","inlineContent":[{"overridingTitle":"Contributed Notes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","type":"reference","isActive":true,"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}]},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/zntfdr","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/zntfdr.dev","type":"reference","isActive":true}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference","isActive":true}]},{"anchor":"Related-Sessions","type":"heading","text":"Related Sessions","level":2},{"type":"links","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110354-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110362-Link-fast-Improve-build-and-launch-times"],"style":"list"},{"type":"small","inlineContent":[{"type":"strong","inlineContent":[{"text":"Legal Notice","type":"text"}]}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"sampleCodeDownload":{"action":{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/wwdc22\/110363","overridingTitle":"Watch Video (14 min)"},"kind":"sampleDownload"},"sections":[],"references":{"zntfdr.jpeg":{"identifier":"zntfdr.jpeg","variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110362-Link-fast-Improve-build-and-launch-times":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110362-Link-fast-Improve-build-and-launch-times","title":"Link fast: Improve build and launch times","url":"\/documentation\/wwdcnotes\/wwdc22-110362-link-fast-improve-build-and-launch-times","role":"sampleCode","abstract":[{"type":"text","text":"Discover how to improve your app’s build and runtime linking performance. We’ll take you behind the scenes to learn more about linking, your options, and the latest updates that improve the link performance of your app."}],"kind":"article","type":"topic"},"WWDC22.jpeg":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC22.jpeg"}],"identifier":"WWDC22.jpeg","alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes":{"title":"WWDC Notes","url":"\/documentation\/wwdcnotes","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"kind":"symbol","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"type":"topic","kind":"article","images":[{"identifier":"zntfdr.jpeg","type":"card"},{"identifier":"zntfdr.jpeg","type":"icon"}],"abstract":[{"text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more.","type":"text"}],"role":"sampleCode","title":"Federico Zanetello (332 notes)","url":"\/documentation\/wwdcnotes\/zntfdr","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110354-Whats-new-in-Swift":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110354-Whats-new-in-Swift","title":"What’s new in Swift","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc22-110354-whats-new-in-swift","type":"topic","abstract":[{"type":"text","text":"Join us for an update on Swift. We’ll take you through performance improvements, explore more secure and extensible Swift packages, and share advancements in Swift concurrency. We’ll also introduce you to Swift Regex, better generics, and other tools built into the language to help you write more flexible & expressive code."}],"role":"sampleCode"},"https://zntfdr.dev":{"titleInlineContent":[{"text":"Blog","type":"text"}],"identifier":"https:\/\/zntfdr.dev","title":"Blog","url":"https:\/\/zntfdr.dev","type":"link"},"WWDC22-Icon.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC22-Icon.png"}],"identifier":"WWDC22-Icon.png","alt":null,"type":"image"},"https://github.com/zntfdr":{"titleInlineContent":[{"text":"GitHub","type":"text"}],"identifier":"https:\/\/github.com\/zntfdr","title":"GitHub","url":"https:\/\/github.com\/zntfdr","type":"link"},"https://developer.apple.com/wwdc22/110363":{"identifier":"https:\/\/developer.apple.com\/wwdc22\/110363","checksum":null,"url":"https:\/\/developer.apple.com\/wwdc22\/110363","type":"download"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"title":"Contributions are welcome!","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"type":"link","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"alt":null},"zntfdr":{"identifier":"zntfdr","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}],"alt":"Profile image of Federico Zanetello"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22":{"title":"WWDC22","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22","abstract":[{"type":"text","text":"Xcode 14, Swift 5.7, iOS 16, macOS 13 (Ventura), tvOS 16, watchOS 9."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"WeatherKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"ScreenCaptureKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"Swift Regex"},{"type":"text","text":", and more."}],"kind":"article","url":"\/documentation\/wwdcnotes\/wwdc22","role":"collectionGroup","type":"topic","images":[{"type":"icon","identifier":"WWDC22-Icon.png"},{"type":"card","identifier":"WWDC22.jpeg"}]}}}