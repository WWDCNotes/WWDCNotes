{"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency"},"primaryContentSections":[{"kind":"content","content":[{"text":"Task hierarchy","level":2,"type":"heading","anchor":"Task-hierarchy"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"unlocks automatic task cancellation, priority propagation, and useful task-local value behaviors."}]}]}],"type":"unorderedList"},{"text":"Concurrency in Swift","level":3,"type":"heading","anchor":"Concurrency-in-Swift"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Helps us to reason about concurrent code using well-defined points where execution branches off and runs concurrently."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Automatically implements advanced behaviours.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Concurrent execution is triggered when you use an "},{"code":"async let","type":"codeVoice"},{"type":"text","text":", a task group, create a task or detached task."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Results rejoin the current execution at a suspension point, indicated by an "},{"type":"codeVoice","code":"await"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Structured tasks are created using ","type":"text"},{"code":"async let","type":"codeVoice"},{"text":" and task groups.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Unstructured tasks are created using ","type":"text"},{"code":"Task","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Task.detached","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"text":"Structured tasks live to the end of the scope where they are declared and are automatically cancelled when they go out.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"strong","inlineContent":[{"text":"Example of making soup in a kitchen with Unstructured and structured concurrency","type":"text"}]}]}],"type":"paragraph"},{"text":"Unstructured concurrency","level":3,"type":"heading","anchor":"Unstructured-concurrency"},{"inlineContent":[{"text":"Here we are creating unstructured Tasks to add concurrency to the functions, and awaiting their values when necessary.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func makeSoup(order: Order) async throws -> Soup {","    let boilingPot = Task { try await stove.boilBroth() }","    let choppedIngredients = Task { try await chopIngredients(order.ingredients) }","    let meat = Task { await marinate(meat: .chicken) }","    let soup = await Soup(meat: meat.value, ingredients: choppedIngredients.value)","    return await stove.cook(pot: boilingPot.value, soup: soup, duration: .minutes(10))","}"]},{"text":"Structured concurrency","level":3,"type":"heading","anchor":"Structured-concurrency"},{"items":[{"content":[{"inlineContent":[{"text":"Since we have a known number of child tasks to create, we can use the convenient ","type":"text"},{"code":"async let","type":"codeVoice"},{"text":" syntax.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"These tasks form a structured relationship with their parent task.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["func makeSoup(order: Order) async throws -> Soup {","    async let pot = stove.boilBroth()","    async let choppedIngredients = chopIngredients(order.ingredients)","    async let meat = marinate(meat: .chicken)","    let soup = try await Soup(meat: meat, ingredients: choppedIngredients)","    return try await stove.cook(pot: pot, soup: soup, duration: .minutes(10))","}",""]},{"text":"Task cancellation","level":2,"type":"heading","anchor":"Task-cancellation"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"used to signal that the app no longer needs the result of a task and the task should stop and either return a partial result or throw an error."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Structured tasks are cancelled implicitly when they go out of scope.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"call ","type":"text"},{"type":"codeVoice","code":"cancelAll"},{"text":" on task groups to cancel all active children and any future child tasks.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Unstructured tasks are cancelled explicitly with the ","type":"text"},{"code":"cancel","type":"codeVoice"},{"text":" function.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Cancelling the parent task results in the cancellation of all child tasks."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Cancellation is cooperative, so child tasks aren’t immediately stopped."}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["func makeSoup(order: Order) async throws -> Soup {","    async let pot = stove.boilBroth()","","    guard !Task.isCancelled else {","        throw SoupCancellationError()","    }","","    async let choppedIngredients = chopIngredients(order.ingredients)","    async let meat = marinate(meat: .chicken)","    let soup = try await Soup(meat: meat, ingredients: choppedIngredients)","    return try await stove.cook(pot: pot, soup: soup, duration: .minutes(10))","}"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If throwing a cancellation error instead of returning a partial result, we can call "},{"type":"codeVoice","code":"Task.checkCancellation"},{"type":"text","text":", which throws a "},{"type":"codeVoice","code":"CancellationError"},{"type":"text","text":" if the task was cancelled."}]}]},{"content":[{"inlineContent":[{"text":"Cancellation checking is synchronous, so any function, asynchronous or synchronous, that should react to cancellation should check the task cancellation status before continuing.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Polling","type":"text"}]},{"type":"text","text":" for cancellation with "},{"type":"codeVoice","code":"isCancelled"},{"type":"text","text":" or "},{"type":"codeVoice","code":"checkCancellation"},{"type":"text","text":" is useful when the task is running."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"withTaskCancellationHandler"},{"text":" is useful at times when you may need to respond to cancellation while the task is suspended and no code is running.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Cancellation and async sequences","level":3,"type":"heading","anchor":"Cancellation-and-async-sequences"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the asynchronous for-loop gets a new order before it is cancelled."}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["actor Cook {","    func handleShift<Orders>(orders: Orders) async throws","       where Orders: AsyncSequence,","             Orders.Element == Order {","","        for try await order in orders {","            let soup = try await makeSoup(order)","            \/\/ ...","        }","    }","}"]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"the cancellation may take place while the task is suspended, waiting on the next order."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"use the cancellation handler to detect the cancellation event and break out of the asynchronous for-loop.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"These orders are produced from an ","type":"text"},{"type":"codeVoice","code":"AsyncSequence"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"AsyncSequences are driven by an "},{"code":"AsyncIterator","type":"codeVoice"},{"type":"text","text":", which defines an asynchronous "},{"code":"next","type":"codeVoice"},{"type":"text","text":" function."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Like with synchronous iterators, the ","type":"text"},{"code":"next","type":"codeVoice"},{"text":" function returns the next element in the sequence, or nil to indicate that we are at the end of the sequence.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Many AsyncSequences are implemented with a state machine, which we use to stop the running sequence.","type":"text"}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["public func next() async -> Order? {","    return await withTaskCancellationHandler {","        let result = await kitchen.generateOrder()","        guard state.isRunning else {","            return nil","        }","        return result","    } onCancel: {","        state.cancel()","    }","}"]},{"text":"AsyncSequence state machine","level":3,"type":"heading","anchor":"AsyncSequence-state-machine"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"While actors are great for protecting encapsulated state they can’t really protect the protect the state machine."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"to modify and read individual properties on the state machine actors aren’t quite the right tool."}]}]},{"content":[{"inlineContent":[{"text":"can’t guarantee the order that operations run on an actor, so we can’t ensure that our cancellation will run first.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"use ","type":"text"},{"type":"codeVoice","code":"atomics"},{"text":" from the Swift Atomics package, a dispatch queue or locks instead.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"These mechanisms allow us to:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"synchronize the shared state","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"avoiding race conditions, while allowing us to cancel the running state machine without introducing an unstructured task in the cancellation handler.","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["private final class OrderState: Sendable {","    let protectedIsRunning = ManagedAtomic<Bool>(true)","    var isRunning: Bool {","        get { protectedIsRunning.load(ordering: .acquiring) }","        set { protectedIsRunning.store(newValue, ordering: .relaxed) }","    }","    func cancel() { isRunning = false }","}"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Therefore ","type":"text"},{"type":"strong","inlineContent":[{"text":"Task cancellation","type":"text"}]},{"text":":","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Propagate through the task tree.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Seamlessly integrates with throwing errors."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Event-driven cancellation handlers or explicit polling.","type":"text"}]}]}]}]}],"type":"unorderedList"},{"text":"Task priority","level":2,"type":"heading","anchor":"Task-priority"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Priority is your way to communicate to the system how urgent a given task is."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Certain tasks, like responding to a button press, need to run immediately or the app will appear frozen."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Meanwhile, other tasks, like prefetching content from a server, can run in the background without anyone noticing."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"priority inversion","type":"text"}]},{"type":"text","text":" happens when a high-priority task is waiting on the result of a lower-priority task."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"By default, child tasks inherit their priority from their parent.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the parent is running in a task at medium priority, all child tasks will also run at medium priority."}]}]}],"type":"unorderedList"},{"text":"Structured priority escalation","level":3,"type":"heading","anchor":"Structured-priority-escalation"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Lower priority tasks escalate priority when awaited on by a higher priority task."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Escalation propagates through the task tree.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Priority remains escalated until the task completes."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It’s not possible to undo a priority escalation.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Task group patterns","level":2,"type":"heading","anchor":"Task-group-patterns"},{"inlineContent":[{"type":"text","text":"A powerful tool used for limiting and managing concurrency."}],"type":"paragraph"},{"inlineContent":[{"text":"Example to see the pattern more clearly:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["    withTaskGroup(of: Something.self) { group in","    for _ in 0..<maxConcurrentTasks {","        group.addTask { }","    }","    while let <partial result> = await group.next() {","        if !shouldStop { ","            group.addTask { }","        }","    }","}"]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"The initial loop creates up to the maximum number of concurrent tasks, ensuring that we don’t create too many."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Once the maximum number of tasks is running, we wait for one to finish.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"After it finishes and we haven’t hit a stopping condition, we create a new task to keep making progress.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"This limits the number of concurrent tasks in the group since we won’t start new work until earlier tasks finish.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Discarding task groups","level":3,"type":"heading","anchor":"Discarding-task-groups"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"withDiscardingTaskGroup","type":"codeVoice"},{"text":" API is New Swift 5.9","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Discarding task groups don’t hold onto the results of completed child tasks.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Resources used by tasks are freed immediately after the task finishes.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["\twithDiscardingTaskGroup { group in","\t\tgroup.addTask()","\t}","\t","\twithThrowingDiscardingTaskGroup { group in ","\t\tgroup.addTask()","\t}"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We can change the run method to make use of a discarding task group."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Discarding task groups automatically clean up their children, so there is no need to explicitly cancel the group and clean up."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The discarding task group also has automatic sibling cancellation."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If any of the child tasks throw an error, all remaining tasks are automatically cancelled."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["func run() async throws {","    try await withThrowingDiscardingTaskGroup { group in","        for cook in staff.keys {","            group.addTask { try await cook.handleShift() }","        }","","        group.addTask { \/\/ keep the restaurant going until closing time","            try await Task.sleep(for: shiftDuration)","            throw TimeToCloseError()","        }","    }","}"]},{"text":"TaskGroups","level":3,"type":"heading","anchor":"TaskGroups"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"DiscardingTaskGroup"},{"type":"text","text":" releases resources immediately on task completion ."}]}]},{"content":[{"inlineContent":[{"text":"Use the completion of one task to signal the creation of the next in a TaskGroup.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Task-local values","level":2,"type":"heading","anchor":"Task-local-values"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A task-local value is a piece of data associated with a given task, or more precisely, a task hierarchy."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It’s like a global variable, but the value bound to the task-local value is only available from the current task hierarchy.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Task-local values are declared as static properties with the ","type":"text"},{"code":"TaskLocal","type":"codeVoice"},{"text":" property wrapper.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s a good practice to make the task local optional."}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["  @TaskLocal static var orderID: Int?","  @TaskLocal static var cook: String?"]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Any task that doesn’t have the value set will need to return a default value, which is easily represented by a nil optional."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An unbound task local contains its default value."}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["\/\/TaskLocal Values","actor Kitchen {","    @TaskLocal static var orderID: Int?","    @TaskLocal static var cook: String?","    func logStatus() {","        print(\"Current cook: \\(Kitchen.cook ?? \"none\")\")","    }","}","","let kitchen = Kitchen()","await kitchen.logStatus()","await Kitchen.$cook.withValue(\"Sakura\") {","    await kitchen.logStatus()","}","await kitchen.logStatus()"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Task-local values can’t be assigned to explicitly, but must be bound for a specific scope.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"The binding lasts for the duration of the scope, and reverts back to the original value at the end of the scope.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Swift log","level":3,"type":"heading","anchor":"Swift-log"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Logging by hand is repetitive and verbose, which leads to subtle bugs and typos. To prevent that we use SwiftLog."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftLog is a logging API package with multiple backing implementations."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Allows us to drop in a logging back end that suites your needs without making changes to your server."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"MetadataProvider "},{"type":"codeVoice","code":"Logger.MetadataProvider"},{"type":"text","text":" is a new API in SwiftLog 1.5 that:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Automatically includes information in Logger.Metadata","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Good contextual information makes good logs."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"uses a dictionary-like structure, mapping a name to the value being logged.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Multiple libraries may define their own metadata provider to look for library-specific information.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"defines a "},{"type":"codeVoice","code":"multiplex"},{"type":"text","text":" function, which takes multiple metadata providers and combines them into a single object."}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["\/\/MetaDataProvider in action","let orderMetadataProvider = Logger.MetadataProvider {","    var metadata: Logger.Metadata = [:]","    if let orderID = Kitchen.orderID {","        metadata[\"orderID\"] = \"\\(orderID)\"","    }","    return metadata","}","","let chefMetadataProvider = Logger.MetadataProvider {","    var metadata: Logger.Metadata = [:]","    if let chef = Kitchen.chef {","        metadata[\"chef\"] = \"\\(chef)\"","    }","    return metadata","}"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we have a metadata provider, we initialize the logging system with that provider, and we’re ready to start logging."}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["let metadataProvider = Logger.MetadataProvider.multiplex([orderMetadataProvider,","                                                          chefMetadataProvider])","","LoggingSystem.bootstrap(StreamLogHandler.standardOutput, metadataProvider: metadataProvider)","","let logger = Logger(label: \"KitchenService\")"]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"The logs automatically include information specified in the metadata provider, so we don’t need to worry about including it in the log message."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["\/\/Logging and metadata provider","func makeSoup(order: Order) async throws -> Soup {","    logger.info(\"Preparing soup order\")","    async let pot = stove.boilBroth()","    async let choppedIngredients = chopIngredients(order.ingredients)","    async let meat = marinate(meat: .chicken)","    let soup = try await Soup(meat: meat, ingredients: choppedIngredients)","    return try await stove.cook(pot: pot, soup: soup, duration: .minutes(10))","}"]},{"inlineContent":[{"type":"text","text":"Task-local values:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Attach metadata to the current task"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Inherited y child as well as Task { }"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Low-level building block for context"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Task traces","level":3,"type":"heading","anchor":"Task-traces"},{"inlineContent":[{"text":"To trace and profile a concurrent distributed system","type":"text"}],"type":"paragraph"},{"text":"Swift Distributed Tracing","level":4,"type":"heading","anchor":"Swift-Distributed-Tracing"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Open source package for server ecosystem."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Provides an extensible instrumentation API.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Allows us to leverage the benefits of the task tree across multiple systems to gain insight into performance characteristics and task relationships.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Similar to swift Log and Swift Metrics."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift Distributed Tracing package has an implementation of the "},{"type":"codeVoice","code":"OpenTelemetry"},{"type":"text","text":" protocol, so existing tracing solutions, like Zipkin and Jaeger, will work out of the box."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"fills in the opaque "},{"type":"codeVoice","code":"waiting for response"},{"type":"text","text":" in Xcode Instruments with detailed information about what is happening in the server."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"a little different from tracing processes locally.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of getting a trace per-function, we instrument our code with spans using the "},{"type":"codeVoice","code":"withSpan"},{"type":"text","text":" API."}]}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["\/\/Profile server-side execution","func makeSoup(order: Order) async throws -> Soup {","    try await withSpan(\"makeSoup(\\(order.id)\") { span in","        async let pot = stove.boilWater()","        async let choppedIngredients = chopIngredients(order.ingredients)","        async let meat = marinate(meat: .chicken)","        let soup = try await Soup(meat: meat, ingredients: choppedIngredients)","        return try await stove.cook(pot: pot, soup: soup, duration: .minutes(10))","    }","}"]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Spans allow us to assign names to regions of code that are reported in the tracing system.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Spans don’t need to cover an entire function."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"They can provide more insight on specific pieces of a given function."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withSpan"},{"type":"text","text":" annotates our tasks with additional trace IDs and other metadata, allowing the tracing system to merge the task trees into a single trace."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The tracing system has enough information to provide you with insight into the task hierarchy, along with information about the runtime performance characteristics of a task."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The span name is presented in the tracing UI.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You’ll want to keep them short and descriptive so that you can easily find information about a specific span without clutter."}]}]},{"content":[{"inlineContent":[{"text":"We can attach additional metadata with the use of span attributes","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"codeListing","syntax":"swift","code":["func makeSoup(order: Order) async throws -> Soup {","    try await withSpan(#function) { span in","        span.attributes[\"kitchen.order.id\"] = order.id","        async let pot = stove.boilWater()","        async let choppedIngredients = chopIngredients(order.ingredients)","        async let meat = marinate(meat: .chicken)","        let soup = try await Soup(meat: meat, ingredients: choppedIngredients)","        return try await stove.cook(pot: pot, soup: soup, duration: .minutes(10))","    }","}"]},{"items":[{"content":[{"inlineContent":[{"text":"Here we’ve replaced the span name with the ","type":"text"},{"code":"#function","type":"codeVoice"},{"text":" directive to automatically fill the span name with the function name","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"used the span attribute to attach the current order ID to the span information reported to the tracer.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Trace attributes","level":3,"type":"heading","anchor":"Trace-attributes"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Tracing systems usually present the attributes while inspecting a given span.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Most spans come with HTTP status codes, request and response sizes, start and end times, and other metadata making it easy to track information passing through the system.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"If a task fails and throws an error, that information is also presented in the span and reported in the tracing system."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Since spans contain both timing information and the relationships of tasks in the tree, it’s a helpful way to track down errors caused by timing races and identify how they impact other tasks."}]}]}],"type":"unorderedList"},{"text":"The distributed of distributed tracing (Visualize traces even across multiple services\/nodes)","level":3,"type":"heading","anchor":"The-distributed-of-distributed-tracing-Visualize-traces-even-across-multiple-servicesnodes"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Distributed tracing is most powerful when all parts of the system embrace traces, including the HTTP clients, servers, and other RPC systems.","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"Swift Distributed Tracing","type":"codeVoice"},{"type":"text","text":" leverages task-local values, built on the task trees, to automatically propagate all of the information necessary to produce reliable cross-node traces."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Structured tasks:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"unlock the secrets of concurrent systems.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"provide tools to automatically cancel operations."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"automatically propagate priority information."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"facilitate tracing complex distributed workloads."}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"text":"Written By","level":2,"type":"heading","anchor":"Written-By"},{"columns":[{"content":[{"inlineContent":[{"identifier":"RamitSharma991","type":"image"}],"type":"paragraph"}],"size":1},{"content":[{"type":"heading","level":3,"text":"Ramit Sharma","anchor":"Ramit-Sharma"},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/RamitSharma991","overridingTitle":"Contributed Notes","isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}]},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/RamitSharma991","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/x.com\/iosDev_ramit","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/","isActive":true}]}],"size":4}],"numberOfColumns":5,"type":"row"},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}],"type":"paragraph"},{"text":"Related Sessions","level":2,"type":"heading","anchor":"Related-Sessions"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10164-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"],"type":"links"},{"inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}],"type":"small"}]}],"variants":[{"paths":["\/documentation\/wwdcnotes\/wwdc23-10170-beyond-the-basics-of-structured-concurrency"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[],"sampleCodeDownload":{"action":{"identifier":"https:\/\/developer.apple.com\/wwdc23\/10170","isActive":true,"overridingTitle":"Watch Video (24 min)","type":"reference"},"kind":"sampleDownload"},"metadata":{"role":"sampleCode","modules":[{"name":"WWDC Notes"}],"title":"Beyond the basics of structured concurrency","roleHeading":"WWDC23"},"kind":"article","schemaVersion":{"major":0,"patch":0,"minor":3},"abstract":[{"text":"It’s all about the task tree: Find out how structured concurrency can help your apps manage automatic task cancellation, task priority propagation, and useful task-local value patterns. Learn how to manage resources in your app with useful patterns and the latest task group APIs. We’ll show you how you can leverage the power of the task tree and task-local values to gain insight into distributed systems.","type":"text"}],"references":{"WWDC23-Icon.png":{"identifier":"WWDC23-Icon.png","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-Icon.png"}],"alt":null},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110350-Visualize-and-optimize-Swift-concurrency":{"title":"Visualize and optimize Swift concurrency","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","abstract":[{"type":"text","text":"Learn how you can optimize your app with the Swift Concurrency template in Instruments. We’ll discuss common performance issues and show you how to use Instruments to find and resolve these problems. Learn how you can keep your UI responsive, maximize parallel performance, and analyze Swift concurrency activity within your app."}],"kind":"article","url":"\/documentation\/wwdcnotes\/wwdc22-110350-visualize-and-optimize-swift-concurrency","role":"sampleCode","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes":{"title":"WWDC Notes","url":"\/documentation\/wwdcnotes","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"kind":"symbol","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10134-Explore-structured-concurrency-in-Swift":{"url":"\/documentation\/wwdcnotes\/wwdc21-10134-explore-structured-concurrency-in-swift","abstract":[{"type":"text","text":"When you have code that needs to run at the same time as other code, it’s important to choose the right tool for the job. We’ll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We’ll also provide guidance on when you may want to use unstructured tasks."}],"kind":"article","role":"sampleCode","title":"Explore structured concurrency in Swift","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift"},"https://developer.apple.com/wwdc23/10170":{"identifier":"https:\/\/developer.apple.com\/wwdc23\/10170","url":"https:\/\/developer.apple.com\/wwdc23\/10170","type":"download","checksum":null},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10164-Whats-new-in-Swift":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10164-Whats-new-in-Swift","type":"topic","role":"sampleCode","kind":"article","title":"What’s new in Swift","url":"\/documentation\/wwdcnotes\/wwdc23-10164-whats-new-in-swift","abstract":[{"text":"Join us for an update on Swift. We’ll show you how APIs are becoming more extensible and expressive with features like parameter packs and macros. We’ll also take you through improvements to interoperability and share how we’re expanding Swift’s performance and safety benefits everywhere from Foundation to large-scale distributed programs on the server.","type":"text"}]},"WWDC23.jpeg":{"identifier":"WWDC23.jpeg","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23.jpeg"}],"alt":null},"https://x.com/iosDev_ramit":{"identifier":"https:\/\/x.com\/iosDev_ramit","url":"https:\/\/x.com\/iosDev_ramit","titleInlineContent":[{"text":"X\/Twitter","type":"text"}],"type":"link","title":"X\/Twitter"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23":{"abstract":[{"text":"Xcode 15, Swift 5.9, iOS 17, macOS 14 (Sonoma), tvOS 17, visionOS 1, watchOS 10.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"SwiftData","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Observation"},{"type":"text","text":", "},{"type":"codeVoice","code":"StoreKit"},{"type":"text","text":" views, and more."}],"role":"collectionGroup","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc23","title":"WWDC23","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23","images":[{"type":"icon","identifier":"WWDC23-Icon.png"},{"type":"card","identifier":"WWDC23.jpeg"}],"kind":"article"},"https://":{"identifier":"https:\/\/","url":"https:\/\/","titleInlineContent":[{"text":"Blog","type":"text"}],"type":"link","title":"Blog"},"doc://WWDCNotes/documentation/WWDCNotes/RamitSharma991":{"type":"topic","role":"sampleCode","abstract":[{"type":"text","text":"Indie iOS Dev. Swift, SwiftUI, Obj-C, UX and related."}],"title":"Ramit Sharma (15 notes)","kind":"article","url":"\/documentation\/wwdcnotes\/ramitsharma991","images":[{"identifier":"RamitSharma991.jpeg","type":"card"},{"type":"icon","identifier":"RamitSharma991.jpeg"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/RamitSharma991"},"https://github.com/RamitSharma991":{"identifier":"https:\/\/github.com\/RamitSharma991","url":"https:\/\/github.com\/RamitSharma991","titleInlineContent":[{"text":"GitHub","type":"text"}],"type":"link","title":"GitHub"},"RamitSharma991":{"identifier":"RamitSharma991","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/RamitSharma991.jpeg"}],"alt":"Profile image of Ramit Sharma"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10254-Swift-concurrency-Behind-the-scenes":{"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes","type":"topic","title":"Swift concurrency: Behind the scenes","abstract":[{"type":"text","text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We’ll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"type":"link","title":"Contributions are welcome!"},"RamitSharma991.jpeg":{"identifier":"RamitSharma991.jpeg","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/RamitSharma991.jpeg"}],"alt":null},"WWDCNotes.png":{"identifier":"WWDCNotes.png","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"alt":null}}}