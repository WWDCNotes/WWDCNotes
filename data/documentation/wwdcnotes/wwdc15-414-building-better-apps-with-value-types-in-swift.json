{"metadata":{"modules":[{"name":"WWDC Notes"}],"title":"Building Better Apps with Value Types in Swift","roleHeading":"WWDC15","role":"sampleCode"},"abstract":[{"type":"text","text":"Swift supports rich first-class value types in the form of powerful structs, which provide new ways to architect your apps. Learn about the differences between reference and value types, how value types help you elegantly solve common problems around mutability and thread safety, and discover how Swift’s unique capabilities might change the way you think about abstraction."}],"sections":[],"sampleCodeDownload":{"action":{"identifier":"https:\/\/developer.apple.com\/wwdc15\/414","type":"reference","overridingTitle":"Watch Video (39 min)","isActive":true},"kind":"sampleDownload"},"primaryContentSections":[{"content":[{"level":2,"anchor":"Roadmap","type":"heading","text":"Roadmap"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Reference semantics"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Immutability","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Value semantics"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Value types in practice","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Mixing value types and reference types"}]}]}]},{"level":2,"anchor":"1-Reference-semantics","type":"heading","text":"1. Reference semantics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, we get reference semantics with classes."}]},{"level":3,"anchor":"A-Temperature-Class","type":"heading","text":"A Temperature Class"},{"code":["class Temperature {","  var celsius: Double = 0","  var fahrenheit: Double {","    get { return celsius * 9 \/ 5 + 32 }","    set { celsius = (newValue - 32) * 5 \/ 9 }","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s set the thermostat of our home:"}]},{"code":["let home = House()","let temp = Temperature()","temp.fahrenheit = 75","home.thermostat.temperature = temp"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now let’s bake something for dinner. We need to heat up the oven:"}]},{"code":["temp.fahrenheit = 425","home.oven.temperature = temp","home.oven.bake()"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Why is it so hot in the house? Because we unintentionally shared the same temperature object, and now both the thermostat and oven are set to 425 degrees. Here’s the object graph:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-unintended_sharing"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To prevent sharing, we need copies:"}]},{"code":["\/\/ ...","temp.fahrenheit = 75","home.thermostat.temperature = temp.copy()","","temp.fahrenheit = 425","home.oven.temperature = temp.copy()"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Technically, we don’t need this last copy, but we might still do it so we don’t run into the same issue next time. This is called "},{"inlineContent":[{"text":"defensive copying","type":"text"}],"type":"emphasis"},{"type":"text","text":", and we end up having to do this for our "},{"code":"Oven","type":"codeVoice"},{"type":"text","text":", "},{"code":"Thermostat","type":"codeVoice"},{"type":"text","text":", and any other object that might require a new temperature."}]},{"code":["class Oven {","  private var _temperature: Temperature = Temperature(celsius: 0)","","  var temperature: Temperature {","    get { return _temperature }","    set { _temperature = newValue.copy() }","  }","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Copying-in-CocoaTouch-and-Objective-C","type":"heading","text":"Copying in Cocoa[Touch] and Objective-C"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Cocoa[Touch] requires copying throughout."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"NSCopying"},{"type":"text","text":" codifies copying an object"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"NSString","type":"codeVoice"},{"text":", ","type":"text"},{"code":"NSArray","type":"codeVoice"},{"text":", ","type":"text"},{"code":"NSDictionary","type":"codeVoice"},{"text":", ","type":"text"},{"code":"NSURLRequest","type":"codeVoice"},{"text":", etc. all require copying","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Defensive copying pervades Cocoa[Touch] and Objective-C","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"NSDictionary"},{"type":"text","text":" calls "},{"type":"codeVoice","code":"-copy"},{"type":"text","text":" on its keys so that any future changes don’t affect the hash"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"copy"},{"type":"text","text":" attribute provides defensive copying on assignment"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"All of this results in a performance loss, and bugs can still show up any time there’s missed copies.","type":"text"}]},{"level":2,"anchor":"2-Immutability","type":"heading","text":"2. Immutability"},{"level":3,"anchor":"Eliminating-Mutation","type":"heading","text":"Eliminating Mutation"},{"type":"paragraph","inlineContent":[{"text":"Functional programming languages have reference semantics with immutability. This eliminates many problems caused by reference semantics with mutation, such as unintended side effects.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there are several problems with immutable reference semantics:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"They can lead to awkward interfaces because we live and think in a mutable world"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"They don’t map efficiently to the machine model"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Eventually, we have to map to machine code which has stateful CPU, stateful caches, stateful memory and storage, etc.","type":"text"}]}]}],"type":"unorderedList"}]}]},{"level":3,"anchor":"An-immutable-Temperature-class","type":"heading","text":"An immutable Temperature class"},{"code":["class Temperature {","  \/\/ Celsius is now always the point of reference, and it's immutable.","  let celsius: Double = 0","","  var fahrenheit: Double {","    return celsius * 9 \/ 5 + 32","  }","","  \/\/ Convenience initializers.","  init(celsius: Double) { self.celsius = celsius }","  init(fahrenheit: Double) { self.celsius = (fahrenheit - 32) * 5 \/ 9 }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This leads to awkward interfaces. Before, if we wanted to increase our temperature by 10 degrees Fahrenheit, it was simple:"}]},{"code":["\/\/ With mutability","home.oven.temperature.fahrenheit += 10.0"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Without mutability, we have to get the temperature and then create a "},{"type":"emphasis","inlineContent":[{"text":"new","type":"text"}]},{"type":"text","text":" temperature object:"}]},{"code":["\/\/ Without mutability","let temp = home.oven.temperature","home.oven.temperature = Temperature(fahrenheit: temp.fahrenheit + 10.0)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is more awkward and less performant because we need to allocate another object on the heap."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most importantly, this solution is still not truly immutable. We’re still mutating the "},{"type":"codeVoice","code":"Oven"},{"type":"text","text":" when we set a new temperature. A truly immutable system would create a new temperature, a new oven, and a new home…which is still awkward."}]},{"level":3,"anchor":"Sieve-of-Eratosthenes","type":"heading","text":"Sieve of Eratosthenes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Getting a little more mathematical–the Sieve of Eratosthenes is an ancient algorithm for computing prime numbers. This algorithm lends itself very well to mutation."}]},{"type":"paragraph","inlineContent":[{"text":"This is the mutable implementation of the algorithm in Swift:","type":"text"}]},{"code":["func primes(n: Int) -> [Int] {","  var numbers = [Int](2..<n)","","  for i in 0..<n - 2 {","    guard let prime = numbers[i] where prime > 0 else { continue }","    for multiple in stride(from: 2 * prime - 2, to: n - 2, by: prime) {","      numbers[multiple] = 0","    }","  }","","  return numbers.filter { $0 > 0 }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The algorithm basically creates an array of numbers from 2 to ","type":"text"},{"code":"n","type":"codeVoice"},{"text":". The outer loop walks through the array. The inner loop, going right, sets all multiples of that number to ","type":"text"},{"code":"0","type":"codeVoice"},{"text":". The algorithm then returns only non-zero values from the array, which is all the prime numbers.","type":"text"}]},{"level":3,"anchor":"Functional-Sieve-of-Eratosthenes","type":"heading","text":"Functional Sieve of Eratosthenes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also express this algorithm in a world without mutation. Here is the implementation in Haskell, a purely functional language:"}]},{"code":["primes = sieve [2..]","sieve [] = []","sieve (p : xs) = p : sieve [x | x <- xs, x 'mod' p > 0]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"We can do exactly the same thing in Swift:","type":"text"}]},{"code":["func sieve(numbers: [Int]) -> [Int] {","  guard !numbers.isEmpty else { return [] }","  let p = numbers[0]","  return [p] + sieve(numbers[1..<numbers.count]).filter { $0 % p > 0 }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This immutable algorithm is very similar to the mutable one. Assuming the array isn’t empty, we take out the first number ("},{"type":"codeVoice","code":"2"},{"type":"text","text":"), which is always prime. We then perform a filter operation and copy over all array elements that are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" divisible by that number. Then we recurse, and we build up the prime numbers on the left-hand diagonal. These are concatenated together to get the result."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC15-414-immutable_sieve","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Unfortunately, this algorithm is ","type":"text"},{"inlineContent":[{"text":"not","type":"text"}],"type":"emphasis"},{"text":" similar in performance","type":"text"}]},{"text":". The problem is the ","type":"text"},{"type":"codeVoice","code":"filter"},{"text":" operation. In the original mutating algorithm, we only walked over multiples of the prime number, which get more and more sparse as the multiple increases. Moreover, we only have to do addition to get to the next element. Overall, the mutating version does less work per element.","type":"text"}]},{"level":3,"anchor":"Immutability-in-CocoaTouch","type":"heading","text":"Immutability in Cocoa[Touch]"},{"type":"paragraph","inlineContent":[{"text":"Cocoa[Touch] has a number of immutable classes:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"NSDate","type":"codeVoice"},{"text":", ","type":"text"},{"code":"NSURL","type":"codeVoice"},{"text":", ","type":"text"},{"code":"UIImage","type":"codeVoice"},{"text":", ","type":"text"},{"code":"NSNumber","type":"codeVoice"},{"text":", etc.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Improved safety (no need to use copy)","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"There are also downsides to immutability. In Objective-C, if we wanted to start at our home directory and successively add path components, we would have to create a new ","type":"text"},{"code":"NSURL","type":"codeVoice"},{"text":" object on each loop iteration:","type":"text"}]},{"code":["NSURL *url = [[NSURL alloc] initWithString: NSHomeDirectory()];","NSString *component;","while ((component = getNextSubdir())) {","  \/\/ Create new object on heap, copy over all string data, discard old object...","  url = [url URLByAppendingPathComponent: component];","}"],"syntax":"objectivec","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There’s a better way to do this–we could just add the components to an array and create a single new "},{"type":"codeVoice","code":"NSURL"},{"type":"text","text":" instance at the end. However, if we want to be truly immutable, we have to create a new array on each iteration of the loop…which is still "},{"type":"codeVoice","code":"O(n^2)"},{"type":"text","text":":"}]},{"code":["NSArray<NSString *> *array = [NSArray arrayWithObject: NSHomeDirectory()];","NSString *component;","while ((component = getNextSubdir())) {","  \/\/ Create new array, copy over elements, discard old array...","  array = [array arrayByAddingObject: component];","}","url = [NSURL fileURLWithPathComponents: array];"],"syntax":"objectivec","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"strong","inlineContent":[{"text":"correct","type":"text"}]},{"type":"text","text":" way to do this in Cocoa is to use mutation–we need to store all our components into an "},{"type":"codeVoice","code":"NSMutableArray"},{"type":"text","text":" and then create the "},{"type":"codeVoice","code":"NSURL"},{"type":"text","text":" at the end, which is "},{"type":"codeVoice","code":"O(n)"},{"type":"text","text":":"}]},{"code":["NSMutableArray<NSString *> *array = [NSMutableArray array];","[array addObject: NSHomeDirectory()];","NSString *component;","while ((component = getNextSubdir())) {","  [array addObject: component];  \/\/ Mutate array object.","}","url = [NSURL fileURLWithPathComponents: array];"],"syntax":"objectivec","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Immutability is a good thing:","type":"text"}]},{"text":" it makes the reference semantics world easier to reason about, but we still can’t go entirely immutable.","type":"text"}]},{"level":2,"anchor":"3-Value-Semantics","type":"heading","text":"3. Value Semantics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s take a different approach. We like mutation because it’s easy to use when done correctly, but the problem is data sharing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Value types solve this problem. Mutating one variable of some value type will never affect a different variable:"}]},{"code":["var a: Int = 17","var b = a","assert(a == b)","b += 25","print(\"a = \\(a), b = \\(b)\")  \/\/ Prints \"a = 17, b = 42\""],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We’re used to this with fundamental types like numbers and perhaps "},{"type":"codeVoice","code":"CGPoint"},{"type":"text","text":"–we would never expect that a change to "},{"type":"codeVoice","code":"b"},{"type":"text","text":" would affect "},{"type":"codeVoice","code":"a"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can take this same principle and extend it to more complex types."}]},{"level":3,"anchor":"Value-types-compose","type":"heading","text":"Value types compose"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"All of Swift’s “fundamental” types are value types"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"Double"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", …"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"All of Swift’s collections are value types"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"Array","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Set","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Dictionary","type":"codeVoice"},{"text":", …","type":"text"}]}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, any tuple, struct, or enum that contains only value types is also a value type. It’s very easy to build rich abstractions entirely in the world of value types."}]},{"level":3,"anchor":"Value-types-are-distinguished-by-value","type":"heading","text":"Value types are distinguished by value"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Equality is established by the value of a variable, not its identity or how we arrived at the value."}]},{"type":"paragraph","inlineContent":[{"text":"This makes perfect sense for fundamental types like Integers…","type":"text"}]},{"code":["var a: Int = 5","var b: Int = 2 + 3","assert(a == b)  \/\/ True"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"…so we can extend it to less fundamental types like collections:"}]},{"code":["var a: [Int] = [1, 2, 3]","var b: [Int] = [3, 2, 1].sort(<)","assert(a == b)  \/\/ True"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Value-types-should-implement-Equatable","type":"heading","text":"Value types should implement `Equatable`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can’t understand our code unless we have reflexive, symmetric, and transitive notions of equality."}]},{"code":["protocol Equatable {","  \/\/\/ Reflexive: `x == x` is `true`","  \/\/\/ Symmetric: If `x == y` then `y == x`","  \/\/\/ Transitive: If `x == y` and `y == z`, then `x == z`","  func ==(lhs: Self, rhs: Self) -> Bool","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Fortunately, it’s very easy to conform to "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":". After declaring conformance, we just have to implement the equality operator for our properties. Generally speaking, when we compose value types out of other value types, we can rely on the underlying "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operators defined for each property."}]},{"type":"paragraph","inlineContent":[{"text":"In this example, we define equality for ","type":"text"},{"code":"CGPoint","type":"codeVoice"},{"text":" by using equality for ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", another value type:","type":"text"}]},{"code":["extension CGPoint: Equatable {}","","func ==(lhs: CGPoint, rhs: CGPoint) -> Bool {","  return lhs.x == rhs.x && lhs.y == rhs.y","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Value-semantics-version-of-Temperature","type":"heading","text":"Value semantics version of `Temperature`"},{"type":"paragraph","inlineContent":[{"text":"Let’s make ","type":"text"},{"code":"Temperature","type":"codeVoice"},{"text":" a struct now.","type":"text"}]},{"code":["struct Temperature: Equatable {","  var celsius: Double = 0","  var fahrenheit: Double {","    get { return celsius * 9 \/ 5 + 32 }","    set { celsius = (newValue - 32) * 5 \/ 9 }","  }","}","","func ==(lhs: Temperature, rhs: Temperature) -> Bool {","  return lhs.celsius == rhs.celsius","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Unfortunately, we run into an error when using this new "},{"type":"codeVoice","code":"struct"},{"type":"text","text":":"}]},{"code":["let temp = Temperature()","temp.fahrenheit = 75  \/\/ ERROR: cannot assign to property: 'temp' is a 'let' constant"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"All we have to do is change ","type":"text"},{"code":"let","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"var","type":"codeVoice"},{"text":", and our code works perfectly fine because both ","type":"text"},{"code":"thermostat","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"oven","type":"codeVoice"},{"text":" have their own instances of ","type":"text"},{"code":"Temperature","type":"codeVoice"},{"text":" values. There is no more sharing, and the values are also inlined into the ","type":"text"},{"code":"struct","type":"codeVoice"},{"text":" so we get better memory usage and performance:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC15-414-value_temperature","type":"image"}]},{"level":3,"anchor":"Mutation-when-we-want-it-but-not-when-we-dont","type":"heading","text":"Mutation when we want it, but not when we don’t"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Value semantics work well in Swift because we already have keywords to indicate mutability."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"let"},{"type":"text","text":" means the value will "},{"type":"strong","inlineContent":[{"type":"text","text":"never"}]},{"type":"text","text":" change, which is a very strong statement!"}]},{"code":["let numbers = [1, 2, 3, 4, 5]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"code":"var","type":"codeVoice"},{"type":"text","text":" means we can update the value without affecting any other values in our code (no data sharing)."}]},{"code":["var strings = [String]()","for x in numbers {","  strings.append(String(x))","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This gives us "},{"type":"emphasis","inlineContent":[{"text":"controlled","type":"text"}]},{"type":"text","text":" mutability with strong guarantees throughout our code."}]},{"level":3,"anchor":"Freedom-from-race-conditions","type":"heading","text":"Freedom from race conditions"},{"type":"paragraph","inlineContent":[{"text":"Passing value types across thread boundaries means we don’t have to worry about race conditions on those types.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In an array with reference semantics, the code below would cause a race condition because the same array would be shared by both threads. In an array with value semantics, we get ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"logical","type":"text"}]},{"text":" copies each time, so each thread gets its own array.","type":"text"}]},{"code":["var numbers = [1, 2, 3, 4, 5]","scheduler.processNumbersAsynchronously(numbers)","","for i in 0..<numbers.count {","  numbers[i] = numbers[i] * 1","}","","scheduler.processNumbersAsynchronously(numbers)"],"syntax":"swift","type":"codeListing"},{"level":4,"anchor":"What-about-all-those-copies","type":"heading","text":"What about all those copies?"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Copies are cheap ("},{"type":"codeVoice","code":"O(1)"},{"type":"text","text":") with value semantics."}]},{"type":"text","text":" Let’s build this from the ground-up:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Copying a low-level, fundamental type is constant time ("},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"Double"},{"type":"text","text":", …)"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Just requires copying a few bytes, which happens inside the processor."}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Copying a struct, enum, or tuple of value types is also constant time ("},{"type":"codeVoice","code":"CGPoint"},{"type":"text","text":", …)"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Fixed number of fields, so it’s not ","type":"text"},{"code":"O(n)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Copying each “building block” is constant time, so copying the whole object is also constant time."}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Extensible data structures use copy-on-write"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Copying involves a fixed number of reference counting operations."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Copying only happens at the point of mutation. This is “sharing behind the scenes”, but not logical sharing. These are treated as distinct values "},{"type":"emphasis","inlineContent":[{"type":"text","text":"when they need to be"}]},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"String"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Set"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":", etc.","type":"text"}]}]}],"type":"unorderedList"}]}]},{"level":3,"anchor":"Recap-Value-semantics-are-simple-and-efficient","type":"heading","text":"Recap: Value semantics are simple and efficient"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Different variables are logically distinct"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Mutability when we want it","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Copies are cheap","type":"text"}],"type":"paragraph"}]}]},{"level":2,"anchor":"4-Value-types-in-practice","type":"heading","text":"4. Value types in practice"},{"type":"paragraph","inlineContent":[{"text":"We’re going to build a diagram made out of some simple value types like circles and polygons.","type":"text"}]},{"level":3,"anchor":"Circle","type":"heading","text":"Circle"},{"code":["struct Circle: Equatable {","  var center: CGPoint","  var radius: Double","}","","func ==(lhs: Circle, rhs: Circle) {","  return lhs.center == rhs.center && lhs.radius == rhs.radius","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC15-414-circle_struct","type":"image"}]},{"level":3,"anchor":"Polygon","type":"heading","text":"Polygon"},{"code":["struct Polygon: Equatable {","  var corners = [CGPoint]()","}","","func ==(lhs: Polygon, rhs: Polygon) {","  return lhs.corners == rhs.corners","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-polygon_struct"}]},{"level":3,"anchor":"Diagrams-need-to-contain-either-shape","type":"heading","text":"Diagrams need to contain either shape"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can just make both "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Polygon"},{"type":"text","text":" conform to a new protocol, "},{"type":"codeVoice","code":"Drawable"},{"type":"text","text":". For more information, see "},{"type":"reference","identifier":"..\/408","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-diagram_protocol"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s the protocol and conforming implementations:"}]},{"code":["protocol Drawable {","  func draw()","}","","extension Polygon: Drawable {","  func draw() {","    let ctx = UIGraphicsGetCurrentContext()","    CGContextMoveToPoint(ctx, corners.last!.x, corners.last!.y)","    for point in corners {","      CGContextAddLineToPoint(ctx, point.x, point.y)","    }","    CGContextClosePath(ctx)","    CGContextStrokePath(ctx)","  }","}","","extension Circle: Drawable {","  func draw() {","    let arc = CGPathCreateMutable()","    CGPathAddArc(arc, nil, center.x, center.y, radius, 0, 2 * π, true)","    CGContextAddPath(ctx, arc)","    CGContextStrokePath(ctx)","  }","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Creating-Diagram","type":"heading","text":"Creating `Diagram`"},{"code":["struct Diagram {","  var items = [Drawable]()","","  mutating func addItem(item: Drawable) {","    items.append(item)","  }","","  func draw() {","    for item in items {","      item.draw()","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Using-the-diagram","type":"heading","text":"Using the diagram"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-copied_on_assignment"}]},{"level":3,"anchor":"Making-Diagram-Equatable","type":"heading","text":"Making `Diagram` `Equatable`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The straightforward implementation would be to just use equality for each item in the "},{"type":"codeVoice","code":"items"},{"type":"text","text":" array, but this causes an error:"}]},{"code":["extension Diagram: Equatable {}","","func ==(lhs: Diagram, rhs: Diagram) {","  \/\/ ERROR: binary operator '==' cannot be applied to two [Drawable] operands","  return lhs.items == rhs.items","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"For more information, see ","type":"text"},{"isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"Protocol-Oriented Programming in Swift"}],"type":"reference","overridingTitle":"Protocol-Oriented Programming in Swift","identifier":"..\/408"},{"text":".","type":"text"}]},{"level":3,"anchor":"Making-Diagram-Drawable","type":"heading","text":"Making `Diagram` `Drawable`"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Diagram"},{"text":" already has a ","type":"text"},{"type":"codeVoice","code":"draw()"},{"text":" function, so all we have to do is declare conformance:","type":"text"}]},{"code":["struct Diagram: Drawable { ... }"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"We can actually add a new instance of ","type":"text"},{"code":"Diagram","type":"codeVoice"},{"text":" to the first ","type":"text"},{"code":"Diagram","type":"codeVoice"},{"text":", and it’s all contained inside the ","type":"text"},{"code":"items","type":"codeVoice"},{"text":" array:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC15-414-diagram_drawable1","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"We can even add the diagram to its own ","type":"text"},{"type":"codeVoice","code":"items"},{"text":" array:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-diagram_drawable2"}]},{"type":"paragraph","inlineContent":[{"text":"Why doesn’t this cause infinite recursion? Let’s look at the implementation of ","type":"text"},{"code":"Diagram.draw","type":"codeVoice"},{"text":":","type":"text"}]},{"code":["func draw() {","  for item in items {","    item.draw()","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"Diagram"},{"type":"text","text":" used reference semantics, we "},{"type":"strong","inlineContent":[{"type":"text","text":"would"}]},{"type":"text","text":" get infinite recursion. Calling "},{"type":"codeVoice","code":"draw"},{"type":"text","text":" would iterate through "},{"type":"codeVoice","code":"items"},{"type":"text","text":", and eventually it would call its own "},{"type":"codeVoice","code":"draw"},{"type":"text","text":" again…and again."}]},{"type":"paragraph","inlineContent":[{"text":"However, we’re using value semantics. We get an entirely new copy of ","type":"text"},{"type":"codeVoice","code":"Diagram"},{"text":" that is ","type":"text"},{"inlineContent":[{"type":"text","text":"not equal"}],"type":"strong"},{"text":" to the original ","type":"text"},{"type":"codeVoice","code":"Diagram"},{"text":" because it doesn’t have itself in its ","type":"text"},{"type":"codeVoice","code":"items"},{"text":" array:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-diagram_copy"}]},{"level":2,"anchor":"5-Mixing-value-types-and-reference-types","type":"heading","text":"5. Mixing value types and reference types"},{"level":3,"anchor":"Reference-types-often-contain-value-types","type":"heading","text":"Reference types often contain value types"},{"type":"paragraph","inlineContent":[{"text":"Value types are generally used for “primitive” data of objects:","type":"text"}]},{"code":["class Button: Control {","  var label: String","  var enabled: Bool","  \/\/ ...","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"A-value-type-can-contain-a-reference","type":"heading","text":"A value type can contain a reference"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Copies of the value type will share the reference:"}]},{"code":["struct ButtonWrapper {","  var button: Button","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Maintaining value semantics requires special considerations:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"How do we cope with mutation of the referenced object?"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"How does the reference identity affect equality?"}],"type":"paragraph"}]}]},{"level":3,"anchor":"Immutable-references-are-okay","type":"heading","text":"Immutable references are okay!"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s create an "},{"type":"codeVoice","code":"Image"},{"type":"text","text":" struct that wraps a reference type, "},{"type":"codeVoice","code":"UIImage"},{"type":"text","text":":"}]},{"code":["struct Image: Drawable {","  var topLeft: CGPoint","  var image: UIImage","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Now, let’s create 2 images which point to the same ","type":"text"},{"code":"UIImage","type":"codeVoice"},{"text":" object:","type":"text"}]},{"code":["var image = Image(","  topLeft: CGPoint(x: 0, y: 0),","  image: UIImage(imageNamed: \"San Francisco\")!",")","var image2 = image"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-image_copy"}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"This is not going to cause issues (like with "},{"code":"Temperature","type":"codeVoice"},{"type":"text","text":") because "},{"code":"UIImage","type":"codeVoice"},{"type":"text","text":" is immutable"}]},{"type":"text","text":". We don’t have to worry about "},{"code":"image2","type":"codeVoice"},{"type":"text","text":" mutating the image it shares with "},{"code":"image","type":"codeVoice"},{"type":"text","text":"."}]},{"level":3,"anchor":"Immutable-references-and-Equatable","type":"heading","text":"Immutable references and `Equatable`"},{"type":"paragraph","inlineContent":[{"text":"Let’s implement ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" for our struct. Notice the ","type":"text"},{"code":"===","type":"codeVoice"},{"text":" operator that checks if both ","type":"text"},{"code":"image","type":"codeVoice"},{"text":" properties point to the same ","type":"text"},{"code":"UIImage","type":"codeVoice"},{"text":" in memory:","type":"text"}]},{"code":["extension Image: Equatable {}","func ==(lhs: Image, rhs: Image) -> Bool {","  return lhs.topLeft == rhs.topLeft && lhs.image === rhs.image","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This would work in the example we have, but what if we create 2 separate ","type":"text"},{"code":"UIImage","type":"codeVoice"},{"text":"s using the same underlying bitmap?","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-double_image"}]},{"type":"paragraph","inlineContent":[{"text":"These should also be considered equal. However, even though both ","type":"text"},{"type":"codeVoice","code":"UIImage"},{"text":"s were created with the same bitmap, they would have different references, and our ","type":"text"},{"type":"codeVoice","code":"==="},{"text":" operator would consider these images unequal.","type":"text"}]},{"level":3,"anchor":"Reference-identity-is-not-enough","type":"heading","text":"Reference identity is not enough"},{"type":"paragraph","inlineContent":[{"text":"Instead, we should use the ","type":"text"},{"type":"codeVoice","code":"isEqual"},{"text":" method that ","type":"text"},{"type":"codeVoice","code":"UIImage"},{"text":" inherits from ","type":"text"},{"type":"codeVoice","code":"NSObject"},{"text":":","type":"text"}]},{"code":["func ==(lhs: Image, rhs: Image) -> Bool {","  return lhs.topLeft == rhs.topLeft && lhs.image.isEqual(rhs.image)","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"References-to-mutable-objects","type":"heading","text":"References to mutable objects"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This "},{"code":"BezierPath","type":"codeVoice"},{"type":"text","text":" value type is made up entirely of a reference to a mutable type, "},{"code":"UIBezierPath","type":"codeVoice"},{"type":"text","text":". If we have 2 "},{"code":"BezierPath","type":"codeVoice"},{"type":"text","text":"s pointing to the same reference, calling "},{"code":"addLineToPoint","type":"codeVoice"},{"type":"text","text":" is going to cause problems for both objects."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-reference_mutable_object"}]},{"code":["struct BezierPath: Drawable {","  var path = UIBezierPath()","","  var isEmpty: Bool {","    return path.empty","  }","","  \/\/ Potential problems","  func addLineToPoint(point: CGPoint) {","    path.addLineToPoint(point)","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Also notice that there is no "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword because "},{"type":"codeVoice","code":"path"},{"type":"text","text":" is a reference type. This is a bad situation because we’re not maintaining value semantics even though we’re using value types."}]},{"level":3,"anchor":"Copy-on-write","type":"heading","text":"Copy-on-write"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Unrestricted mutation of referenced objects breaks value semantics","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Separate non-mutating operations from mutating ones"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Non-mutating operations are always safe"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Mutating operations must first copy","type":"text"}]}]}],"type":"unorderedList"}]}]},{"level":3,"anchor":"Copy-on-write-in-action","type":"heading","text":"Copy-on-write in action"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We need to separate accessors for reading and writing so we maintain value semantics."}]},{"code":["struct BezierPath: Drawable {","  private var _path = UIBezierPath()","","  var pathForReading: UIBezierPath {","    return _path","  }","","  var pathForWriting: UIBezierPath {","    mutating get {","      _path = _path.copy() as! UIBezierPath","      return _path","    }","  }","","  var isEmpty: Bool {","    return pathForReading.empty","  }","","  mutating func addLineToPoint(point: CGPoint) {","    pathForWriting.addLineToPoint(point)","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, if we use "},{"code":"BezierPath","type":"codeVoice"},{"type":"text","text":", we share references as long as there’s no mutation…"}]},{"code":["var path = BezierPath()","var path2 = path","if path.empty { print(\"Path is empty\") }"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-bezier_shared_read"}]},{"type":"paragraph","inlineContent":[{"text":"…and when we mutate, we first create a copy so ","type":"text"},{"type":"codeVoice","code":"path2"},{"text":" is not affected:","type":"text"}]},{"code":["path.addLineToPoint(CGPoint(x: 10, y: 20))"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-bezier_shared_write"}]},{"level":3,"anchor":"Forming-a-path-from-a-Polygon","type":"heading","text":"Forming a path from a `Polygon`"},{"type":"paragraph","inlineContent":[{"text":"Immutable algorithm:","type":"text"}]},{"code":["extension Polygon {","  var path: BezierPath {","    var result = BezierPath()","    result.moveToPoint(corners.last!)","    for point in corners {","      \/\/ Copies `BezierPath` in every iteration of the loop!","      result.addLineToPoint(point)","    }","    return result","  }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of the copies, we may see a performance hit. A better implementation "},{"type":"emphasis","inlineContent":[{"type":"text","text":"carefully"}]},{"type":"text","text":" uses mutation:"}]},{"code":["extension Polygon {","  var path: BezierPath {","    var result = UIBezierPath()  \/\/ Reference type","    result.moveToPoint(corners.last!)","    for point in corners {","      result.addLineToPoint(point)  \/\/ Mutate in every iteration","    }","    return BezierPath(path: result) \/\/ Create value type at end","  }","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Uniquely-referenced-Swift-objects","type":"heading","text":"Uniquely referenced Swift objects"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift can tell us if objects are uniquely referenced, so we can avoid making copies if we don’t need to. The Swift Standard Library uses this feature extensively."}]},{"code":["struct MyWrapper {","  var _object: SomeSwiftObject","  var objectForWriting: SomeSwiftObject {","    mutating get {","      if !isUniquelyReferencedNonObjc(&_object) {","        _object = _object.copy()","      }","      return _object","    }","  }","}"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"Recap-Mixing-value-types-and-reference-types","type":"heading","text":"Recap: Mixing value types and reference types"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Maintaining value semantics requires special considerations","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Copy-on-write enables efficient value semantics when wrapping Swift reference types","type":"text"}],"type":"paragraph"}]}]},{"level":3,"anchor":"Implementing-undo-with-value-types","type":"heading","text":"Implementing undo with value types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We’re going to create a diagram and an array of diagrams. With every mutation, we add our "},{"type":"codeVoice","code":"doc"},{"type":"text","text":" to our diagram array."}]},{"code":["var doc = Diagram()","var undoStack = [Diagram]()","undoStack.append(doc)","","doc.addItem(Polygon())","undoStack.append(doc)","","doc.addItem(Circle())","undoStack.append(doc)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC15-414-undo_stack","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, our "},{"code":"undo_stack","type":"codeVoice"},{"type":"text","text":" has 3 distinct instances of "},{"code":"Diagram","type":"codeVoice"},{"type":"text","text":". These aren’t references to the same "},{"code":"Diagram","type":"codeVoice"},{"type":"text","text":" because we’re using value semantics."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In an app, this could enable a history feature that gives us a list of all our states. We can easily go back and forth just by indexing into the "},{"code":"undo_stack","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC15-414-history_feature"}]},{"type":"paragraph","inlineContent":[{"text":"In fact, Adobe Photoshop uses value semantics to implement their history feature. Every action results in a new ","type":"text"},{"type":"codeVoice","code":"doc"},{"text":" instance, and this is efficient because of copy-on-write.","type":"text"}]},{"level":2,"anchor":"Summary","type":"heading","text":"Summary"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reference semantics and unexpected mutation can lead to bugs"}]}]},{"content":[{"inlineContent":[{"text":"Value semantics solve these problems by giving you the expressiveness of mutability and the safety of immutability","type":"text"}],"type":"paragraph"}]}]},{"level":2,"anchor":"Written-By","type":"heading","text":"Written By"},{"numberOfColumns":5,"type":"row","columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"skhillon"}]}]},{"size":4,"content":[{"type":"heading","level":3,"anchor":"Sarthak-Khillon","text":"Sarthak Khillon"},{"type":"paragraph","inlineContent":[{"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","isActive":true,"overridingTitle":"Contributed Notes"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/skhillon","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/x.com\/SarthakKhillon","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","isActive":true}]}]}]},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}]},{"level":2,"anchor":"Related-Sessions","type":"heading","text":"Related Sessions"},{"style":"list","type":"links","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-419-Protocol-and-Value-Oriented-Programming-in-UIKit-Apps"]},{"type":"small","inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC15-414-Building-Better-Apps-with-Value-Types-in-Swift","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc15-414-building-better-apps-with-value-types-in-swift"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC15"]]},"kind":"article","references":{"WWDC15-414-diagram_drawable2":{"identifier":"WWDC15-414-diagram_drawable2","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC15-414-diagram_drawable2.png"}]},"WWDC15-414-bezier_shared_write":{"identifier":"WWDC15-414-bezier_shared_write","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-bezier_shared_write.png","traits":["1x","light"]}]},"https://github.com/skhillon":{"url":"https:\/\/github.com\/skhillon","title":"GitHub","type":"link","titleInlineContent":[{"type":"text","text":"GitHub"}],"identifier":"https:\/\/github.com\/skhillon"},"WWDC15-414-diagram_protocol":{"identifier":"WWDC15-414-diagram_protocol","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC15-414-diagram_protocol.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC16-419-Protocol-and-Value-Oriented-Programming-in-UIKit-Apps":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-419-Protocol-and-Value-Oriented-Programming-in-UIKit-Apps","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc16-419-protocol-and-value-oriented-programming-in-uikit-apps","title":"Protocol and Value Oriented Programming in UIKit Apps","kind":"article","type":"topic","abstract":[{"type":"text","text":"Building on last year’s Protocol-Oriented Programming and Building Better Apps with Value Types sessions, this year’s session will highlight tips and tricks for building better Swift apps. See how you can incorporate these design approaches into a real MVC-based Cocoa Touch app, especially in the view and controller layers, where you might not have thought of using these techniques before."}]},"skhillon.jpeg":{"identifier":"skhillon.jpeg","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/skhillon.jpeg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","url":"\/documentation\/wwdcnotes","type":"topic","title":"WWDC Notes","images":[{"type":"icon","identifier":"WWDCNotes.png"}]},"WWDC15-414-undo_stack":{"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-undo_stack.png","traits":["1x","light"]}],"alt":null,"type":"image","identifier":"WWDC15-414-undo_stack"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","title":"Contributions are welcome!","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}]},"WWDC15-414-unintended_sharing":{"identifier":"WWDC15-414-unintended_sharing","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-unintended_sharing.png","traits":["1x","light"]}]},"https://www.linkedin.com/in/sarthakkhillon/":{"url":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","title":"Blog","type":"link","titleInlineContent":[{"type":"text","text":"Blog"}],"identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/"},"WWDC15-414-bezier_shared_read":{"identifier":"WWDC15-414-bezier_shared_read","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC15-414-bezier_shared_read.png"}]},"WWDC15-414-image_copy":{"identifier":"WWDC15-414-image_copy","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-image_copy.png","traits":["1x","light"]}]},"skhillon":{"variants":[{"url":"\/images\/WWDCNotes\/skhillon.jpeg","traits":["1x","light"]}],"alt":"Profile image of Sarthak Khillon","type":"image","identifier":"skhillon"},"WWDC15-Icon.png":{"identifier":"WWDC15-Icon.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC15-Icon.png"}]},"WWDC15-414-reference_mutable_object":{"identifier":"WWDC15-414-reference_mutable_object","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-reference_mutable_object.png","traits":["1x","light"]}]},"WWDC15-414-polygon_struct":{"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-polygon_struct.png","traits":["1x","light"]}],"alt":null,"type":"image","identifier":"WWDC15-414-polygon_struct"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDCNotes.png"}]},"WWDC15.jpeg":{"identifier":"WWDC15.jpeg","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15.jpeg","traits":["1x","light"]}]},"WWDC15-414-immutable_sieve":{"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-immutable_sieve.png","traits":["1x","light"]}],"alt":null,"type":"image","identifier":"WWDC15-414-immutable_sieve"},"https://x.com/SarthakKhillon":{"identifier":"https:\/\/x.com\/SarthakKhillon","url":"https:\/\/x.com\/SarthakKhillon","type":"link","title":"X\/Twitter","titleInlineContent":[{"type":"text","text":"X\/Twitter"}]},"../408":{"identifier":"..\/408","type":"link","title":"Protocol-Oriented Programming in Swift","url":"..\/408","titleInlineContent":[{"type":"text","text":"Protocol-Oriented Programming in Swift"}]},"WWDC15-414-diagram_copy":{"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-diagram_copy.png","traits":["1x","light"]}],"alt":null,"type":"image","identifier":"WWDC15-414-diagram_copy"},"WWDC15-414-double_image":{"identifier":"WWDC15-414-double_image","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC15-414-double_image.png"}]},"WWDC15-414-history_feature":{"identifier":"WWDC15-414-history_feature","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-history_feature.png","traits":["1x","light"]}]},"WWDC15-414-value_temperature":{"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-value_temperature.png","traits":["1x","light"]}],"alt":null,"type":"image","identifier":"WWDC15-414-value_temperature"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC15":{"url":"\/documentation\/wwdcnotes\/wwdc15","title":"WWDC15","role":"collectionGroup","kind":"article","images":[{"identifier":"WWDC15-Icon.png","type":"icon"},{"identifier":"WWDC15.jpeg","type":"card"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC15","abstract":[{"text":"Xcode 7, Swift 2.0, iOS 9, macOS 10.11 (El Capitan), watchOS 2.","type":"text"}],"type":"topic"},"https://developer.apple.com/wwdc15/414":{"identifier":"https:\/\/developer.apple.com\/wwdc15\/414","url":"https:\/\/developer.apple.com\/wwdc15\/414","checksum":null,"type":"download"},"WWDC15-414-circle_struct":{"identifier":"WWDC15-414-circle_struct","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-circle_struct.png","traits":["1x","light"]}]},"WWDC15-414-copied_on_assignment":{"identifier":"WWDC15-414-copied_on_assignment","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC15-414-copied_on_assignment.png","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/skhillon":{"images":[{"identifier":"skhillon.jpeg","type":"card"},{"identifier":"skhillon.jpeg","type":"icon"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","url":"\/documentation\/wwdcnotes\/skhillon","role":"sampleCode","abstract":[{"text":"No Bio on GitHub","type":"text"}],"type":"topic","title":"Sarthak Khillon (19 notes)","kind":"article"},"WWDC15-414-diagram_drawable1":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC15-414-diagram_drawable1.png"}],"alt":null,"type":"image","identifier":"WWDC15-414-diagram_drawable1"}}}