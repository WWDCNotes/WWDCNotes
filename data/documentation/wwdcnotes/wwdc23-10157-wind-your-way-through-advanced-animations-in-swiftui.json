{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"SwiftUI animations are interruptible, physics-based, and integrated throughout the framework."}],"type":"paragraph"},{"inlineContent":[{"text":"First: A quick review of the animation tools in SwiftUI","type":"text"}],"type":"paragraph"},{"anchor":"Scale-Animation","level":3,"type":"heading","text":"Scale Animation"},{"code":["struct Avatar: View {","    var petImage: Image","    @State private var selected: Bool = false","","    var body: some View {","        petImage","            .scaleEffect(selected ? 1.5 : 1.0)","            .onTapGesture {","                withAnimation {","                    selected.toggle()","                }","            }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Adding animation is as easy as using “withAnimation” or adding an “animation” modifier.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"After the state of the application changes, SwiftUI applies animations that interpolate from the previous state to the new state.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-first"}],"type":"paragraph"},{"inlineContent":[{"text":"But some animations don’t simply animate from a previous state into a new state.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Rather than animating between two states, these animations can define multiple steps that happen in sequence.","type":"text"},{"text":" ","type":"text"},{"text":"Especially great in two situations:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"repeating animations, that loop continuously while a view is visible…","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"and with event-driven animations, such as a view that pulses when an event occurs.","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"There a new family of APIs that makes animations easier to build."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this session:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Animation phases, which let SwiftUI automatically advance through a set of pre-planned states that make up your animation.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Keyframes","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Some tips and tricks to get the most out of this API."}],"type":"paragraph"}]}]},{"anchor":"Animation-phases","level":1,"type":"heading","text":"Animation phases"},{"inlineContent":[{"text":"Ex with trail running.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Trail races can be very long. Ultramarathons can take a whole day, or even multiple days to finish, so he is showing an app to plan events."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-app"}],"type":"paragraph"},{"inlineContent":[{"text":"Here, the reminder at the bottom of the screen is letting know that it is time for a meal. We want to give it an animated highlight effect to make it extra visible.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To make this view animate, we can apply the "},{"code":".phaseAnimator","type":"codeVoice"},{"type":"text","text":" modifier."}],"type":"paragraph"},{"code":["OverdueReminderView()","        .phaseAnimator([false, true]) { content, phase in","            content","        } "],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Using the phase animator modifier, we need to provide a sequence of states that define the individual steps in a multipart animation. SwiftUI then animates between these states automatically.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this case, we’ll just be animating between two states: highlighted, and not highlighted, so we can simply use a boolean values."}],"type":"paragraph"},{"inlineContent":[{"text":"Next, we’ll apply an opacity modifier: This will make the view fully opaque when highlighted, and 50% transparent otherwise.","type":"text"}],"type":"paragraph"},{"code":["OverdueReminderView()","        .phaseAnimator([false, true]) { content, phase in","            content","                .opacity(phase ? 1.0 : 0.5)","        } "],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"identifier":"WWDC23-10157-phaseAnimator","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"We provided two phases to the phase animator modifier: false, and true.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"When the view first appears, the first phase is active, causing the view to be 50% transparent. SwiftUI then immediately begins an animated transition to the next phase, where the view is fully opaque.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-phaseAnimator2"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Then when that animation is finished, SwiftUI advances again."}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-phaseAnimator3","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"There are only have two phases, so this causes the animation to cycle between the two states. Of course, we can also define animations that include more than two phases, and any number of additional view modifiers."}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-phaseAnimator4","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Now, instead of changing the opacity, this changes the foreground style, using red when highlighted, and otherwise the primary foreground style."}],"type":"paragraph"},{"syntax":"swift","code":["OverdueReminderView()","        .phaseAnimator([false, true]) { content, phase in","            content","                .foregroundStyle(phase ? .red : .primary)","        } "],"type":"codeListing"},{"inlineContent":[{"text":"By default, SwiftUI uses a spring animation. And while springs are great for handling dynamic state changes, in this case we can change the animation by adding a trailing “animation” closure.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["OverdueReminderView()","        .phaseAnimator([false, true]) { content, phase in","            content","                .foregroundStyle(value ? .red : .primary)","        } animation: { phase in","            .easeInOut(duration: 1.0)","        }"],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-phaseAnimator6"}],"type":"paragraph"},{"inlineContent":[{"text":"The phase that is being animated to is passed in, in case we want to use a different animation for each phase.","type":"text"}],"type":"paragraph"},{"level":1,"anchor":"Animations-that-are-triggered-by-events","text":"Animations that are triggered by events.","type":"heading"},{"inlineContent":[{"text":"Animating the emoji show reactions left by others.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-reactions"}],"type":"paragraph"},{"inlineContent":[{"text":"Unlike in the previous example that simply alternated between two states, we want a more complex animation. An enum is a great way to define a list of steps for the animation.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","","enum Phase: CaseIterable {","    case initial   ","    case move  ","    case scale  ","}"],"type":"codeListing"},{"inlineContent":[{"text":"Three cases:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"for the initial appearance,"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"to move the view up,"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"and scale it up ."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"To simplify the view body, we will add computed properties to this enum that define the different effects that we will apply. for instance a computed vertical offset property. We switch over the enum to return the right offset for each case."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Likewise, there are two additional computed properties to determine the view’s scale and foreground style."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","","enum Phase: CaseIterable {","    case initial   ","    case move  ","    case scale  ","","    var verticalOffset: Double {","        switch self {","        case .initial: 0","        case .move, .scale: -64","        }","    }","","    var scale: Double {","        switch self {","        case .initial: 1.0","        case .move: 1.1","        case .scale: 1.8","        }","    }","    ","    var foregroundStyle: Color {","        switch self {","        case .initial: .white","        case .move, .scale: .red","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-reactionsPhases"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We add the phaseAnimator modifier, but this time, we give it a “trigger” value which observes the value that we specify for changes. And when a change occurs, it begins animating through the phases."},{"type":"text","text":" "},{"type":"text","text":"Using the computed properties that we defined on the phase type, we apply modifiers to the view."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .phaseAnimator","        Phase.allCases, ","        trigger: reactionCount","    ) { content, phase in","        content","            .scaleEffect(phase.scale)","            .offset(y: phase.verticalOffset)","            .foregroundStyle(phase.foregroundStyle)","    } ","}"],"type":"codeListing"},{"inlineContent":[{"identifier":"WWDC23-10157-reactionsPhases2","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Customizing the animation for each transition to get the effect that we want…"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .phaseAnimator","        Phase. allCases, ","        trigger: reactionCount","    ) { content, phase in","        content","            .scaleEffect(phase.scale)","            .offset(y: phase.verticalOffset)","            .foregroundStyle(phase.foregroundStyle)","    } animation: { phase in","        switch phase {","        case initial: .smooth","        case .move: .easeInOut(duration: 0.3)","        case .scale: .spring(","            duration: 0.3, bounce: 0.7)","        }","}"],"type":"codeListing"},{"inlineContent":[{"identifier":"WWDC23-10157-reactionsPhases3","type":"image"}],"type":"paragraph"},{"level":1,"anchor":"Keyframes","text":"Keyframes","type":"heading"},{"inlineContent":[{"text":"Keyframes provide complex, coordinated animations with complete control over timing and movement.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Keyframes are different from phases. Phases define discrete states that are provided to your view one at a time. And SwiftUI animates between those states, using the same animation types that we already know. When a state transition occurs, all of the properties are animated at the same time.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-keyframes","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"And then, when that animation is finished, SwiftUI animates to the next state."}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-keyframes2","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"And this continues across all of the phases of the animation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Keyframes allow us to animate each property independently, defining values at specific times within an animation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The dots here indicate keyframes: angles to use at each point during the animation."}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-dots","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"When the animation plays back, SwiftUI interpolates values in between these keyframes, which we can then use to apply modifiers to the view."},{"type":"text","text":"\n"},{"type":"text","text":"And keyframes allow to independently animate multiple effects at the same time by defining separate tracks, each with their own unique timing."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-keyframes3"}],"type":"paragraph"},{"inlineContent":[{"text":"In this example, keyframes are driving several other tracks, including vertical stretch, scale, and translation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Getting back to the code:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","","struct AnimationValues {","    var scale = 1.0","    var verticalStretch = 1.0","    var verticalTranslation = 0.0","    var angle = Angle.zero","}"],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-keyframes4"}],"type":"paragraph"},{"inlineContent":[{"text":"Keyframes can animate any value conforming to the “Animatable” protocol.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Unlike phases, keyframes generate interpolated values of the type that we specify.","type":"text"},{"text":" ","type":"text"},{"text":"While an animation is in progress, SwiftUI will provide us with a value of this type on every frame so that we can update the view.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Next, we add the keyframeAnimator modifier.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","       \/\/ ...","    }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This modifier is similar to the phase animator that we used earlier, but accepts keyframes."},{"type":"text","text":"\n"},{"type":"text","text":"We provide an instance of the struct to use as the initial value. The keyframes that we define will apply animations onto this value. Next, we’ll apply modifiers to the view for each of the properties on the struct."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","            .rotationEffect(value.angle)","            .scaleEffect(value.scale)","            .scaleEffect(y: value.verticalStretch)","            .offset(y: value.verticalTranslation)","    } keyframes: {_ in","       \/\/ ...","    }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"And finally, defining keyframes:"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { ... } keyframes: {_ in","        KeyframeTrack(\\.scale) {","            \/\/...","    }"],"type":"codeListing"},{"inlineContent":[{"text":"Keyframes are organized into tracks. Each track controls a different property of the type that we are animating, which is specified by the key path that we provide when creating the track.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here, We first add a linear keyframe, repeating the initial scale value and holding it for 0.36 seconds.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","        KeyframeTrack(\\.scale) {","            Linearkeyframe(1.0, duration: 0.36)","    }"],"type":"codeListing"},{"inlineContent":[{"identifier":"WWDC23-10157-keyframes5","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Previews in Xcode can be a great way to fine-tune animations…"}],"type":"paragraph"},{"inlineContent":[{"text":"Adding a “SpringKeyframe.”. This uses a spring function to pull the value toward the target.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","        KeyframeTrack(\\.scale) {","            Linearkeyframe(1.0, duration: 0.36)","            SpringKeyframe(1.5, duration: 0.8,","                spring: bouncy)","    }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Then adding another spring keyframe that animates the scale back to 1.0."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","        KeyframeTrack(\\.scale) {","            Linearkeyframe(1.0, duration: 0.36)","            SpringKeyframe(1.5, duration: 0.8,","                spring: bouncy)","            SpringKeyframe (1.0, spring: .bouncy)","    }"],"type":"codeListing"},{"inlineContent":[{"identifier":"WWDC23-10157-keyframes6","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"There are actually four different types of keyframes."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-moreKeyframes"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"LinearKeyframe interpolates linearly in vector space from the previous keyframe."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"SpringKeyframe, as its name suggests, uses a spring function to interpolate to the target value from the previous keyframe."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"CubicKeyframe uses a cubic Bézier curve to interpolate between keyframes. Combiniung multiple cubic keyframes in sequence, the resulting curve is equivalent to a Catmull-Rom spline.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"MoveKeyframe immediately jumps to a value without interpolation."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Each kind of keyframe supports customization and we can mix and match different kinds of keyframes within an animation."},{"type":"text","text":"\n"},{"type":"text","text":"SwiftUI maintains velocity between keyframes."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Using linear and spring keyframes to animate the vertical translation."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","        KeyframeTrack(\\.scale) { \/\/... }","        ","        KeyframeTrack(\\.verticalTranslation) {","            LinearKeyframe(0.0, duration: 0.1)","            SpringKeyframe(20.0, duration: 0.15,","                spring: .bouncy)","            SpringKeyframe(-60.0, duration: 1.0,","                spring: .bouncy)","            SpringKeyframe(0.0, spring: .bouncy)","            }","    }"],"type":"codeListing"},{"inlineContent":[{"identifier":"WWDC23-10157-moreKeyframes2","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"Right before the view jumps up, it pulls back.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This starts with vertical stretch, with a cubic keyframe."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","        KeyframeTrack(\\.scale) { \/\/... }","        ","        KeyframeTrack(\\.verticalTranslation) { \/\/... }","        ","        KeyframeTrack(\\.verticalStretch) {","            CubicKeyframe(1.0, duration: 0.1)","            CubicKeyframe(0.6, duration: 0.15)","            CubicKeyframe(1.5, duration: 0.1)","            CubicKeyframe(1.05, duration: 0.15)","            CubicKeyframe(1.0, duration: 0.88)","            CubicKeyframe(0.8, duration: 0.1)","            CubicKeyframe(1.04, duration: 0.4)","            CubicKeyframe(1.0, duration: 0.22)","        } ","    }"],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-moreKeyframes3"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Finally, the rotation will be animated."}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(","        initialValue: AnimationValues(), ","        trigger: reactionCount","    ) { content, value in","        content","    } keyframes: {_ in","        KeyframeTrack(\\.scale) { \/\/... }","        ","        KeyframeTrack(\\.verticalTranslation) { \/\/... }","        ","        KeyframeTrack(\\.verticalStretch) { \/\/... }","            ","        KeyframeTrack(\\.angle) {","            CubicKeyframe(.zero, duration: 0.58)","            CubicKeyframe(.degrees(16), duration: 0.125)","            CubicKeyframe(.degrees(-16), duration: 0.125)","            CubicKeyframe(.degrees(16), duration: 0.125)","            CubicKeyframe(.zero, duration: 0.125)","            }","    }"],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-moreKeyframes4"}],"type":"paragraph"},{"inlineContent":[{"text":"And those curves? Those are a visualization of the animation","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-moreKeyframes5","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"Keyframes are like video clips that can be played. They give you a ton of control, but there’s a tradeoff. Keyframe animations can’t gracefully retarget the way that springs can, so it’s generally best to avoid changing keyframes mid-animation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-remember"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Updates happen on every frame, so we should avoid performing any expensive operations while applying a keyframe animation to the view."}],"type":"paragraph"},{"level":1,"anchor":"Tips-and-tricks","text":"Tips and tricks","type":"heading"},{"inlineContent":[{"type":"text","text":"The race map example, showing the route."},{"type":"text","text":"\n"},{"type":"text","text":"lets add an animation that automatically zooms in and follows the course. MapKit now allows to use keyframes to move the camera!"}],"type":"paragraph"},{"syntax":"swift","code":["struct RaceMap: View {","    let route: Route","    ","    var body: some View {","        Map(initialPosition: .rect(route.rect)) {","            MapPolyline (coordinates: route.coordinates)","                .stroke(.orange, lineWidth: 4.0)","            Marker(\"Start\", coordinate: route.start)","                .tint(.green)","            Marker (\"End\", coordinate: route.end)","                .tint (.red)","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"Here, we use a “Map” view to show the course.","type":"text"},{"text":"\n","type":"text"},{"text":"The view already has a route, which is a model that contains all of the coordinates along one leg of the race.","type":"text"},{"text":"\n","type":"text"},{"text":"To build the tour, we’ll add a state property and a button to change it.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct RaceMap: View {","    let route: Route","    ","    @State private var trigger = false","    ","    var body: some View {","        Map(initialPosition: .rect(route.rect)) {","            MapPolyline (coordinates: route.coordinates)","                .stroke(.orange, lineWidth: 4.0)","            Marker(\"Start\", coordinate: route.start)","                .tint(.green)","            Marker (\"End\", coordinate: route.end)","                .tint (.red)","        }","        .toolbar {","            Button(\"Tour\") { trigger.toggle() }","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"image","identifier":"WWDC23-10157-race"}],"type":"paragraph"},{"inlineContent":[{"text":"Lets use the new “mapCameraKeyframeAnimator” modifier, giving the trigger value to it, then adding keyframes.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct RaceMap: View {","    let route: Route","    ","    @State private var trigger = false","    ","    var body: some View {","        Map(initialPosition: .rect(route.rect)) {...} ","            .toolbar {...}","            .mapCameraKeyframeAnimator(trigger: trigger) {","                KeyframeTrack(\\.centerCoordinate) {...}","                KeyframeTrack(\\.heading) {...}","                KeyframeTrack(\\.distance) {...}","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"Every time the trigger value changes, maps will use these keyframes to animate.","type":"text"},{"text":"\n","type":"text"},{"text":"The final value of the keyframes determines the camera value that is used at the end of the animation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC23-10157-mapAnimation","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"If the user performs a gesture while animating, the animation will be removed and the user will have full control over the camera.","type":"text"},{"text":"\n","type":"text"},{"text":"We can independently animate the center coordinate, heading, and distance.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"There is more. We’ve seen the “keyframeAnimator” modifier. Outside of the modifier, we can use the “KeyframeTimeline” type to capture a set of keyframes and tracks. We initialize this type with an initial value, and the keyframe tracks that define the animation, just like with the view modifier.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Keyframes","let myKeyframes = KeyframeTimeline(initialValue: CGPoint.zero) {","    KeyframeTrack(\\.x) {...}","    KeyframeTrack(\\.y) {...}","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"KeyframeTimeline provides API that gives the duration, which is equal to the duration of the longest track."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Duration in seconds","let duration: TimeInterval = myKeyframes.duration"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"And we can calculate values for any time within the range of the animation."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Value for time","let value = myKeyframes.value (time: 1.2)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This makes it easy to visualize keyframes with Swift Charts, This also means that we can use keyframe-defined curves however you want, or to creatively combine keyframes with other APIs, for example, with a geometry proxy to scrub keyframe-driven effects using scroll position, or with a “TimelineView” to update based on time."}],"type":"paragraph"},{"level":1,"anchor":"Conclusion","text":"Conclusion","type":"heading"},{"inlineContent":[{"text":"Use keyframes for more complex animations where we need complete control.","type":"text"}],"type":"paragraph"},{"level":1,"anchor":"Check-out-also","text":"Check out also","type":"heading"},{"inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc23\/10148"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc23\/10156"}],"type":"paragraph"},{"level":1,"anchor":"Some-of-the-code-examples-included-in-the-talk","text":"Some of the code examples included in the talk","type":"heading"},{"inlineContent":[{"text":"Boolean Phases","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["OverdueReminderView()","        .phaseAnimator([false, true]) { content, value in","            content","                .foregroundStyle(value ? .red : .primary)","        } animation: { _ in","            .easeInOut(duration: 1.0)","        }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Custom Phases"}],"type":"paragraph"},{"syntax":"swift","code":["ReactionView()","    .phaseAnimator(","        Phase.allCases, ","        trigger: reactionCount","    ) { content, phase in","        content","            .scaleEffect(phase.scale)","            .offset(y: phase.verticalOffset)","    } animation: { phase in","        switch phase {","        case .initial: .smooth","        case .move: .easeInOut(duration: 0.3)","        case .scale: .spring(","            duration: 0.3, bounce: 0.7)","        } ","    }","    ","enum Phase: CaseIterable {","    case initial","    case move","    case scale","","    var verticalOffset: Double {","        switch self {","        case .initial: 0","        case .move, .scale: -64","        }","    }","","    var scale: Double {","        switch self {","        case .initial: 1.0","        case .move: 1.1","        case .scale: 1.8","        }","    }","}"],"type":"codeListing"},{"syntax":"swift","code":["ReactionView()","    .keyframeAnimator(initialValue: AnimationValues()) { content, value in","        content","            .foregroundStyle(.red)","            .rotationEffect(value.angle)","            .scaleEffect(value.scale)","            .scaleEffect(y: value.verticalStretch)","            .offset(y: value.verticalTranslation)","        } keyframes: { _ in","            KeyframeTrack(\\.angle) {","                CubicKeyframe(.zero, duration: 0.58)","                CubicKeyframe(.degrees(16), duration: 0.125)","                CubicKeyframe(.degrees(-16), duration: 0.125)","                CubicKeyframe(.degrees(16), duration: 0.125)","                CubicKeyframe(.zero, duration: 0.125)","            }","","            KeyframeTrack(\\.verticalStretch) {","                CubicKeyframe(1.0, duration: 0.1)","                CubicKeyframe(0.6, duration: 0.15)","                CubicKeyframe(1.5, duration: 0.1)","                CubicKeyframe(1.05, duration: 0.15)","                CubicKeyframe(1.0, duration: 0.88)","                CubicKeyframe(0.8, duration: 0.1)","                CubicKeyframe(1.04, duration: 0.4)","                CubicKeyframe(1.0, duration: 0.22)","            }","            ","            KeyframeTrack(\\.scale) {","                LinearKeyframe(1.0, duration: 0.36)","                SpringKeyframe(1.5, duration: 0.8, spring: .bouncy)","                SpringKeyframe(1.0, spring: .bouncy)","            }","            KeyframeTrack(\\.verticalTranslation) {","                LinearKeyframe(0.0, duration: 0.1)","                SpringKeyframe(20.0, duration: 0.15, spring: .bouncy)","                SpringKeyframe(-60.0, duration: 1.0, spring: .bouncy)","                SpringKeyframe(0.0, spring: .bouncy)","            }","        }","","struct AnimationValues {","    var scale = 1.0","    var verticalStretch = 1.0","    var verticalTranslation = 0.0","    var angle = Angle.zero","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"map keyframes"}],"type":"paragraph"},{"syntax":"swift","code":["struct RaceMap: View {","    let route: Route","","    @State private var trigger = false","","    var body: some View {","        Map(initialPosition: .rect(route.rect)) {","            MapPolyline(coordinates: route.coordinates)","                .stroke(.orange, lineWidth: 4.0)","            Marker(\"Start\", coordinate: route.start)","                .tint(.green)","            Marker(\"End\", coordinate: route.end)","                .tint(.red)","        }","        .toolbar {","            Button(\"Tour\") { trigger.toggle() }","        }","        .mapCameraKeyframeAnimation(trigger: playTrigger) { initialCamera in","            KeyframeTrack(\\MapCamera.centerCoordinate) {","                let points = route.points","                for point in points {","                    CubicKeyframe(point.coordinate, duration: 16.0 \/ Double(points.count))","                }","                CubicKeyframe(initialCamera.centerCoordinate, duration: 4.0)","            }","            KeyframeTrack(\\.heading) {","                CubicKeyframe(heading(from: route.start.coordinate, to: route.end.coordinate), duration: 6.0)","                CubicKeyframe(heading(from: route.end.coordinate, to: route.end.coordinate), duration: 8.0)","                CubicKeyframe(initialCamera.heading, duration: 6.0)","            }","            KeyframeTrack(\\.distance) {","                CubicKeyframe(24000, duration: 4)","                CubicKeyframe(18000, duration: 12)","                CubicKeyframe(initialCamera.distance, duration: 4)","            }","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"keyframe timeline"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Keyframes","let myKeyframes = KeyframeTimeline(initialValue: CGPoint.zero) {","    KeyframeTrack(\\.x) {...}","    KeyframeTrack(\\.y) {...}","}","","\/\/ Duration in seconds","let duration: TimeInterval = myKeyframes.duration","","\/\/ Value for time","let value = myKeyframes.value(time: 1.2)"],"type":"codeListing"},{"level":2,"anchor":"Written-By","text":"Written By","type":"heading"},{"columns":[{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"multitudes"}]}],"size":1},{"content":[{"level":3,"text":"laurent b","anchor":"laurent-b","type":"heading"},{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/multitudes","overridingTitle":"Contributed Notes","type":"reference","overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}]},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/multitudes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/x.com\/wrmultitudes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/laurentbrusa.hashnode.dev\/","type":"reference"}],"type":"paragraph"}],"size":4}],"numberOfColumns":5,"type":"row"},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","isActive":true}],"type":"paragraph"},{"level":2,"anchor":"Related-Sessions","text":"Related Sessions","type":"heading"},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10148-Whats-new-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10156-Explore-SwiftUI-animation"],"style":"list","type":"links"},{"inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}],"type":"small"}]}],"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc23-10157-wind-your-way-through-advanced-animations-in-swiftui"]}],"sections":[],"metadata":{"role":"sampleCode","modules":[{"name":"WWDC Notes"}],"title":"Wind your way through advanced animations in SwiftUI","roleHeading":"WWDC23"},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10157-Wind-your-way-through-advanced-animations-in-SwiftUI","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Discover how you can take animation to the next level with the latest updates to SwiftUI. Join us as we wind our way through animation and build out multiple steps, use keyframes to add coordinated multi-track animated effects, and combine APIs in unique ways to make your app spring to life."}],"sampleCodeDownload":{"action":{"identifier":"https:\/\/developer.apple.com\/wwdc23\/10157","type":"reference","isActive":true,"overridingTitle":"Watch Video (18 min)"},"kind":"sampleDownload"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"references":{"WWDC23-10157-race":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-race.jpg"}],"identifier":"WWDC23-10157-race","alt":"race"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10156-Explore-SwiftUI-animation":{"url":"\/documentation\/wwdcnotes\/wwdc23-10156-explore-swiftui-animation","type":"topic","abstract":[{"type":"text","text":"Explore SwiftUI’s powerful animation capabilities and find out how these features work together to produce impressive visual effects. Learn how SwiftUI refreshes the rendering of a view, determines what to animate, interpolates values over time, and propagates context for the current transaction."}],"kind":"article","title":"Explore SwiftUI animation","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10156-Explore-SwiftUI-animation","role":"sampleCode"},"WWDC23-10157-mapAnimation":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-mapAnimation.jpg"}],"identifier":"WWDC23-10157-mapAnimation","alt":"mapAnimation"},"https://developer.apple.com/wwdc23/10148":{"titleInlineContent":[{"text":"What’s new in SwiftUI","type":"text"}],"url":"https:\/\/developer.apple.com\/wwdc23\/10148","type":"link","identifier":"https:\/\/developer.apple.com\/wwdc23\/10148","title":"What’s new in SwiftUI"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!"},"WWDCNotes.png":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"identifier":"WWDCNotes.png","alt":null},"https://github.com/multitudes":{"titleInlineContent":[{"text":"GitHub","type":"text"}],"url":"https:\/\/github.com\/multitudes","type":"link","identifier":"https:\/\/github.com\/multitudes","title":"GitHub"},"https://x.com/wrmultitudes":{"titleInlineContent":[{"text":"X\/Twitter","type":"text"}],"url":"https:\/\/x.com\/wrmultitudes","type":"link","identifier":"https:\/\/x.com\/wrmultitudes","title":"X\/Twitter"},"WWDC23-10157-app":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-app.jpg"}],"identifier":"WWDC23-10157-app","alt":"the app"},"https://developer.apple.com/wwdc23/10156":{"titleInlineContent":[{"text":"Explore SwiftUI animations","type":"text"}],"url":"https:\/\/developer.apple.com\/wwdc23\/10156","type":"link","identifier":"https:\/\/developer.apple.com\/wwdc23\/10156","title":"Explore SwiftUI animations"},"WWDC23-10157-keyframes6":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-keyframes6.jpg"}],"identifier":"WWDC23-10157-keyframes6","alt":"keyframes"},"WWDC23-10157-moreKeyframes2":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-moreKeyframes2.jpg"}],"identifier":"WWDC23-10157-moreKeyframes2","alt":"keyframes"},"WWDC23-10157-moreKeyframes":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-moreKeyframes.jpg"}],"identifier":"WWDC23-10157-moreKeyframes","alt":"keyframes"},"WWDC23-10157-phaseAnimator":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-phaseAnimator.jpg"}],"identifier":"WWDC23-10157-phaseAnimator","alt":"the “.phaseAnimator” modifier"},"WWDC23-10157-first":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-first.jpg"}],"identifier":"WWDC23-10157-first","alt":"scale animation"},"WWDC23-10157-dots":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-dots.jpg"}],"identifier":"WWDC23-10157-dots","alt":"dots diagram"},"WWDC23-10157-reactionsPhases2":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-reactionsPhases2.jpg"}],"identifier":"WWDC23-10157-reactionsPhases2","alt":"emoji show reactions left by others"},"WWDC23-Icon.png":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-Icon.png"}],"identifier":"WWDC23-Icon.png","alt":null},"WWDC23-10157-phaseAnimator4":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-phaseAnimator4.jpg"}],"identifier":"WWDC23-10157-phaseAnimator4","alt":"the “.phaseAnimator” modifier"},"https://laurentbrusa.hashnode.dev/":{"titleInlineContent":[{"text":"Blog","type":"text"}],"url":"https:\/\/laurentbrusa.hashnode.dev\/","type":"link","identifier":"https:\/\/laurentbrusa.hashnode.dev\/","title":"Blog"},"WWDC23-10157-keyframes4":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-keyframes4.jpg"}],"identifier":"WWDC23-10157-keyframes4","alt":"keyframes"},"WWDC23-10157-remember":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-remember.jpg"}],"identifier":"WWDC23-10157-remember","alt":"remember"},"doc://WWDCNotes/documentation/WWDCNotes":{"title":"WWDC Notes","url":"\/documentation\/wwdcnotes","type":"topic","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"role":"collection","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","kind":"symbol"},"WWDC23-10157-phaseAnimator3":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-phaseAnimator3.jpg"}],"identifier":"WWDC23-10157-phaseAnimator3","alt":"the “.phaseAnimator” modifier"},"WWDC23-10157-keyframes2":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-keyframes2.jpg"}],"identifier":"WWDC23-10157-keyframes2","alt":"keyframes"},"WWDC23-10157-moreKeyframes3":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-moreKeyframes3.jpg"}],"identifier":"WWDC23-10157-moreKeyframes3","alt":"keyframes"},"WWDC23-10157-phaseAnimator6":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-phaseAnimator6.jpg"}],"identifier":"WWDC23-10157-phaseAnimator6","alt":"the “.phaseAnimator” modifier"},"WWDC23-10157-moreKeyframes5":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-moreKeyframes5.jpg"}],"identifier":"WWDC23-10157-moreKeyframes5","alt":"keyframes"},"WWDC23-10157-reactionsPhases3":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-reactionsPhases3.jpg"}],"identifier":"WWDC23-10157-reactionsPhases3","alt":"emoji show reactions left by others"},"doc://WWDCNotes/documentation/WWDCNotes/multitudes":{"images":[{"identifier":"multitudes.jpeg","type":"card"},{"identifier":"multitudes.jpeg","type":"icon"}],"title":"laurent b (33 notes)","url":"\/documentation\/wwdcnotes\/multitudes","kind":"article","role":"sampleCode","type":"topic","abstract":[{"type":"text","text":"student at 42Berlin 🐬 | 🍎 Swift(UI) app dev  | speciality coffee ☕️ & cycling 🚴🏻‍♂️"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/multitudes"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23","images":[{"identifier":"WWDC23-Icon.png","type":"icon"},{"identifier":"WWDC23.jpeg","type":"card"}],"url":"\/documentation\/wwdcnotes\/wwdc23","abstract":[{"type":"text","text":"Xcode 15, Swift 5.9, iOS 17, macOS 14 (Sonoma), tvOS 17, visionOS 1, watchOS 10."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"SwiftData"},{"type":"text","text":", "},{"type":"codeVoice","code":"Observation"},{"text":", ","type":"text"},{"type":"codeVoice","code":"StoreKit"},{"type":"text","text":" views, and more."}],"kind":"article","type":"topic","title":"WWDC23","role":"collectionGroup"},"WWDC23-10157-moreKeyframes4":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-moreKeyframes4.jpg"}],"identifier":"WWDC23-10157-moreKeyframes4","alt":"keyframes"},"multitudes.jpeg":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/multitudes.jpeg"}],"identifier":"multitudes.jpeg","alt":null},"WWDC23.jpeg":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23.jpeg"}],"identifier":"WWDC23.jpeg","alt":null},"WWDC23-10157-phaseAnimator2":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-phaseAnimator2.jpg"}],"identifier":"WWDC23-10157-phaseAnimator2","alt":"the “.phaseAnimator” modifier"},"WWDC23-10157-keyframes":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-keyframes.jpg"}],"identifier":"WWDC23-10157-keyframes","alt":"keyframes"},"https://developer.apple.com/wwdc23/10157":{"url":"https:\/\/developer.apple.com\/wwdc23\/10157","type":"download","identifier":"https:\/\/developer.apple.com\/wwdc23\/10157","checksum":null},"WWDC23-10157-reactionsPhases":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-reactionsPhases.jpg"}],"identifier":"WWDC23-10157-reactionsPhases","alt":"emoji show reactions left by others"},"WWDC23-10157-keyframes3":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-keyframes3.jpg"}],"identifier":"WWDC23-10157-keyframes3","alt":"keyframes"},"WWDC23-10157-keyframes5":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-keyframes5.jpg"}],"identifier":"WWDC23-10157-keyframes5","alt":"keyframes"},"multitudes":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/multitudes.jpeg"}],"identifier":"multitudes","alt":"Profile image of laurent b"},"WWDC23-10157-reactions":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10157-reactions.jpg"}],"identifier":"WWDC23-10157-reactions","alt":"emoji show reactions left by others"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10148-Whats-new-in-SwiftUI":{"role":"sampleCode","type":"topic","title":"What’s new in SwiftUI","abstract":[{"type":"text","text":"Learn how you can use SwiftUI to build great apps for all Apple platforms. Explore the latest updates to SwiftUI and discover new scene types for visionOS. Simplify your data models with the latest data flow options and learn about the Inspector view. We’ll also take you through enhanced animation APIs, powerful ScrollView improvements, and a host of refinements to help you make tidier tables, improve focus and keyboard input, and so much more."}],"url":"\/documentation\/wwdcnotes\/wwdc23-10148-whats-new-in-swiftui","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10148-Whats-new-in-SwiftUI","kind":"article"}}}