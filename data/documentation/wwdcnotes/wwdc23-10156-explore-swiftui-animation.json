{"primaryContentSections":[{"kind":"content","content":[{"type":"heading","anchor":"overview","level":2,"text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Speaker: Kyle Macomber, SwiftUI Engineer"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is an overview of SwiftUI’s animation capabilities."}]},{"type":"heading","anchor":"Anatomy-of-an-update","level":2,"text":"Anatomy of an update"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI tracks a view’s dependencies, like state variables. When an event happens, an update transaction is opened. If any dependencies change, the view is invalidated, and at the end of the transaction, the framework calls "},{"type":"codeVoice","code":"body"},{"type":"text","text":" to refresh the rendering."}]},{"type":"paragraph","inlineContent":[{"text":"SwiftUI maintains a dependency graph that manages the lifetimes of views and their data, storing each piece of the UI in attributes. When state changes, the value of each attribute becomes stale, and the new view value is unwrapped to refresh the view.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10156-attribute-graph","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Then the view’s body value is discarded, and drawing commands are emitted to update the rendering.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If the state change is wrapped in ","type":"text"},{"type":"codeVoice","code":"withAnimation"},{"text":", any attributes that are ","type":"text"},{"type":"strong","inlineContent":[{"text":"animatable","type":"text"}]},{"text":" will check if an animation is set for the transaction, and if so, it makes a copy and uses the animation to interpolate between old and new value over time. Built-in animatable attributes like scaleEffect are very efficient.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10156-animation-timeline","type":"image"}]},{"type":"heading","anchor":"Animatable","level":2,"text":"Animatable"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Animatable attributes (like scaleEffect) determine the data being animated."}]},{"type":"paragraph","inlineContent":[{"text":"SwiftUI builds an animatable attribute for any view conforming to the Animatable protocol — which requires that the view define a readwrite vector of the data it wants to animate. The data must conform to VectorArithmetic.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"VectorArithmetic deals in vectors, a fixed-length list of numbers that support vector addition and scalar multiplication. They allow abstracting over the length of that list. (CGFloat and Double are one-dimensional vectors; CGPoint and CGSize are two-dimensional; and CGRect is a four-dimensional vector). Using vectors, SwiftUI can animate with a single generic implementation."}]},{"type":"paragraph","inlineContent":[{"code":"scaleEffect","type":"codeVoice"},{"text":" might seem really simple, but in reality is a four-dimensional vector. It fuses together width, height, and anchor point, using AnimatablePair. AnimatablePair is what you’ll want to use if you need to conform a view to Animatable.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most of the time, it’s best to use SwiftUI’s built-in animatable visual effects, since it’s far more expensive to create our own. When animating a custom layout or drawing code, this might be the only way to achieve the desired effect."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example shown is for animating three images moving along a custom RadialLayout: with automatic animation, the images move to their end positions in a straight line, while with custom animation, they go around the perimeter. The main difference between the two is that the default version animates each of the child subviews independently, moving each one’s position, while the custom version moves the body itself instead of the position: body is called each frame with a new offset angle."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10156-animation-timeline-position-body"}]},{"anchor":"Animation","text":"Animation","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Animation determines how data changes over time (or, the generic algorithms that interpolate animatable data over time)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Choose an animation by passing it to "},{"type":"codeVoice","code":"withAnimation"},{"type":"text","text":":"}]},{"code":["struct Avatar: View {","\tvar pet: Pet","\t@State private var selected: Bool = false","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.scaleEffect(selected ? 1.5 : 1)","\t\t\t.onTapGesture {","\t\t\t\twithAnimation(.bouncy) { \/\/ HERE","\t\t\t\t\tselected.toggle()","\t\t\t\t}","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Timing-curve","text":"Timing curve","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most commonly seen animations. All timing curve animations take a curve and a duration. Curves are defined with bezier control points."}]},{"type":"paragraph","inlineContent":[{"text":"SwiftUI comes with:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"linear"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"easeIn"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"easeOut","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"easeInOut","type":"codeVoice"},{"text":" ","type":"text"},{"text":"They can all take in an optional custom ","type":"text"},{"code":"duration","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Spring-recommended","text":"Spring (recommended)","type":"heading","level":3},{"inlineContent":[{"text":"Springs determine the value at a given point in time by running a spring simulation. They are traditionally specified using mass, stiffness, and damping, but in SwiftUI, ","type":"text"},{"code":"duration","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"bounce","type":"codeVoice"},{"text":" are preferred.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"SwiftUI comes with:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"code":"smooth","type":"codeVoice"},{"text":" (no bounce, default in ","type":"text"},{"code":"withAnimation","type":"codeVoice"},{"text":" since iOS 17)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"snappy","type":"codeVoice"},{"type":"text","text":" (small bounce)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"bouncy","type":"codeVoice"},{"text":" (medium bounce)","type":"text"},{"text":" ","type":"text"},{"text":"They can all take in optional ","type":"text"},{"code":"duration","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"extraBounce","type":"codeVoice"},{"text":".","type":"text"}]}]}],"type":"unorderedList"},{"type":"heading","text":"Higher order","level":3,"anchor":"Higher-order"},{"inlineContent":[{"text":"Modify a base animation: slow down \/ speed up, add a delay, repeat, playing forwards \/ in reverse.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"NEW: Custom animations","level":3,"anchor":"NEW-Custom-animations"},{"inlineContent":[{"text":"Gives developers access to the same entry points used to implement the animations included in SwiftUI.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The protocol has three requirements: ","type":"text"},{"code":"animate","type":"codeVoice"},{"text":", ","type":"text"},{"code":"shouldMerge","type":"codeVoice"},{"text":" (optional), ","type":"text"},{"code":"velocity","type":"codeVoice"},{"text":" (optional).","type":"text"}],"type":"paragraph"},{"code":["public protocol CustomAnimation: Hashable {","    func animate<V: VectorArithmetic>(","        value: V, \/\/ vector to animate towards","                  \/\/ comes from view's animatable data","        time: TimeInterval, \/\/ time elapsed since animation began","        context: inout AnimationContext<V> \/\/ additional animation state","    ) -> V? \/\/ current value of the animation, or nil if finished","    ","    func shouldMerge<V: VectorArithmetic>(","        previous: Animation,","        value: V,","        time: TimeInterval,","        context: inout AnimationContext<V>","    ) -> Bool","    ","    func velocity<V: VectorArithmetic>(","        value: V, time: TimeInterval, context: AnimationContext<V>","    ) -> V?","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"With vector addition and scalar multiplication, animations don’t actually happen from start value to end value, but over the delta between the two. For instance, if an animation starts and 1 and ends at 1.5, the actual animation is 0.5. This makes the animate method more convenient.\\"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"shouldMerge"},{"text":" comes in when the animation is interrupted: for instance, if the user taps again while a toggle animation is running. In timing curve animations, it returns false, and the vectors are added together. In spring animations, it returns true, so it preserves velocity and retargets to a new value, which feels more natural.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"velocity"},{"type":"text","text":": implementing it preserves velocity when a running animation is merged with a new one."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","text":"Transaction","level":2,"anchor":"Transaction"},{"inlineContent":[{"text":"In this talk, transaction has meant “the set of work that’s performed for a given update to the UI”. It also refers to a related data-flow construct and family of APIs. It’s a dictionary SwiftUI uses to implicitly propagate all the context for the current update, most notably the animation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s look through the earlier example of how an animatable attribute reads the value, in more detail."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"withAnimation sets the animation in the root transaction dictionary."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"body updates the attribute values."}]}]},{"content":[{"inlineContent":[{"text":"The transaction dictionary is propagated","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"When it reaches an animatable attribute, the attribute checks for an animation: if it finds one, it makes a copy for presentation.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"The transaction is discarded at the end up the update.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"To change state programmatically, and make that change still be animated, add the transaction modifier:"}],"type":"paragraph"},{"code":["struct Avatar: View {","\tvar pet: Pet","\t\/\/ @State changed to @Binding to change it externally","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.scaleEffect(selected ? 1.5 : 1.0)","\t\t\t.transition { \/\/ this attribute will override the animation.","\t\t\t\t$0.animation = .bouncy","\t\t\t}","\t\t\t.onTapGesture {","\t\t\t\twithAnimation(.bouncy) {","\t\t\t\t\tselected.toggle()","\t\t\t\t}","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[!warning] This can lead to accidental animation."}]}],"type":"aside","style":"note"},{"inlineContent":[{"text":"To fix that, SwiftUI provides the ","type":"text"},{"code":"animation","type":"codeVoice"},{"text":" view modifier. In the example, the animation will only run if ","type":"text"},{"code":"selected","type":"codeVoice"},{"text":" has changed. ","type":"text"},{"code":"withAnimation","type":"codeVoice"},{"text":" is no longer needed, it can be removed.","type":"text"}],"type":"paragraph"},{"code":["struct Avatar: View {","\tvar pet: Pet","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.scaleEffect(selected ? 1.5 : 1.0)","\t\t\t.animation(.bouncy, value: selected) \/\/ HERE","\t\t\t.onTapGesture {","\t\t\t\tselected.toggle()","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"animation","type":"codeVoice"},{"text":" modifier is also useful to apply different animations to different parts of a view. In the example, a shadow is added, which has a different animation. A different animation modifier, with a value of ","type":"text"},{"code":"smooth","type":"codeVoice"},{"text":", is added immediately after the shadow.","type":"text"}],"type":"paragraph"},{"code":["struct Avatar: View {","\tvar pet: Pet","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.shadow(radius: selected ? 12 : 8)","\t\t\t.animation(.smooth, value: selected) \/\/ HERE","\t\t\t.scaleEffect(selected ? 1.5 : 1.0)","\t\t\t.animation(.bouncy, value: selected)","\t\t\t.onTapGesture {","\t\t\t\tselected.toggle()","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Animation modifiers are only active when their value changes, reducing the odds of accidental animation. But if another change happens in the same transaction, it would inherit the same animation. Depending on the component structure, this can be a problem: if the component may contain arbitrary child content, accidental animations may happen. In this case, we can use a new version of the animation modifier.","type":"text"}],"type":"paragraph"},{"code":["struct Avatar: View {","\tvar pet: Pet","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.animation(.smooth) {","\t\t\t\t$0.shadow(radius: selected ? 12 : 8)","\t\t\t}","\t\t\t.animation(.bouncy) {","\t\t\t\t$0.scaleEffect(selected ? 1.5 : 1.0)","\t\t\t}","\t\t\t.onTapGesture {","\t\t\t\tselected.toggle()","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"When the transaction propagates through the attributes and finds an animation view modifier, a copy is made that populated with the specified animation. Then, the copy is discarded, and the transaction continues down the attributes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"New: Custom transaction keys can be defined, to leverage the transaction dictionary and implicitly propagate custom update-specific data. It’s similar to declaring a custom environment key, and the only requirement is a "},{"type":"codeVoice","code":"defaultValue"},{"type":"text","text":". Then, declare a computed property as an extension on Transaction, that reads and writes from the transaction dictionary using the custom key."}],"type":"paragraph"},{"inlineContent":[{"text":"In this example, a boolean key is defined to track whether the image was tapped or not, which will determine which animation is used.","type":"text"}],"type":"paragraph"},{"code":["private struct AvatarTappedKey: TransactionKey {","\tstatic let defaultValue: false","}","","extension Transaction {","\tvar avatarTapped: Bool {","\t\tget { self[AvatarTappedKey.self] }","\t\tset { self[AvatarTappedKey.self] = newValue }","\t}","}","","struct Avatar: View {","\tvar pet: Pet","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.scaleEffect(selected ? 1.5 : 1.0)","\t\t\t.transaction {","\t\t\t\t\/\/ If the image was tapped, the animation will be more","\t\t\t\t\/\/ lively than if it was changed programmatically.","\t\t\t\t$0.animation = $0.avatarTapped","\t\t\t\t\t? .bouncy : .smooth","\t\t\t}","\t\t\t.onTapGesture {","\t\t\t\twithTransaction(\\.avatarTapped, true) { \/\/ HERE","\t\t\t\t\tselected.toggle()","\t\t\t\t}","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"codeVoice","code":"withAnimation"},{"type":"text","text":" is a wrapper around "},{"type":"codeVoice","code":"withTransaction"},{"type":"text","text":": The arguments passed to "},{"type":"codeVoice","code":"withTransaction"},{"type":"text","text":" are a key path to a computed property on the Transaction and the value to set."}],"type":"paragraph"},{"inlineContent":[{"text":"This can again lead to accidental animations, which is why the transaction modifier has two new variants: One to scope using a value…","type":"text"}],"type":"paragraph"},{"code":["struct Avatar: View {","\tvar pet: Pet","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tImage(pet.type)","\t\t\t.scaleEffect(selected ? 1.5 : 1.0)","\t\t\t.transaction(value: selected) { \/\/ HERE","\t\t\t\t$0.animation = $0.avatarTapped","\t\t\t\t\t? .bouncy : .smooth","\t\t\t}","\t\t\t.onTapGesture {","\t\t\t\twithTransaction(\\.avatarTapped, true) {","\t\t\t\t\tselected.toggle()","\t\t\t\t}","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"And another to scope to a sub-hierarchy defined in a body closure:","type":"text"}],"type":"paragraph"},{"code":["struct Avatar: View {","\tvar pet: Pet","\t@Binding var selected: Bool","\t","\tvar body: some View {","\t\tcontent","\t\t\t.transaction {","\t\t\t\t$0.animation = $0.avatarTapped","\t\t\t\t\t? .bouncy : .smooth","\t\t\t} body: {","\t\t\t\t$0.scaleEffect(selected: 1.5 : 1.0)","\t\t\t}","\t\t\t.onTapGesture {","\t\t\t\twithTransaction(\\.avatarTapped, true) { \/\/ HERE","\t\t\t\t\tselected.toggle()","\t\t\t\t}","\t\t\t}","\t}","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Recommended:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"WWDC23 Animate with Springs"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"WWDC23 Wind your way through advanced animations in SwiftUI","type":"text"}]}]}],"type":"unorderedList"},{"type":"heading","text":"Written By","level":2,"anchor":"Written-By"},{"type":"row","numberOfColumns":5,"columns":[{"size":1,"content":[{"inlineContent":[{"type":"image","identifier":"Cecile-Lebleu"}],"type":"paragraph"}]},{"size":4,"content":[{"text":"Cécile Lebleu","type":"heading","level":3,"anchor":"Cécile-Lebleu"},{"inlineContent":[{"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"isActive":true,"type":"reference","overridingTitle":"Contributed Notes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/Cecile-Lebleu"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/Cecile-Lebleu"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/cecilelebleu.com"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference"}],"type":"paragraph"},{"type":"heading","text":"Related Sessions","level":2,"anchor":"Related-Sessions"},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10043-Meet-MapKit-for-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10148-Whats-new-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10157-Wind-your-way-through-advanced-animations-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10158-Animate-with-springs","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10160-Demystify-SwiftUI-performance"],"type":"links","style":"list"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Legal Notice","type":"text"}]}],"type":"small"},{"inlineContent":[{"text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}],"type":"small"}]}],"kind":"article","sampleCodeDownload":{"action":{"isActive":true,"overridingTitle":"Watch Video (30 min)","type":"reference","identifier":"https:\/\/developer.apple.com\/wwdc23\/10156"},"kind":"sampleDownload"},"sections":[],"metadata":{"roleHeading":"WWDC23","role":"sampleCode","title":"Explore SwiftUI animation","modules":[{"name":"WWDC Notes"}]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10156-Explore-SwiftUI-animation"},"schemaVersion":{"major":0,"patch":0,"minor":3},"abstract":[{"text":"Explore SwiftUI’s powerful animation capabilities and find out how these features work together to produce impressive visual effects. Learn how SwiftUI refreshes the rendering of a view, determines what to animate, interpolates values over time, and propagates context for the current transaction.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc23-10156-explore-swiftui-animation"]}],"references":{"WWDC23-10156-animation-timeline-position-body":{"type":"image","identifier":"WWDC23-10156-animation-timeline-position-body","alt":"Animation timeline for animatable position and animatable body.","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10156-animation-timeline-position-body.jpeg"}]},"WWDC23-Icon.png":{"type":"image","identifier":"WWDC23-Icon.png","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-Icon.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10157-Wind-your-way-through-advanced-animations-in-SwiftUI":{"type":"topic","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc23-10157-wind-your-way-through-advanced-animations-in-swiftui","title":"Wind your way through advanced animations in SwiftUI","role":"sampleCode","abstract":[{"text":"Discover how you can take animation to the next level with the latest updates to SwiftUI. Join us as we wind our way through animation and build out multiple steps, use keyframes to add coordinated multi-track animated effects, and combine APIs in unique ways to make your app spring to life.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10157-Wind-your-way-through-advanced-animations-in-SwiftUI"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10043-Meet-MapKit-for-SwiftUI":{"abstract":[{"type":"text","text":"Discover how expanded SwiftUI support for MapKit has made it easier than ever for you to integrate Maps into your app. We’ll show you how to use SwiftUI to add annotations and overlays to a map, control the camera, and more."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10043-Meet-MapKit-for-SwiftUI","title":"Meet MapKit for SwiftUI","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc23-10043-meet-mapkit-for-swiftui","kind":"article","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/Cecile-Lebleu":{"abstract":[{"type":"text","text":"Designer turned developer."}],"url":"\/documentation\/wwdcnotes\/cecile-lebleu","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/Cecile-Lebleu","title":"Cécile Lebleu (3 notes)","role":"sampleCode","images":[{"type":"card","identifier":"Cecile-Lebleu.jpeg"},{"type":"icon","identifier":"Cecile-Lebleu.jpeg"}],"type":"topic","kind":"article"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"type":"link","title":"Contributions are welcome!","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"Cecile-Lebleu.jpeg":{"type":"image","identifier":"Cecile-Lebleu.jpeg","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/Cecile-Lebleu.jpeg"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10148-Whats-new-in-SwiftUI":{"type":"topic","title":"What’s new in SwiftUI","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10148-Whats-new-in-SwiftUI","abstract":[{"type":"text","text":"Learn how you can use SwiftUI to build great apps for all Apple platforms. Explore the latest updates to SwiftUI and discover new scene types for visionOS. Simplify your data models with the latest data flow options and learn about the Inspector view. We’ll also take you through enhanced animation APIs, powerful ScrollView improvements, and a host of refinements to help you make tidier tables, improve focus and keyboard input, and so much more."}],"kind":"article","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc23-10148-whats-new-in-swiftui"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10158-Animate-with-springs":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10158-Animate-with-springs","url":"\/documentation\/wwdcnotes\/wwdc23-10158-animate-with-springs","role":"sampleCode","kind":"article","title":"Animate with springs","abstract":[{"type":"text","text":"Discover how you can bring life to your app with animation! We’ll show you how to create amazing animations when you take advantage of springs and help you learn how to use them in your app."}]},"https://cecilelebleu.com":{"url":"https:\/\/cecilelebleu.com","titleInlineContent":[{"text":"Blog","type":"text"}],"type":"link","title":"Blog","identifier":"https:\/\/cecilelebleu.com"},"WWDC23-10156-attribute-graph":{"type":"image","identifier":"WWDC23-10156-attribute-graph","alt":"Attribute graph in SwiftUI.","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10156-attribute-graph.png"}]},"WWDCNotes.png":{"type":"image","identifier":"WWDCNotes.png","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10160-Demystify-SwiftUI-performance":{"type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10160-Demystify-SwiftUI-performance","title":"Demystify SwiftUI performance","url":"\/documentation\/wwdcnotes\/wwdc23-10160-demystify-swiftui-performance","abstract":[{"text":"Learn how you can build a mental model for performance in SwiftUI and write faster, more efficient code. We’ll share some of the common causes behind performance issues and help you triage hangs and hitches in SwiftUI to create more responsive views in your app.","type":"text"}],"role":"sampleCode"},"https://developer.apple.com/wwdc23/10156":{"checksum":null,"url":"https:\/\/developer.apple.com\/wwdc23\/10156","type":"download","identifier":"https:\/\/developer.apple.com\/wwdc23\/10156"},"WWDC23.jpeg":{"type":"image","identifier":"WWDC23.jpeg","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23.jpeg"}]},"WWDC23-10156-animation-timeline":{"type":"image","identifier":"WWDC23-10156-animation-timeline","alt":"Animation timeline in SwiftUI.","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10156-animation-timeline.jpeg"}]},"https://github.com/Cecile-Lebleu":{"url":"https:\/\/github.com\/Cecile-Lebleu","titleInlineContent":[{"text":"GitHub","type":"text"}],"type":"link","title":"GitHub","identifier":"https:\/\/github.com\/Cecile-Lebleu"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23":{"url":"\/documentation\/wwdcnotes\/wwdc23","title":"WWDC23","role":"collectionGroup","abstract":[{"type":"text","text":"Xcode 15, Swift 5.9, iOS 17, macOS 14 (Sonoma), tvOS 17, visionOS 1, watchOS 10."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"SwiftData"},{"type":"text","text":", "},{"type":"codeVoice","code":"Observation"},{"type":"text","text":", "},{"type":"codeVoice","code":"StoreKit"},{"text":" views, and more.","type":"text"}],"images":[{"identifier":"WWDC23-Icon.png","type":"icon"},{"identifier":"WWDC23.jpeg","type":"card"}],"type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"},"doc://WWDCNotes/documentation/WWDCNotes":{"images":[{"type":"icon","identifier":"WWDCNotes.png"}],"type":"topic","url":"\/documentation\/wwdcnotes","role":"collection","title":"WWDC Notes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"kind":"symbol"},"Cecile-Lebleu":{"type":"image","identifier":"Cecile-Lebleu","alt":"Profile image of Cécile Lebleu","variants":[{"traits":["1x","light"],"url":"\/images\/Cecile-Lebleu.jpeg"}]}}}