{"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-415-Behind-the-Scenes-of-the-Xcode-Build-Process","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Ever wonder what happens when you build your project in Xcode? Learn how Xcode automates the steps required to build an application, and go behind the scenes to learn how clang, swiftc, and the linker work together to turn your source code into a working program."}],"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18"]]},"sampleCodeDownload":{"action":{"identifier":"https:\/\/developer.apple.com\/wwdc18\/415","type":"reference","isActive":true,"overridingTitle":"Watch Video (57 min)"},"kind":"sampleDownload"},"metadata":{"title":"Behind the Scenes of the Xcode Build Process","role":"sampleCode","modules":[{"name":"WWDC Notes"}],"roleHeading":"WWDC18"},"primaryContentSections":[{"content":[{"anchor":"Xcode-10-build-system","text":"Xcode 10 build system","type":"heading","level":2},{"items":[{"content":[{"inlineContent":[{"text":"written from scratch in Swift","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"improved performance and reliability"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Build-Process-Execution-of-a-collection-of-Tasks","text":"Build Process: Execution of a collection of Tasks","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"When building an app, we go throughout a sequence of steps:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Compile and link source code","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Copy and process resources (e.g., headers, asset catalogues, storyboards)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Code sign"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"(optional) custom work in shell scripts","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"…and more","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Most of the tasks in the build process are performed by running command line tools:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"swiftc"},{"type":"text","text":" (Swift compiler)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"clang","type":"codeVoice"},{"text":" (C, C++, ObjC compiler)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ld"},{"type":"text","text":" (linker)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"actool"},{"type":"text","text":" (assets catalog tool)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"…"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"These tools have to be executed with a very specific set of arguments, and in a particular order, based on the configuration of your Xcode project."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The build process automates the orchestration and execution of these tasks each time you perform a build."}]},{"type":"paragraph","inlineContent":[{"text":"The order in which build tasks are executed is determined from the dependency information of each task:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"the inputs that a task consumes","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"the outputs that a task produces"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"For example:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"a compilation task consumes a source code file ("},{"type":"text","text":".swift"},{"type":"text","text":", "},{"type":"text","text":".m"},{"type":"text","text":") as input, and produces an object file ("},{"type":"text","text":".o"},{"type":"text","text":") as output"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"a linker task consumes a number of object files ("},{"type":"text","text":".o"},{"type":"text","text":") produced by the compiler in previous tasks, and produces and executable or library output"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"If tasks are independent, they can (and will) run in parallel.","type":"text"}]},{"anchor":"What-happens-when-you-press-build","text":"What happens when you press build?","type":"heading","level":2},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"the build system takes the build description in your Xcode project file, parses it, takes into account all the files in your project, your targets, the dependency relationships, your build settings, etc."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the build system will generate a Directed Graph (from the info of step 1), which represents all the dependencies between the input and output files in your project. It will generate the tasks that will be executed to process them."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"the low-level execution engine (","type":"text"},{"type":"codeVoice","code":"llbuild"},{"text":", ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-llbuild","type":"reference"},{"text":") processes this graph, looks at the dependency specifications and figures out which tasks to execute, the sequence or order in which they must be run, which tasks can be run in parallel. Then proceeds to execute them.","type":"text"}]}]}],"type":"orderedList"},{"anchor":"Discovered-dependencies","text":"Discovered dependencies","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"When "},{"type":"codeVoice","code":"llbuild"},{"type":"text","text":" runs, besides outputting the object file ("},{"type":"text","text":".o"},{"type":"text","text":"), it might also output a listing file ("},{"type":"text","text":".d"},{"type":"text","text":"), containing which header files (imports) were included by that source file."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The next time you build, the build system uses the information from this file ("},{"type":"text","text":".d"},{"type":"text","text":") to make sure that it recompiles the source file if you change any of the header files that it includes."}]},{"type":"paragraph","inlineContent":[{"text":"Having an accurate dependency information (via ","type":"text"},{"text":".d","type":"text"},{"text":") is very important in order for incremental builds to work correctly and efficiently.","type":"text"}]},{"anchor":"Change-Detection-and-Task-Signatures","text":"Change Detection and Task Signatures","type":"heading","level":3},{"items":[{"content":[{"inlineContent":[{"text":"Each task in the build graph has an associated signature","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this signature is a hash computed from various task information"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"the stat info of the task’s inputs","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"file paths"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"modification time stamps"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"the command line indication used to perform the command"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"and other task-specific metadata such as the version of the compiler that’s being used","type":"text"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"build system tracks task signatures among multiple builds"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"a task is re-run when the hash is different between builds, it’s skipped otherwise","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Where-do-dependencies-come-from","text":"Where do dependencies come from?","type":"heading","level":3},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Built in - the various tools within the build system know which tasks accept which input and produce which output (e.g. "},{"type":"codeVoice","code":"atool"},{"type":"text","text":", "},{"type":"codeVoice","code":"ld"},{"type":"text","text":", ..)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Target dependencies","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"before Xcode 10, when a target was built, it required the compilation of the entire dependent target to be completed before it could start","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"with Xcode 10 new build system, targets can start building sooner"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"all run script phases need to complete before this parallelization can take effect"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC18-415-targetDep","type":"image"}]},{"items":[{"content":[{"inlineContent":[{"text":"Implicit dependencies","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"if you list a target in your "},{"type":"text","text":"Link library With Binaries"},{"type":"text","text":" build phase, and "},{"type":"text","text":"Find Implicit Dependencies"},{"type":"text","text":" are enabled in the scheme editor (on by default), the build system will establish an implicit dependency on that target (even if it’s not listed in target dependencies)"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC18-415-linkDep"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Build phase dependencies","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"each phase is a separate task"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"the build system might run these phases in a different order (e.g. if ","type":"text"},{"text":"Link Binary with libraries","type":"text"},{"text":" phase is ordered before ","type":"text"},{"text":"Compile sources","type":"text"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"a wrong phase order might cause a build failure","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC18-415-buildDep","type":"image"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Scheme order dependencies"}]},{"items":[{"content":[{"inlineContent":[{"text":"If you have the ","type":"text"},{"text":"Parallelize Build","type":"text"},{"text":" check box enabled in your scheme settings, you get better build performance and the order of your targets in your scheme doesn’t matter","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"if you turn ","type":"text"},{"text":"Parallelize Build","type":"text"},{"text":" off, Xcode will attempt to build your targets in the order you listed them in the build action of the scheme one by one","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC18-415-schemeDep"}]},{"anchor":"Tips","text":"Tips","type":"heading","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"set input\/outputs on your build phases (lets the build system avoid re-running the script tasks unnecessarily)","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Avoid Auto-link for project dependencies"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"this setting allows the compiler to automatically link to the frameworks corresponding to any modules you import without having to explicitly link them in your link library’s build phase","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"auto-link does not establish dependency on that framework at the build system level (won’t guarantee that the target you depend on is actually built before you try to link against it)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"you should rely on this feature only for frameworks from the platform SDK (UIKit, etc.).","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC18-415-autolink","type":"image"}]},{"items":[{"content":[{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For targets in your own projects, make sure to add explicit library dependencies"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC18-415-noautolink"}]},{"anchor":"Clang-Compiler","text":"Clang Compiler","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Clang is Apple’s official compiler for the C language family.","type":"text"}]},{"anchor":"Header-Maps","text":"Header Maps","type":"heading","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"tell the build system (Clang) where the file headers are located"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"their purpose is to point back to your source code"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"if needed, they prepend your framework name to headers, e.g. "},{"type":"text","text":"Cat.h"},{"type":"text","text":" will change to "},{"type":"text","text":"PetKit\/Cat.h"},{"type":"text","text":", however this can cause issues with Clang modules"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"it is recommended that you always specify the framework name when you include a public or private header file from your own framework (instead of writing "},{"type":"codeVoice","code":"import <Cat.h>"},{"type":"text","text":" or "},{"type":"codeVoice","code":"import Cat.h"},{"type":"text","text":", write "},{"type":"codeVoice","code":"import <PetKit\/Cat.h>"},{"type":"text","text":" or "},{"type":"codeVoice","code":"import PetKit\/Cat.h"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"you don’t need to do this for project headers"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"How does the build system find the system header maps?"}]},{"items":[{"content":[{"inlineContent":[{"text":"header maps are only for your code","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Clang searches system header files in two folders be default:","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["$(SDKROOT)\/usr\/include ","$(SDKROOT)\/System\/Library\/Frameworks (framework directory)"],"syntax":"cli","type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"code":"$(SDKROOT)","type":"codeVoice"},{"text":" specifies the directory of the base SDK to use to build the product.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"type":"paragraph","inlineContent":[{"text":"Let’s say we’re searching for ","type":"text"},{"code":"Foundation","type":"codeVoice"},{"text":"’s header map:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"first Clang searches ","type":"text"},{"code":"$(SDKROOT)\/usr\/include\/Foundation\/Foundation.h","type":"codeVoice"},{"text":", it won’t find it there (unless you’ve declared a new Foundation header, this is called header shadowing)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"then it will try to find it in the ","type":"text"},{"code":"$(SDKROOT)\/System\/Library\/Frameworks","type":"codeVoice"},{"text":" path, in this folder Clang needs to search for the framework and then dive into it and grab the headers:","type":"text"}]}]}],"type":"orderedList"},{"code":["$SDKROOT\/System\/Library\/Frameworks\/Foundation.framework\/Headers\/Foundation.h"],"syntax":"cli","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If it cannot find it there, it will try to search for the header in the "},{"type":"codeVoice","code":"PrivateHeaders"},{"type":"text","text":" directory:"}]},{"code":["$SDKROOT\/System\/Library\/Frameworks\/Foundation.framework\/PrivateHeaders\/Foundation.h"],"syntax":"cli","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Apple doesn’t ship any ","type":"text"},{"type":"codeVoice","code":"PrivateHeaders"},{"text":" but other projects might, hence Clang will look there, too.","type":"text"}]},{"anchor":"Clang-modules","text":"Clang modules","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Clang modules are on-disk cached header representations that allow us to only find and parse the headers once per framework.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To make this possible, every module needs to have certain properties:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"context-free: ignores the context-related statement (e.g., macro definitions)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"self-contained: has to specify its own dependencies","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"How does Clang know when it should build a module?","type":"text"}]},{"anchor":"System-modules","text":"System modules","type":"heading","level":4},{"items":[{"content":[{"inlineContent":[{"text":"first Clang has to find the header in the framework (as we saw above).","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"then Clang will look for a ","type":"text"},{"code":"Modules","type":"codeVoice"},{"text":" directory and a ","type":"text"},{"code":"module.modulemap","type":"codeVoice"},{"text":" relative to the header’s directory. A Module Map describes how a certain set of header files translate onto your module","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Here’s the whole Foundation module map:","type":"text"}]},{"code":["\/\/ Foundation.framework\/Modules\/module.modulemap ","","framework module Foundation [extern_c] [system] { ","  umbrella header \"Foundation.h\" ","","  export *","  module * { ","    export * ","  }","","  explicit module NSDebug { ","    header \"NSDebug.h\" ","    export * ","  }","}"],"syntax":"objc","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The module map contains the framework name and specifies what headers are part of the module.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In Foundation’s case, ","type":"text"},{"code":"Foundation.h","type":"codeVoice"},{"text":" is an umbrella header, which also needs to be parsed to look for other headers in the module.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Lastly, we use the command "},{"type":"codeVoice","code":"$ clang -fmodules ..."},{"type":"text","text":" to create a module cache on disk. Note that creates a cache folder by hashing the command arguments, if we change the "},{"type":"codeVoice","code":"clang -fmodules ..."},{"type":"text","text":" invocation, a new cache will be used\/generated."}]},{"anchor":"3rd-party-modules","text":"3rd party modules","type":"heading","level":4},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In our frameworks, the header map will point to the source directory, where we don’t have a "},{"code":"Modules","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Clang doesn’t know how to handle this","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"solution: Clang Virtual File System (VFS)"}]},{"items":[{"content":[{"inlineContent":[{"text":"VFS creates a virtual abstraction of a framework that allows Clang to build the module","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"the abstraction just points to the files back in your directory"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"anchor":"Clang-and-Swift","text":"Clang and Swift","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"As Swift files don’t have headers, the compiler has to perform some additional bookkeeping.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The compiler has to:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"find declarations both within Swift targets and from Objective-C (to compile Swift files depending on Objective-C declarations)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"generate interfaces describing the contents of each file (to compile Objective-C files depending on Swift declarations)","type":"text"}]}]}],"type":"orderedList"},{"anchor":"Finding-declarations-within-a-Swift-Target","text":"Finding declarations within a Swift Target","type":"heading","level":4},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"unlike Clang, when compiling one Swift file (with "},{"type":"codeVoice","code":"swiftc"},{"type":"text","text":"), the compiler will parse all the other Swift files in the target. To examine the parts of them that are relevant to the interfaces."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"note that it will only parse the files headers, not the implementations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"in Xcode 9, this resulted in repeated work as the compiler had to repeatedly parse all files (once to produce the associated "},{"type":"text","text":".o"},{"type":"text","text":", and multiple times as an interface to find declarations)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"in Xcode 10, the compiler gather multiple files into groups (that will be compiled in separated processes) to share as much work as possible (avoids repeating parsing within a group, only need to parse again across groups\/processes).","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Finding-declarations-from-Objective-C","text":"Finding declarations from Objective-C","type":"heading","level":4},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"swiftc"},{"type":"text","text":" embeds "},{"type":"codeVoice","code":"clang"},{"type":"text","text":" and uses it as a library"}]}]},{"content":[{"inlineContent":[{"text":"this makes it possible to directly import Objective-C (without having to manually create a Swift interface for each declaration)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"in any target, when you import an Objective-C framework, the importer finds declarations in the headers exposing Clang’s module map for that framework"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"within a framework that mixes Swift and Objective-C code, the importer finds declarations in the "},{"type":"strong","inlineContent":[{"type":"text","text":"umbrella header"}]},{"type":"text","text":" (this header defines the public interface, this way, Swift code inside the framework can call public Objective-C code in the same framework. The umbrella header name is the name of the framework, e.g. "},{"code":"MyFramework.h","type":"codeVoice"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"within app and unit test bundles, via the target "},{"type":"strong","inlineContent":[{"type":"text","text":"bridging header"}]},{"type":"text","text":" (which allows Objective-C declarations to be called from Swift)"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Clang Importer makes methods more Swifty, e.g.:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"methods that use the ","type":"text"},{"code":"NSError","type":"codeVoice"},{"text":" idiom become throwing methods in Swift","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"methods will drop parameter type names following verbs and prepositions (see full list "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift\/blob\/82568468494fd74dba17ba695c3cdf6fab1c3369\/lib\/Basic\/PartsOfSpeech.def"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"use "},{"type":"codeVoice","code":"NS_SWIFT_NAME"},{"type":"text","text":" to change imported name explicitly"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"if you’d like to check\/preview how your Objective-C code will be imported into Swift: go to Xcode’s related items ("},{"type":"text","text":"^"},{"type":"text","text":" + "},{"type":"text","text":"1"},{"type":"text","text":") and select "},{"type":"text","text":"Generated interface"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Generate-interfaces-to-use-in-Objective-C","text":"Generate interfaces to use in Objective-C","type":"heading","level":4},{"items":[{"content":[{"inlineContent":[{"text":"Swift generates a header that you can ","type":"text"},{"type":"codeVoice","code":"#import"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this allows you to write classes in Swift and call them from Objective-C"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Declaration in Swift:","type":"text"}]},{"code":["class PetCollar: NSObject {","  @objc var color: UIColor = ...","  var name: String = \"...\"","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use from Objective-C:"}]},{"code":["#import \"PetWall-Swift.h\"","","- (void)resetCollarColor {","  self.collar.color = [UIColor redColor];","}"],"syntax":"objc","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The compiler will generate Objective-C declarations for Swift classes extending "},{"type":"codeVoice","code":"NSObject"},{"type":"text","text":" and methods\/properties marked "},{"type":"codeVoice","code":"@objc"}]},{"type":"paragraph","inlineContent":[{"text":"Swift declaration:","type":"text"}]},{"code":["class PetCollar: NSObject {","  @objc var color: UIColor = ...","  var name: String = \"...\"","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generated Objective-C header:"}]},{"code":["SWIFT_CLASS(\"_TtC7PetWall9PetCollar\")","@interface PetCollar: NSObject","@property (nonatomic, strong) UIColor * _Nonnull color; ","- (nonnull instancetype)init; ","@end"],"syntax":"objc","type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"the compiler ties the Objective-C class to the mangled name of the Swift class, which includes the name of the module (PetWall): this prevents conflict when two modules define classes with the same name"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Use ","type":"text"},{"code":"@objc(YOUROBJCCLASSNAMEHERE)","type":"codeVoice"},{"text":" to provide a Objective-C custom name","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"anchor":"Generate-interfaces-to-use-in-other-Swift-Targets","text":"Generate interfaces to use in other Swift Targets","type":"heading","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"What’s a module?"}]},{"items":[{"content":[{"inlineContent":[{"text":"distributable unit of declarations","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"must first import other modules to see their declarations"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"can import Clang\/Objective-C modules (e.g., XCTest)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"in Xcode, each Swift target produces a separate module (including your app target, this is why you have to import your app’s main module in order to test it from your unit tests)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"when importing a module, the compiler deserializes a special Swift module file ("},{"type":"text","text":".swiftmodule"},{"type":"text","text":") to check the types when you use them"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Expose Declarations to Other Modules via "},{"type":"text","text":".swiftmodule"},{"type":"text","text":":"}]},{"items":[{"content":[{"inlineContent":[{"text":"Serialized, binary representation of module’s declarations","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Includes bodies of ","type":"text"},{"type":"codeVoice","code":"@inlinable"},{"text":" functions","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Includes private declarations (for debugging)"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For incremental builds:"}]},{"items":[{"content":[{"inlineContent":[{"text":"the compiler produces partial Swift module files and then merges them into a single file that represents the contents of the entire module","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this merging process also makes it possible to produce a single Objective-C header (out of the final "},{"type":"text","text":".swiftmodule"},{"type":"text","text":")"}]}]}],"type":"unorderedList"},{"anchor":"Behind-the-Scenes-of-the-Xcode-Build-Process-Linking","text":"Behind the Scenes of the Xcode Build Process: Linking","type":"heading","level":2},{"anchor":"The-Linker","text":"The Linker","type":"heading","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it’s the final task in building an executable Mach-O"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"it combines the output of all compiler invocations (Object files "},{"type":"text","text":".o"},{"type":"text","text":", Libraries "},{"type":"text","text":".dylib"},{"type":"text","text":", "},{"type":"text","text":".tbd"},{"type":"text","text":", "},{"type":"text","text":".a"},{"type":"text","text":") into a single file"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"moves and patches code generated by the compilers (it cannot create code)"}]}]}],"type":"unorderedList"},{"anchor":"Symbols","text":"Symbols","type":"heading","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"A symbol is a name to refer to a fragment of code or data","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Fragments of code may reference other symbols (e.g., when a function calls another function)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Symbols can have attributes on them that alter the linker’s behavior","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"e.g. Weak is one of those attributes"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"weak symbols state that the symbol might not be there when we run the executable on the system"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this is what all the availability markup that says this API is available on iOS x"}]}]}],"type":"unorderedList"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Languages often encode data into a symbol mangling the symbol","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Object-Files-o","text":"Object Files (.o)","type":"heading","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Output of individual compiler actions"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"they are collections of code and data we refer via symbols"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A non-executable Mach-O file containing code and data fragments"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"while they are compiled code, they have bits missing, which is what the linker is going to glue together"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Each fragment in these ","type":"text"},{"text":".o","type":"text"},{"text":" is represented by a symbol","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Fragments may reference “undefined” symbols","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"when a ","type":"text"},{"text":".o","type":"text"},{"text":" refers to a function in another ","type":"text"},{"text":".o","type":"text"},{"text":" file, the linker is responsible to find those undefined symbols and link them","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"anchor":"Libraries","text":"Libraries","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Libraries define symbols that are not built as part of your target"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Dylibs: Dynamic libraries ("},{"type":"text","text":".dylib"},{"type":"text","text":")"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Mach-O file that exposes code and data fragments executables can use","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"some of those are distributed as part of the OS, that’s what Apple’s frameworks are"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"can also be from 3rd parties","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"TBDs: Text Based Dylib Stubs ("},{"type":"text","text":".tbd"},{"type":"text","text":")"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"only contains symbols"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"no bodies for any symbols, just their names (no binary code)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"used for distributing Apple’s SDKs to reduce their size (it reduces the size of the SDK you download with Xcode, not the size of the app you’re building)"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Static archives (","type":"text"},{"text":".a","type":"text"},{"text":")","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"archive of multiple ","type":"text"},{"text":".o","type":"text"},{"text":" files built with the ","type":"text"},{"type":"codeVoice","code":"ar"},{"text":" tool","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it’s just a "},{"type":"text","text":".zip"},{"type":"text","text":" file with "},{"type":"text","text":".a"},{"type":"text","text":" extension ("},{"type":"text","text":".a"},{"type":"text","text":" was the original archive format used by UNIX)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"only ","type":"text"},{"text":".o","type":"text"},{"text":" files with symbols you reference are included in your app","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’re using some sort of non-symbol behavior like a static initializer, or you’re re-exporting them as part of your own dylib, you may need to explicitly use something like force load or all load to the linker to tell it bring in everything"}]}]}]}]}]}]}],"type":"unorderedList"},{"anchor":"Written-By","text":"Written By","type":"heading","level":2},{"columns":[{"content":[{"inlineContent":[{"identifier":"zntfdr","type":"image"}],"type":"paragraph"}],"size":1},{"content":[{"anchor":"Federico-Zanetello","type":"heading","text":"Federico Zanetello","level":3},{"inlineContent":[{"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","isActive":true,"overridingTitle":"Contributed Notes"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/zntfdr","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/zntfdr.dev","isActive":true}],"type":"paragraph"}],"size":4}],"numberOfColumns":5,"type":"row"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"isActive":true,"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}]},{"anchor":"Related-Sessions","text":"Related Sessions","type":"heading","level":2},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110364-Demystify-parallelization-in-Xcode-builds","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10680-Refine-ObjectiveC-frameworks-for-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-401-Whats-New-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-408-Building-Faster-in-Xcode","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC17-413-App-Startup-Time-Past-Present-and-Future"],"style":"list","type":"links"},{"type":"small","inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}]},{"type":"small","inlineContent":[{"text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}]}],"kind":"content"}],"kind":"article","sections":[],"variants":[{"paths":["\/documentation\/wwdcnotes\/wwdc18-415-behind-the-scenes-of-the-xcode-build-process"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10680-Refine-ObjectiveC-frameworks-for-Swift":{"kind":"article","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10680-Refine-ObjectiveC-frameworks-for-Swift","title":"Refine Objective-C frameworks for Swift","url":"\/documentation\/wwdcnotes\/wwdc20-10680-refine-objectivec-frameworks-for-swift","type":"topic","abstract":[{"text":"Fine-tune your Objective-C headers to work beautifully in Swift. We’ll show you how to take an unwieldy Objective-C framework and transform it into an API that feels right at home. Learn about the suite of annotations you can use to provide richer type information, more idiomatic names, and better errors to Swift. And discover Objective-C conventions you might not have known about that are key to a well-behaved Swift API.","type":"text"}]},"WWDC18-Icon.png":{"alt":null,"variants":[{"url":"\/images\/WWDC18-Icon.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-Icon.png"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","kind":"article","url":"\/documentation\/wwdcnotes\/zntfdr","abstract":[{"text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more.","type":"text"}],"title":"Federico Zanetello (332 notes)","images":[{"identifier":"zntfdr.jpeg","type":"card"},{"identifier":"zntfdr.jpeg","type":"icon"}],"role":"sampleCode"},"WWDC18-415-targetDep":{"alt":null,"variants":[{"url":"\/images\/WWDC18-415-targetDep.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-415-targetDep"},"doc://WWDCNotes/documentation/WWDCNotes":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","kind":"symbol","url":"\/documentation\/wwdcnotes","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"title":"WWDC Notes","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"role":"collection"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC17-413-App-Startup-Time-Past-Present-and-Future":{"type":"topic","title":"App Startup Time: Past, Present, and Future","abstract":[{"text":"Learn about the dyld dynamic linker used on Apple platforms, how it’s changed over the years, and where it’s headed next. Find out how improved tooling makes it easier to optimize your app’s launch time, and see how new changes coming in dyld will bring even further launch time improvements.","type":"text"}],"role":"sampleCode","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc17-413-app-startup-time-past-present-and-future","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC17-413-App-Startup-Time-Past-Present-and-Future"},"WWDCNotes.png":{"alt":null,"variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}],"type":"image","identifier":"WWDCNotes.png"},"https://github.com/zntfdr":{"titleInlineContent":[{"text":"GitHub","type":"text"}],"url":"https:\/\/github.com\/zntfdr","title":"GitHub","type":"link","identifier":"https:\/\/github.com\/zntfdr"},"WWDC18-415-linkDep":{"alt":null,"variants":[{"url":"\/images\/WWDC18-415-linkDep.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-415-linkDep"},"WWDC18-415-buildDep":{"alt":null,"variants":[{"url":"\/images\/WWDC18-415-buildDep.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-415-buildDep"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC18-408-Building-Faster-in-Xcode":{"url":"\/documentation\/wwdcnotes\/wwdc18-408-building-faster-in-xcode","title":"Building Faster in Xcode","role":"sampleCode","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-408-Building-Faster-in-Xcode","kind":"article","abstract":[{"text":"Build your apps faster in Xcode 10. Learn how to structure your projects and tweak your code to take full advantage of all processor cores. Whether you’ve made a few small code changes you want to give a try, or you’re building your full app for release, these techniques will cut the time it takes to build a running app.","type":"text"}]},"https://developer.apple.com/wwdc18/415":{"url":"https:\/\/developer.apple.com\/wwdc18\/415","checksum":null,"type":"download","identifier":"https:\/\/developer.apple.com\/wwdc18\/415"},"WWDC18-415-autolink":{"alt":null,"variants":[{"url":"\/images\/WWDC18-415-autolink.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-415-autolink"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC18-401-Whats-New-in-Swift":{"title":"What’s New in Swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-401-Whats-New-in-Swift","kind":"article","role":"sampleCode","abstract":[{"type":"text","text":"Hear about the latest advancements in Swift, the safe, fast, and expressive language. Find out about improvements to build times, code size, and runtime performance. Learn how to take advantage of new features in your code that eliminate boilerplate, increase safety and security, and improve your overall development productivity."}],"url":"\/documentation\/wwdcnotes\/wwdc18-401-whats-new-in-swift","type":"topic"},"WWDC18.jpeg":{"alt":null,"variants":[{"url":"\/images\/WWDC18.jpeg","traits":["1x","light"]}],"type":"image","identifier":"WWDC18.jpeg"},"zntfdr.jpeg":{"alt":null,"variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image","identifier":"zntfdr.jpeg"},"https://github.com/apple/swift-llbuild":{"titleInlineContent":[{"text":"it’s open source","type":"text"}],"url":"https:\/\/github.com\/apple\/swift-llbuild","title":"it’s open source","type":"link","identifier":"https:\/\/github.com\/apple\/swift-llbuild"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110364-Demystify-parallelization-in-Xcode-builds":{"title":"Demystify parallelization in Xcode builds","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110364-Demystify-parallelization-in-Xcode-builds","type":"topic","abstract":[{"text":"Learn how the Xcode build system extracts maximum parallelism from your builds. We’ll explore how you can structure your project to improve build efficiency, take you through the process for resolving relationships between targets’ build phases in Xcode, and share how you can take full advantage of available hardware resources when compiling in Swift. We’ll also introduce you to Build Timeline — a powerful tool to help you monitor your build efficiency and performance.","type":"text"}],"role":"sampleCode","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc22-110364-demystify-parallelization-in-xcode-builds"},"WWDC18-415-noautolink":{"alt":null,"variants":[{"url":"\/images\/WWDC18-415-noautolink.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-415-noautolink"},"https://github.com/apple/swift/blob/82568468494fd74dba17ba695c3cdf6fab1c3369/lib/Basic/PartsOfSpeech.def":{"titleInlineContent":[{"text":"here","type":"text"}],"url":"https:\/\/github.com\/apple\/swift\/blob\/82568468494fd74dba17ba695c3cdf6fab1c3369\/lib\/Basic\/PartsOfSpeech.def","title":"here","type":"link","identifier":"https:\/\/github.com\/apple\/swift\/blob\/82568468494fd74dba17ba695c3cdf6fab1c3369\/lib\/Basic\/PartsOfSpeech.def"},"https://zntfdr.dev":{"titleInlineContent":[{"text":"Blog","type":"text"}],"url":"https:\/\/zntfdr.dev","title":"Blog","type":"link","identifier":"https:\/\/zntfdr.dev"},"zntfdr":{"alt":"Profile image of Federico Zanetello","variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image","identifier":"zntfdr"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC18":{"url":"\/documentation\/wwdcnotes\/wwdc18","title":"WWDC18","abstract":[{"text":"Xcode 10, Swift 4.2, iOS 12, macOS 10.14 (Mojave), tvOS 12, watchOS 5.","type":"text"}],"images":[{"identifier":"WWDC18-Icon.png","type":"icon"},{"identifier":"WWDC18.jpeg","type":"card"}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18","kind":"article","role":"collectionGroup"},"WWDC18-415-schemeDep":{"alt":null,"variants":[{"url":"\/images\/WWDC18-415-schemeDep.png","traits":["1x","light"]}],"type":"image","identifier":"WWDC18-415-schemeDep"}}}