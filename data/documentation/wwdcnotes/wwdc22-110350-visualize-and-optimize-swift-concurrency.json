{"metadata":{"title":"Visualize and optimize Swift concurrency","roleHeading":"WWDC22","role":"sampleCode","modules":[{"name":"WWDC Notes"}]},"abstract":[{"text":"Learn how you can optimize your app with the Swift Concurrency template in Instruments. We’ll discuss common performance issues and show you how to use Instruments to find and resolve these problems. Learn how you can keep your UI responsive, maximize parallel performance, and analyze Swift concurrency activity within your app.","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc22-110350-visualize-and-optimize-swift-concurrency"]}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22"]]},"primaryContentSections":[{"content":[{"level":2,"type":"heading","anchor":"Swift-Concurrency-Recap","text":"Swift Concurrency Recap"},{"anchor":"Asyncawait","type":"heading","text":"`Async\/await`","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"basic syntactic building blocks for concurrent code","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"allow you to create and call functions that can suspend their work in the middle of execution, then resume that work later, without blocking an execution thread","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Tasks","type":"heading","text":"`Task`s","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"basic unit of work in concurrent code"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"execute concurrent code and manage its state and associated data"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"contain local variables"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"handle cancellation","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"begin\/suspend execution of async code","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Structured-concurrency","type":"heading","text":"Structured concurrency","level":3},{"items":[{"content":[{"inlineContent":[{"text":"makes it easy to spawn child tasks to run in parallel and wait for them to complete","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"ensures that tasks are awaited or automatically canceled if not used"}]}]}],"type":"unorderedList"},{"anchor":"Actors","type":"heading","text":"`Actor`s","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"coordinate multiple tasks that need to access shared data"}]}]},{"content":[{"inlineContent":[{"text":"isolate data from the outside","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"allow only one task at a time to manipulate their internal state, avoiding data races from concurrent mutation","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Continuations","type":"heading","text":"`Continuation`s","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"bridge between Swift concurrency and other forms of async code (GCD)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"a continuation suspends the current task and provides a callback which resumes the task when called","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"can be used with callback-based async APIs","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Continuation callbacks must be called exactly once","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Concurrency-Optimization","type":"heading","text":"Concurrency Optimization","level":2},{"inlineContent":[{"type":"text","text":"Even with Swift concurrency is still possible to write code that misuses concurrency constructs, common issues:"}],"type":"paragraph"},{"anchor":"Main-actor-blocking","type":"heading","text":"Main actor blocking","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"occurs when a long-running task runs on the main Actor","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"can cause your app to hang","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Actor-contention","type":"heading","text":"Actor contention","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"occurs when several tasks attempt to use the same "},{"type":"codeVoice","code":"Actor"},{"type":"text","text":" simultaneously"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"each task must wait for the Actor to become available"}]}]},{"content":[{"inlineContent":[{"text":"the ","type":"text"},{"code":"Actor","type":"codeVoice"},{"text":" serializes execution of those tasks","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"hurt performance by reducing parallel execution","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"To fix this, we need make sure that tasks only run on the Actor when they really need exclusive access to the Actor’s data. Everything else should run off of the Actor","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Thread-pool-exhaustion","type":"heading","text":"Thread pool exhaustion","level":3},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"hurt performance by reducing parallel execution"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"can hurt performance or even deadlock an application","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"happens when a task waits for something via a blocking call, such as blocking file or network IO, or acquiring locks, without suspending"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"this breaks the requirement for tasks to make forward progress, because the task continues to occupy the thread where it’s executing, but it isn’t actually using a CPU core","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"in such situations the concurrency runtime is unable to fully use all CPU cores, and can even cause deadlock"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"make blocking calls outside Swift Concurrency (for example by running it on a Dispatch queue, and bridge it to the concurrency world using continuations)"}]}]}],"type":"unorderedList"},{"anchor":"Continuation-misuse","type":"heading","text":"Continuation misuse","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"occurs when the continuation callback is called multiple times or never","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"the program will crash or misbehave when the continuation callback is called more than once"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"the task will leak (a.k.a. wait forever) if the callback is never called","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The new Swift Concurrency instrument helps catching these problems in your app.","type":"text"}],"type":"paragraph"},{"anchor":"Written-By","type":"heading","text":"Written By","level":2},{"numberOfColumns":5,"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"identifier":"zntfdr","type":"image"}],"type":"paragraph"}]},{"size":4,"content":[{"level":3,"type":"heading","text":"Federico Zanetello","anchor":"Federico-Zanetello"},{"type":"paragraph","inlineContent":[{"isActive":true,"overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitle":"Contributed Notes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/zntfdr","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/zntfdr.dev","type":"reference"}]}]}]},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","isActive":true}],"type":"paragraph"},{"anchor":"Related-Sessions","type":"heading","text":"Related Sessions","level":2},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10248-Analyze-hangs-with-Instruments","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10068-Whats-new-in-UIKit","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10082-Track-down-hangs-with-Xcode-and-ondevice-detection","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110354-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"],"style":"list","type":"links"},{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Legal Notice","type":"text"}]}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}],"kind":"content"}],"kind":"article","sampleCodeDownload":{"kind":"sampleDownload","action":{"identifier":"https:\/\/developer.apple.com\/wwdc22\/110350","isActive":true,"overridingTitle":"Watch Video (24 min)","type":"reference"}},"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","interfaceLanguage":"swift"},"sections":[],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10194-Swift-concurrency-Update-a-sample-app":{"abstract":[{"type":"text","text":"Discover Swift concurrency in action: Follow along as we update an existing sample app. Get real-world experience with async\/await, actors, and continuations. We’ll also explore techniques for migrating existing code to Swift concurrency over time."}],"role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","title":"Swift concurrency: Update a sample app","url":"\/documentation\/wwdcnotes\/wwdc21-10194-swift-concurrency-update-a-sample-app","type":"topic","kind":"article"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10254-Swift-concurrency-Behind-the-scenes":{"title":"Swift concurrency: Behind the scenes","abstract":[{"text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We’ll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes","type":"topic","role":"sampleCode","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"},"https://developer.apple.com/wwdc22/110350":{"checksum":null,"url":"https:\/\/developer.apple.com\/wwdc22\/110350","identifier":"https:\/\/developer.apple.com\/wwdc22\/110350","type":"download"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22","role":"collectionGroup","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc22","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"kind":"article","title":"WWDC22","abstract":[{"type":"text","text":"Xcode 14, Swift 5.7, iOS 16, macOS 13 (Ventura), tvOS 16, watchOS 9."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"WeatherKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"ScreenCaptureKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"Swift Regex"},{"type":"text","text":", and more."}]},"doc://WWDCNotes/documentation/WWDCNotes":{"abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"kind":"symbol","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","type":"topic","title":"WWDC Notes","url":"\/documentation\/wwdcnotes","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"role":"collection"},"WWDCNotes.png":{"alt":null,"identifier":"WWDCNotes.png","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10133-Protect-mutable-state-with-Swift-actors":{"role":"sampleCode","kind":"article","title":"Protect mutable state with Swift actors","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","abstract":[{"type":"text","text":"Data races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug."}],"url":"\/documentation\/wwdcnotes\/wwdc21-10133-protect-mutable-state-with-swift-actors"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10132-Meet-asyncawait-in-Swift":{"title":"Meet async\/await in Swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","abstract":[{"text":"Swift now supports asynchronous functions — a pattern commonly known as async\/await. Discover how the new syntax can make your code easier to read and understand. Learn what happens when a function suspends, and find out how to adapt existing completion handlers to asynchronous functions.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc21-10132-meet-asyncawait-in-swift","kind":"article","role":"sampleCode","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10170-Beyond-the-basics-of-structured-concurrency":{"title":"Beyond the basics of structured concurrency","abstract":[{"text":"It’s all about the task tree: Find out how structured concurrency can help your apps manage automatic task cancellation, task priority propagation, and useful task-local value patterns. Learn how to manage resources in your app with useful patterns and the latest task group APIs. We’ll show you how you can leverage the power of the task tree and task-local values to gain insight into distributed systems.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc23-10170-beyond-the-basics-of-structured-concurrency","type":"topic","role":"sampleCode","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110354-Whats-new-in-Swift":{"url":"\/documentation\/wwdcnotes\/wwdc22-110354-whats-new-in-swift","abstract":[{"type":"text","text":"Join us for an update on Swift. We’ll take you through performance improvements, explore more secure and extensible Swift packages, and share advancements in Swift concurrency. We’ll also introduce you to Swift Regex, better generics, and other tools built into the language to help you write more flexible & expressive code."}],"title":"What’s new in Swift","kind":"article","role":"sampleCode","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110354-Whats-new-in-Swift"},"https://github.com/zntfdr":{"url":"https:\/\/github.com\/zntfdr","title":"GitHub","identifier":"https:\/\/github.com\/zntfdr","titleInlineContent":[{"text":"GitHub","type":"text"}],"type":"link"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-10068-Whats-new-in-UIKit":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10068-Whats-new-in-UIKit","role":"sampleCode","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc22-10068-whats-new-in-uikit","kind":"article","title":"What’s new in UIKit","abstract":[{"type":"text","text":"Discover the latest updates and improvements to UIKit and learn how to build better iPadOS, iOS, and Mac Catalyst apps. We’ll take you through UI refinements, productivity updates, API enhancements, and more. We’ll also help you explore improvements to performance, security, and privacy."}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-10082-Track-down-hangs-with-Xcode-and-ondevice-detection":{"title":"Track down hangs with Xcode and on-device detection","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10082-Track-down-hangs-with-Xcode-and-ondevice-detection","abstract":[{"type":"text","text":"Learn how you can increase responsiveness and eliminate hangs in your app and make even better experiences. Hang out with the Performance Tools team as we explore how you can track down these issues — and even stop them from occurring in the first place. We’ll take you through the latest detection mechanisms for iOS to help track hangs during pre-release testing, show you how to identify issues in release builds using the Xcode Organizer, and more."}],"url":"\/documentation\/wwdcnotes\/wwdc22-10082-track-down-hangs-with-xcode-and-ondevice-detection","kind":"article","role":"sampleCode"},"zntfdr.jpeg":{"alt":null,"identifier":"zntfdr.jpeg","variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}],"type":"image"},"zntfdr":{"alt":"Profile image of Federico Zanetello","identifier":"zntfdr","variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10248-Analyze-hangs-with-Instruments":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10248-Analyze-hangs-with-Instruments","kind":"article","abstract":[{"text":"User interface elements often mimic real-world interactions, including real-time responses. Apps with a noticeable delay in user interaction — a hang — can break that illusion and create frustration. We’ll show you how to use Instruments to analyze, understand, and fix hangs in your apps on all Apple platforms. Discover how you can efficiently navigate an Instruments trace document, interpret trace data, and record additional profiling data to better understand your specific hang.","type":"text"}],"title":"Analyze hangs with Instruments","url":"\/documentation\/wwdcnotes\/wwdc23-10248-analyze-hangs-with-instruments","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency":{"role":"sampleCode","kind":"article","title":"Eliminate data races using Swift Concurrency","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","abstract":[{"type":"text","text":"Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We’ll take you through Swift’s approach to eliminating data races and its effect on app architecture. We’ll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system."}],"url":"\/documentation\/wwdcnotes\/wwdc22-110351-eliminate-data-races-using-swift-concurrency"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10134-Explore-structured-concurrency-in-Swift":{"role":"sampleCode","kind":"article","title":"Explore structured concurrency in Swift","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","abstract":[{"type":"text","text":"When you have code that needs to run at the same time as other code, it’s important to choose the right tool for the job. We’ll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We’ll also provide guidance on when you may want to use unstructured tasks."}],"url":"\/documentation\/wwdcnotes\/wwdc21-10134-explore-structured-concurrency-in-swift"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"kind":"article","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","images":[{"type":"card","identifier":"zntfdr.jpeg"},{"type":"icon","identifier":"zntfdr.jpeg"}],"title":"Federico Zanetello (332 notes)","url":"\/documentation\/wwdcnotes\/zntfdr","role":"sampleCode","abstract":[{"type":"text","text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more."}]},"https://wwdcnotes.github.io/WWDCNotes/documentation/wwdcnotes/contributing":{"url":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"type":"link"},"https://zntfdr.dev":{"url":"https:\/\/zntfdr.dev","title":"Blog","identifier":"https:\/\/zntfdr.dev","titleInlineContent":[{"text":"Blog","type":"text"}],"type":"link"}}}