{"kind":"article","hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19"]]},"metadata":{"title":"Making Apps with Core Data","role":"sampleCode","roleHeading":"WWDC19","modules":[{"name":"WWDC Notes"}]},"abstract":[{"text":"Core Data helps manage the flow of data throughout your app. Hear about new features in Core Data that make your code simpler and more powerful, including derived attributes, history tracking, change notifications and batch operations. Learn more about using these facilities and the new diffing APIs in UIKit and Foundation to make your apps run more efficiently.","type":"text"}],"sampleCodeDownload":{"action":{"type":"reference","overridingTitle":"Watch Video (33 min)","isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc19\/230"},"kind":"sampleDownload"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc19-230-making-apps-with-core-data"]}],"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-230-Making-Apps-with-Core-Data","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"minor":3,"major":0},"primaryContentSections":[{"content":[{"type":"heading","text":"Getting started","level":2,"anchor":"Getting-started"},{"type":"aside","name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/synchronizing_a_local_store_to_the_cloud","type":"reference","isActive":true}]}]},{"inlineContent":[{"identifier":"WWDC19-230-demo","type":"image"}],"type":"paragraph"},{"type":"heading","text":"Modeling data","level":2,"anchor":"Modeling-data"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The app has types for posts, media attachments, tags."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Attachments might be large, so we store data separately."}],"type":"paragraph"}]}]},{"inlineContent":[{"identifier":"WWDC19-230-shape","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"Once you define the shape of your data, it is straightforward to translate it into a Core Data model.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC19-230-model"}],"type":"paragraph"},{"inlineContent":[{"text":"Here we define data entities and relationships.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"The relationship between an Attachment and ImageData is one-to-one. Core Data can delete the image data when an attachment is deleted (cascade deletion rule)."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The relationship between an "},{"type":"codeVoice","code":"Post"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Attachment"},{"type":"text","text":" is one-to-many."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The relationship between an ","type":"text"},{"code":"Post","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Tag","type":"codeVoice"},{"text":" is many-to-many.","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","text":"The Core Data stack","level":2,"anchor":"The-Core-Data-stack"},{"inlineContent":[{"type":"image","identifier":"WWDC19-230-stack"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Model: ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nsmanagedobjectmodel","type":"reference","isActive":true}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Persistent store coordinator: ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentstorecoordinator","isActive":true,"type":"reference"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"responsible for managing persistence stores","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"(most of the time) this is a database that lives on the file system"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It’s possible to have many stores at once, including our own custom made types that derive from ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentstore","type":"reference","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The coordinator has to know about the model to make sense of stores"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Managed object context: "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nsmanagedobjectcontext","type":"reference"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"anything that has to do with the store has to go through the context. E.g., create and store objects, perform fetch requests","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"contexts needs to know a coordinator in order to do their work","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"contexts provide us with seamless access to managed data"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Persistent container: "},{"identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentcontainer","isActive":true,"type":"reference"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"While the types above are all sufficiently interdependent, the coordinator provides one type that encapsulates them all and represents the entire stack: the persistent container"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"By using a persistent container, we can set up a stack in just a few lines of code, especially if the model lives in our bundle"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"heading","text":"Setting up the stack","level":3,"anchor":"Setting-up-the-stack"},{"inlineContent":[{"text":"By name:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let container = NSPersistentCloudKitContainer(name: \"CoreDataCloudKitDemo\")","container.loadPersistentStores { _, error in \/* ... *\/ }"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"With a model generated in code:"}],"type":"paragraph"},{"type":"codeListing","code":["let container = NSPersistentCloudKitContainer(name: \"CoreDataCloudKitDemo\", managedObjectModel: model)","container.loadPersistentStores { _, error in \/* ... *\/ }"],"syntax":"swift"},{"type":"heading","text":"Configuring Managed Object Contexts","level":3,"anchor":"Configuring-Managed-Object-Contexts"},{"inlineContent":[{"type":"text","text":"Query generations provide a stable view of the stores data, allowing safe and consistent access to objects, even if they’re changed or deleted by another actor."}],"type":"paragraph"},{"type":"codeListing","code":["try container.viewContext.setQueryGenerationFrom(.current)"],"syntax":"swift"},{"inlineContent":[{"text":"Contexts can be configured to keep themselves up-to-date as changes are saved by their siblings.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["context.automaticallyMergesChangesFromParent = true"],"syntax":"swift"},{"inlineContent":[{"text":"The most important thing to remember when using a context is that all store requests and interactions with managed objects must be done in the context queue.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"There’s a blocking invariant, as well as an asynchronous version of the perform API. The container offers a convenience method for performing background tasks that creates a background context for you.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["context.performAndWait {","    \/* ... *\/","}","context.perform {","    \/* ... *\/","}","container.performBackgroundTask { context in","    \/* ... *\/","}"],"syntax":"swift"},{"type":"heading","text":"Adding data","level":2,"anchor":"Adding-data"},{"inlineContent":[{"type":"text","text":"Use the initializer provided by the managed object subclasses that were generated from the Core Data model by Xcode."}],"type":"paragraph"},{"type":"codeListing","code":["context.perform {","    let post = Post(context: context)","    post.title = \"Hello, world!\"","    try? context.save()","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"To insert objects by the hundreds or thousands, use batch insertions."}],"type":"paragraph"},{"type":"codeListing","code":["let rawPostsData: Data = \/\/ Server response ...","if let postDicts = try? JSONSerialization.jsonObject(with:rawPostsData) as? [[String : Any]] {","    context.perform {","        let insertRequest = NSBatchInsertRequest(entity: Post.entity(), objects: postDicts)","        let insertResult = try? context.execute(insertRequest) as! NSBatchInsertRequest","        let success = insertResult.result as! Bool","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"The keys in the JSON objects need to line up with the names of your attributes in the model.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC19-230-batch","type":"image"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"If you have unique constraints then any existing objects matching the dictionary will be pulled out of the database and updated with new values.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Attributes that are optional or configured with default values can be omitted from the dictionary.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"In the case of updating an object with unique constraint, the existing values will not be changed.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Batch insertions can’t be used to set relationships. But if a batch insert updates an existing object due to a unique constraint, the existing relationships will be left alone.","type":"text"}]}]}]},{"type":"heading","text":"Fetching data","level":2,"anchor":"Fetching-data"},{"type":"heading","text":"Fetching an object","level":3,"anchor":"Fetching-an-object"},{"inlineContent":[{"type":"text","text":"We use a fetch request to get objects out of the store and use it to configure a view."}],"type":"paragraph"},{"type":"codeListing","code":["let fetchRequest : NSFetchRequest<Tag> = Tag.fetchRequest()","","fetchRequest.predicate = NSPredicate(format: \"name = %@\", tagName)","","if let tag = try? fetchRequest.execute().first {","    tagLabel.text = tag.name","    tagLabel.textColor = tag.color as? UIColor","}"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"If the tag’s name or color change, our managed object context will make sure that the objects’ properties get updated.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"To observe those changes use KVO."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The Combine framework makes KVO easier to use in Swift. Check out "},{"isActive":true,"type":"reference","identifier":"..\/721"}],"type":"paragraph"}]}]},{"type":"codeListing","code":["let fetchRequest : NSFetchRequest<Tag> = Tag.fetchRequest()","","fetchRequest.predicate = NSPredicate(format: \"name = %@\", tagName)","","if let tag = try? fetchRequest.execute().first {","    nameSubscription = tag.publisher(for: \\.name)","        .assign(to: \\.text, on: tagLabel)","    ","    colorSubscription = tag.publisher(for: \\.color)","        .map({ $0 as? UIColor })","        .assign(to: \\.textColor, on: tagLabel)","}"],"syntax":"swift"},{"type":"heading","text":"Fetching many objects","level":3,"anchor":"Fetching-many-objects"},{"inlineContent":[{"type":"text","text":"Sort results with sort descriptors."}],"type":"paragraph"},{"type":"codeListing","code":["fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"name\", ascending: true)]"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Batch fetching to avoid filling up memory and keep the app responsive."}],"type":"paragraph"},{"type":"codeListing","code":["fetchRequest.fetchBatchSize = 50"],"syntax":"swift"},{"inlineContent":[{"text":"To monitor changes, use an ","type":"text"},{"code":"NSFetchedResultsController","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let fetchRequest: NSFetchRequest<Post> = Post.fetchRequest()","fetchRequest.sortDescriptors = [NSSortDescriptor(key: \"title\", ascending: true)]","fetchRequest.fetchBatchSize = 50","","let controller = NSFetchedResultsController(fetchRequest: fetchRequest,","    managedObjectContext: moc,","    sectionNameKeyPath: nil, cacheName: nil)","","controller.delegate = self try! controller.performFetch()","try! controller.performFetch()"],"syntax":"swift"},{"inlineContent":[{"text":"A fetched results controller communicates changes to a fetch requests through a delegate protocol.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["controllerWillChangeContent(:)","controller(:didChange:atSectionIndex:for:)","controller(:didChange:at:for:newIndexPath:)","controllerDidChangeContent(:)"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"There is also a delegate method that vends an instance of "},{"code":"NSDiffableDataSourceSnapshot","type":"codeVoice"},{"type":"text","text":", which you can use with a "},{"code":"DiffableDataSource","type":"codeVoice"},{"type":"text","text":" for a table view. Check "},{"isActive":true,"type":"reference","identifier":"..\/220"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","code":["func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,","    didChangeContentWith snapshot: NSDiffableDataSourceSnapshotReference<NSManagedObjectID, NSString> ) {","        collectionViewDataSource.applySnapshot(snapshot as! NSDiffableDataSourceSnapshot)","}",""],"syntax":"swift"},{"inlineContent":[{"text":"There is also a delegate method that gives you a summary of all the changes to the fetched results in one shot.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"It returns a "},{"type":"codeVoice","code":"CollectionDifference"},{"type":"text","text":", which encodes the difference between two collections."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Introduced in "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/master\/proposals\/0240-ordered-collection-diffing.md"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"text":"Check ","type":"text"},{"isActive":true,"identifier":"..\/723","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}]}]},{"type":"codeListing","code":["func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,","    didChangeContentWith diff: CollectionDifference<NSManagedObjectID>) {","    collectionView.performBatchUpdates({","        for change in diff {","            switch change {","            case .insert(offset: let newRow, element: _, associatedWith: let assoc):","                if let oldRow = assoc {","                    collectionView.moveItem(","                        at: IndexPath(row: oldRow, section: frcSection),","                        to: IndexPath(row: newRow, section: frcSection))","                } else {","                    collectionView.insertItems(","                        at: [IndexPath(row: newRow, section: frcSection)])","                }","            case .remove(offset: let oldRow, element: _, associatedWith: let assoc):","                if assoc == nil {","                    collectionView.deleteItems(","                        at: [IndexPath(row: oldRow, section: frcSection)])","                }","\t    \t}","        }","\t}, completion: nil)","}"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We start by kicking off a batch update, and looping over the changes in the diff."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"CollectionDifferences"},{"type":"text","text":" supports two kinds of changes, Insert and Remove which may refer to each other through association."}]}]},{"content":[{"inlineContent":[{"text":"In the first case, we have an insertion that has an associated removal.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In the second case, we have an insert of an object that was not previously part of the fetched results. So we tell the "},{"type":"codeVoice","code":"CollectionView"},{"type":"text","text":" to add it."}]}]},{"content":[{"inlineContent":[{"text":"Finally, we match all removes that weren’t part of an associated move by filtering for new associations, and then remove those from the ","type":"text"},{"code":"CollectionView","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","text":"Denormalization","level":2,"anchor":"Denormalization"},{"inlineContent":[{"text":"In some cases data can difficult to fetch.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"You might be unable to build a fetch request.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"You might end up with performance problems.","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"At a certain point, you need to give up some modeling purity in order to accomplish your goals. You do that with denormalization.","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"keep copies of your data, so access can be more efficient.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"This comes with the price of some additional overhead maintaining that extra data. But there are many of circumstances where this tradeoff is a no-brainer.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Databases indexes are a good example.","type":"text"}]}]}]},{"inlineContent":[{"type":"text","text":"Check "},{"type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/224","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC19-230-denormalization","type":"image"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Derived attributes are normalized metadata that’s maintained for you by Core Data."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Derived attributes are defined in the managed object model. The Model Editor in Xcode has an interface for it.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"You can define derived attributes in code using ","type":"text"},{"code":"NSDerivedAttributeDescription","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Derivation expressions can refer to any of the properties of an entity, one level deep."}]}]}]},{"inlineContent":[{"text":"Supported derivations available:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Outright duplication, e.g., keeping a copy of an attachments identifier and the image data that backs it.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Simple transformation of fields, e.g., such as lower casing a tag’s name, or canonicalizing some Unicode string."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Aggregate function across a too many relationship. Example above."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Global functions that take no parameters. Useful for things like keeping track of when an object was last updated.","type":"text"}]}]}]},{"type":"heading","text":"Scaling your app","level":2,"anchor":"Scaling-your-app"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"PersistentHistory","type":"codeVoice"},{"text":" is a tool to process data added by an importer, or maintain data consistency across multiple active coordinators that are using the same store","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Fetch requests to make it easier to look up only the history you’re interested in."}],"type":"paragraph"}]}]},{"type":"codeListing","code":["class func entityDescription(withContext context: NSManagedObjectContext) -> NSEntityDescription?","class var entityDescription: NSEntityDescription? { get }","class var fetchRequest: NSFetchRequest? { get }"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"NSPersistentHistoryTransaction"},{"type":"text","text":" and "},{"type":"codeVoice","code":"NSPersistentHistoryChange"},{"type":"text","text":" have cross-methods to work with fetch requests."}]}]},{"content":[{"inlineContent":[{"text":"These include accessories for an entity description corresponding to the type and a method that produces a new preconfigured fetch requests that will return instances of the type when executed.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"You configure the fetch request to the predicate which gets used as part of a "},{"code":"PersistentHistoryRequest","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]}]},{"type":"codeListing","code":["open class NSPersistentHistoryChangeRequest : NSPersistentStoreRequest {","    open class func fetchHistory(withFetch fetchRequest: NSFetchRequest<NSFetchRequestResult>) -> Self","    open var fetchRequest: NSFetchRequest<NSFetchRequestResult>?","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"There’s a new convenience initializer on "},{"type":"codeVoice","code":"NSPersistentHistoryChangeRequest"},{"type":"text","text":" for creating a new instance with a fetch request, as well as immutable property you can use for post-talk configuration."}],"type":"paragraph"},{"type":"heading","text":"Remote change notifications","level":3,"anchor":"Remote-change-notifications"},{"inlineContent":[{"type":"text","text":"Cross-coordinator change notifications. To turn them on, there’s a new "},{"type":"codeVoice","code":"PersistentStore"},{"type":"text","text":" option called "},{"type":"codeVoice","code":"NSPersistentStoreRemoteChangeNotificationPostOptionKey"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"codeListing","code":["let description: NSPersistentStoreDescription = \/* ... *\/","description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)","description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Set it in your store description before loading the ","type":"text"},{"code":"PersistentStore","type":"codeVoice"},{"text":", and the coordinator will listen for remote changes.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"It also tells the coordinator to send remote change notifications whenever it makes any changes."}],"type":"paragraph"}]}]},{"type":"codeListing","code":["func storeRemoteChange(_ notification: Notification) {","    precondition(notification.name == NSNotification.Name.NSPersistentStoreRemoteChange)","    let storeURL = notification.userInfo?[NSPersistentStoreURLKey]!","    let token = notification.userInfo?[NSPersistentHistoryTokenKey]!","    print(\"Store at \\(storeURL) was changed in transaction \\(token).\")","}"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Remote change notifications tell you which store changed with the ","type":"text"},{"type":"codeVoice","code":"NSPersistentStoreURL"},{"text":" key in the user info dictionary.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"If you have "},{"code":"PersistentHistory","type":"codeVoice"},{"type":"text","text":" enabled, it also includes the new history token created by that transaction."}],"type":"paragraph"}]}]},{"inlineContent":[{"text":"Because remote change notifications work kind of like push notifications, sometimes changes make it collapse together if there are many at once. And only the last would get delivered.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To get the current ","type":"text"},{"code":"PersistentHistory","type":"codeVoice"},{"text":" token there is a method on the persistent store coordinator.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension NSPersistentStoreCoordinator {","    func currentPersistentHistoryToken(from stores: [NSPersistentStore]?) -> NSPersistentHistoryToken?","}"],"syntax":"swift"},{"type":"heading","text":"Testing","level":2,"anchor":"Testing"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Know what your performance goals are. A Contacts app should be testing with at least tens of thousands of objects. The Photos app should be testing millions of objects."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Integration tests should also get running configurations optimized for detecting and surfacing other kinds. For applications using Core Data, that should include the Framework’s built-in concurrency debugging."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Use in-memory stores when test runtime is important, specifically the SQLiteStores in-memory mode."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the address sanitizer, thread sanitizer, and undefined behavior sanitizer."}]}]}]},{"type":"codeListing","code":["let container = NSPersistentCloudKitContainer(name: \"CoreDataCloudKitDemo\")","let description = container.persistentStoreDescriptions.first!","description.url = URL(fileURLWithPath: \"\/dev\/null\")","container.loadPersistentStores(completionHandler: { (_, error) in","    guard let error = error as NSError? else { return }","    fatalError(\"###\\(#function): Failed to load persistent stores:\\(error)\")","})"],"syntax":"swift"},{"type":"heading","text":"Written By","level":2,"anchor":"Written-By"},{"numberOfColumns":5,"type":"row","columns":[{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"matteom"}]}],"size":1},{"content":[{"text":"Matteo Manferdini","level":3,"type":"heading","anchor":"Matteo-Manferdini"},{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/matteom","isActive":true,"type":"reference","overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"overridingTitle":"Contributed Notes"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/matteom","isActive":true,"type":"reference"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"http:\/\/matteomanferdini.com","isActive":true,"type":"reference"}]}],"size":4}]},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference"}],"type":"paragraph"},{"type":"heading","text":"Related Sessions","level":2,"anchor":"Related-Sessions"},{"type":"links","style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10017-Core-Data-Sundries-and-maxims","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-202-Using-Core-Data-With-CloudKit","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-220-Advances-in-UI-Data-Sources","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-231-Integrating-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-419-Optimizing-Storage-in-Your-App"]},{"inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}],"type":"small"}],"kind":"content"}],"sections":[],"references":{"https://github.com/apple/swift-evolution/blob/master/proposals/0240-ordered-collection-diffing.md":{"title":"Swift Evolution Proposal 240","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/master\/proposals\/0240-ordered-collection-diffing.md","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/master\/proposals\/0240-ordered-collection-diffing.md","type":"link","titleInlineContent":[{"type":"text","text":"Swift Evolution Proposal 240"}]},"WWDC19-Icon.png":{"identifier":"WWDC19-Icon.png","variants":[{"url":"\/images\/WWDC19-Icon.png","traits":["1x","light"]}],"alt":null,"type":"image"},"../723":{"title":"Advances in Foundation","identifier":"..\/723","url":"..\/723","type":"link","titleInlineContent":[{"type":"text","text":"Advances in Foundation"}]},"https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext":{"title":"NSManagedObjectContext","identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nsmanagedobjectcontext","url":"https:\/\/developer.apple.com\/documentation\/coredata\/nsmanagedobjectcontext","type":"link","titleInlineContent":[{"code":"NSManagedObjectContext","type":"codeVoice"}]},"WWDC19-230-model":{"identifier":"WWDC19-230-model","variants":[{"url":"\/images\/WWDC19-230-model.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://developer.apple.com/documentation/coredata/nspersistentstorecoordinator":{"title":"NSPersistentStoreCoordinator","identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentstorecoordinator","url":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentstorecoordinator","type":"link","titleInlineContent":[{"code":"NSPersistentStoreCoordinator","type":"codeVoice"}]},"WWDC19-230-demo":{"identifier":"WWDC19-230-demo","variants":[{"url":"\/images\/WWDC19-230-demo.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://developer.apple.com/wwdc19/230":{"identifier":"https:\/\/developer.apple.com\/wwdc19\/230","checksum":null,"url":"https:\/\/developer.apple.com\/wwdc19\/230","type":"download"},"matteom":{"identifier":"matteom","variants":[{"url":"\/images\/matteom.jpeg","traits":["1x","light"]}],"alt":"Profile image of Matteo Manferdini","type":"image"},"../220":{"title":"Advances in UI Data Sources","identifier":"..\/220","url":"..\/220","type":"link","titleInlineContent":[{"type":"text","text":"Advances in UI Data Sources"}]},"WWDC19.jpeg":{"identifier":"WWDC19.jpeg","variants":[{"url":"\/images\/WWDC19.jpeg","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10017-Core-Data-Sundries-and-maxims":{"abstract":[{"type":"text","text":"Core Data is the central way to durably and persistently store information from your app — and we’re going to show you how to refine that implementation for even faster data ingest and fetching. Discover how you can improve data capture with batch insert, tailor fetch requests to your data needs, and react to notifications about changes in the persistent store."}],"role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10017-Core-Data-Sundries-and-maxims","kind":"article","title":"Core Data: Sundries and maxims","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc20-10017-core-data-sundries-and-maxims"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}],"alt":null,"type":"image"},"WWDC19-230-denormalization":{"identifier":"WWDC19-230-denormalization","variants":[{"url":"\/images\/WWDC19-230-denormalization.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://developer.apple.com/documentation/coredata/nspersistentcontainer":{"title":"NSPersistentContainer","identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentcontainer","url":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentcontainer","type":"link","titleInlineContent":[{"code":"NSPersistentContainer","type":"codeVoice"}]},"matteom.jpeg":{"identifier":"matteom.jpeg","variants":[{"url":"\/images\/matteom.jpeg","traits":["1x","light"]}],"alt":null,"type":"image"},"https://developer.apple.com/documentation/coredata/nsmanagedobjectmodel":{"title":"NSManagedObjectModel","identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nsmanagedobjectmodel","url":"https:\/\/developer.apple.com\/documentation\/coredata\/nsmanagedobjectmodel","type":"link","titleInlineContent":[{"code":"NSManagedObjectModel","type":"codeVoice"}]},"http://matteomanferdini.com":{"title":"Blog","identifier":"http:\/\/matteomanferdini.com","url":"http:\/\/matteomanferdini.com","type":"link","titleInlineContent":[{"type":"text","text":"Blog"}]},"https://github.com/matteom":{"title":"GitHub","identifier":"https:\/\/github.com\/matteom","url":"https:\/\/github.com\/matteom","type":"link","titleInlineContent":[{"type":"text","text":"GitHub"}]},"https://developer.apple.com/videos/play/wwdc2018/224":{"title":"Core Data Best Practices","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/224","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2018\/224","type":"link","titleInlineContent":[{"type":"text","text":"Core Data Best Practices"}]},"WWDC19-230-shape":{"identifier":"WWDC19-230-shape","variants":[{"url":"\/images\/WWDC19-230-shape.png","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes":{"images":[{"type":"icon","identifier":"WWDCNotes.png"}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","title":"WWDC Notes","kind":"symbol","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"url":"\/documentation\/wwdcnotes","role":"collection"},"doc://WWDCNotes/documentation/WWDCNotes/matteom":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/matteom","url":"\/documentation\/wwdcnotes\/matteom","images":[{"type":"card","identifier":"matteom.jpeg"},{"type":"icon","identifier":"matteom.jpeg"}],"role":"sampleCode","abstract":[{"text":"I teach Swift and iOS Development Best Practices","type":"text"}],"title":"Matteo Manferdini (1 note)","kind":"article"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-202-Using-Core-Data-With-CloudKit":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-202-Using-Core-Data-With-CloudKit","abstract":[{"type":"text","text":"CloudKit offers powerful, cloud-syncing technology while Core Data provides extensive data modeling and persistence APIs. Learn about combining these complementary technologies to easily build cloud-backed applications. See how new Core Data APIs make it easy to manage the flow of data through your application, as well as in and out of CloudKit. Join us to learn more about combining these frameworks to provide a great experience across all your customers’ devices."}],"type":"topic","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc19-202-using-core-data-with-cloudkit","role":"sampleCode","title":"Using Core Data With CloudKit"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-419-Optimizing-Storage-in-Your-App":{"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-419-Optimizing-Storage-in-Your-App","url":"\/documentation\/wwdcnotes\/wwdc19-419-optimizing-storage-in-your-app","title":"Optimizing Storage in Your App","type":"topic","role":"sampleCode","abstract":[{"text":"How you store data in your app affects not only disk footprint, but also the performance of your app and the battery life of the device. Learn techniques for optimizing data serialization, working with images, and syncing to disk. Find out how to take advantage of features in SQLite to improve performance and safety.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19":{"url":"\/documentation\/wwdcnotes\/wwdc19","role":"collectionGroup","kind":"article","title":"WWDC19","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19","abstract":[{"text":"Xcode 11, Swift 5.1, iOS 13, macOS 10.15 (Catalina), tvOS 13, watchOS 6.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"Combine","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Core Haptics","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Create ML"},{"type":"text","text":", and more."}],"images":[{"type":"icon","identifier":"WWDC19-Icon.png"},{"type":"card","identifier":"WWDC19.jpeg"}],"type":"topic"},"WWDC19-230-batch":{"identifier":"WWDC19-230-batch","variants":[{"url":"\/images\/WWDC19-230-batch.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://developer.apple.com/documentation/coredata/nspersistentstore":{"title":"NSPersistentStore","identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentstore","url":"https:\/\/developer.apple.com\/documentation\/coredata\/nspersistentstore","type":"link","titleInlineContent":[{"code":"NSPersistentStore","type":"codeVoice"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-231-Integrating-SwiftUI":{"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc19-231-integrating-swiftui","type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-231-Integrating-SwiftUI","abstract":[{"type":"text","text":"SwiftUI is designed to integrate with your existing code base on any of Apple’s platforms. Learn how to adopt SwiftUI on any Apple platform by adding SwiftUI views into your app’s hierarchy, leveraging your existing data model and more."}],"title":"Integrating SwiftUI"},"https://developer.apple.com/documentation/coredata/synchronizing_a_local_store_to_the_cloud":{"title":"Sample app: Creating blog posts with tags","identifier":"https:\/\/developer.apple.com\/documentation\/coredata\/synchronizing_a_local_store_to_the_cloud","url":"https:\/\/developer.apple.com\/documentation\/coredata\/synchronizing_a_local_store_to_the_cloud","type":"link","titleInlineContent":[{"type":"text","text":"Sample app: Creating blog posts with tags"}]},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"title":"Contributions are welcome!","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}]},"../721":{"title":"Combine in Practice","identifier":"..\/721","url":"..\/721","type":"link","titleInlineContent":[{"type":"text","text":"Combine in Practice"}]},"WWDC19-230-stack":{"identifier":"WWDC19-230-stack","variants":[{"url":"\/images\/WWDC19-230-stack.png","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-220-Advances-in-UI-Data-Sources":{"title":"Advances in UI Data Sources","url":"\/documentation\/wwdcnotes\/wwdc19-220-advances-in-ui-data-sources","kind":"article","role":"sampleCode","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-220-Advances-in-UI-Data-Sources","abstract":[{"type":"text","text":"Use UI Data Sources to simplify updating your table view and collection view items using automatic diffing. High fidelity, quality animations of set changes are automatic and require no extra code! This improved data source mechanism completely avoids synchronization bugs, exceptions, and crashes! Learn about this simplified data model that uses on identifiers and snapshots so that you can focus on your app’s dynamic data and content instead of the minutia of UI data synchronization."}]}}}