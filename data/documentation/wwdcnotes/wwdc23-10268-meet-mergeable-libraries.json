{"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc23-10268-meet-mergeable-libraries"]}],"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10268-Meet-mergeable-libraries"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"]]},"seeAlsoSections":[{"generated":true,"title":"New Tools & Frameworks","identifiers":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10082-Meet-ARKit-for-spatial-computing","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10184-Meet-ActivityKit","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10032-Meet-Assistive-Access","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10147-Meet-Core-Location-Monitor","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10146-Meet-Core-Location-for-spatial-computing","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10043-Meet-MapKit-for-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10191-Meet-Object-Capture-for-iOS","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10025-Meet-Push-Notifications-Console","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10083-Meet-Reality-Composer-Pro","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10099-Meet-RealityKit-Trace","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10279-Meet-Safari-for-spatial-computing","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10013-Meet-StoreKit-for-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10171-Meet-Swift-OpenAPI-Generator","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10187-Meet-SwiftData","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10109-Meet-SwiftUI-for-spatial-computing","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-111215-Meet-UIKit-for-spatial-computing","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10039-Meet-device-management-for-Apple-Watch","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10026-Meet-watchOS-10"]}],"metadata":{"roleHeading":"WWDC23","title":"Meet mergeable libraries","role":"sampleCode","modules":[{"name":"WWDC Notes"}]},"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","anchor":"overview","text":"Overview"},{"type":"aside","content":[{"inlineContent":[{"type":"text","text":"Mergeable Libraries is a new model for building and distributing libraries powered by the static linker"}],"type":"paragraph"}],"name":"Note","style":"note"},{"type":"heading","level":2,"anchor":"Static-vs-Dynamic-libraries","text":"Static vs Dynamic libraries"},{"type":"heading","level":3,"anchor":"Static-libraries","text":"Static libraries:"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Static libraries are a collection of object files.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"At build time, the static linker finds which APIs to use from those libraries"},{"type":"text","text":" "},{"type":"text","text":"and copies that code into the app binary -> since it’s copied, "},{"inlineContent":[{"type":"text","text":"the library isn’t needed after building"}],"type":"emphasis"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Build time slowdown if code in static libraries changes or if more libraries are used -> makes iterative building and debugging slower.","type":"text"}]}]}]},{"type":"heading","level":3,"anchor":"Dynamic-libraries-dylibs","text":"Dynamic libraries (dylibs)"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"They are the binary file type for framework targets in Xcode."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Faster builds -> the static linker does not need to copy code","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"The static linker records the installed path of the library into the app binary for later","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Any frameworks not in the Apple SDK must be embedded into the app bundle. This leads an increase in memory consumption and app launch time because generally, we have hundreds of frameworks.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10268-static-vs-dynamic","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"When an app is launched, the dynamic linker named dyld must find and load framework dependencies including libraries those frameworks depend on. As more are used, this results in a steady increase in memory consumption and app launch time","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And when you factor in dependencies from the Apple SDK, apps can often load hundreds of frameworks. Our platforms have heavily optimized system libraries to account for this but this doesn’t apply to frameworks that get embedded in apps."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10268-dynamic-linking","type":"image"}]},{"type":"heading","level":3,"anchor":"Recap","text":"Recap"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"There are some tradeoffs when deciding between using static and dynamic libraries."},{"type":"text","text":" "},{"type":"text","text":"While dynamic libraries have little impact on build time but noticeable launch time consequences, static libraries provide minimal launch time impact but are costly on build time"}]}],"name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"text":"Due to this, we have historically recommended measuring what’s best for your app. With mergeable libraries, this is no longer needed because","type":"text"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"text":"mergeable libraries unlock the best of both linking strategies","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10268-sweet-spot"}]},{"type":"heading","level":2,"anchor":"Meet-mergeable-libraries-how-mergeable-libraries-work-to-make-your-apps-build-and-run-faster","text":"Meet mergeable libraries: how mergeable libraries work to make your apps build and run faster."},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Any dynamic library can be built as mergeable."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Consider any binary image (like an executable) and the frameworks this binary depends on are given to the static linker. These dependencies can become ","type":"text"},{"inlineContent":[{"text":"mergeable libraries","type":"text"}],"type":"strong"},{"text":" and the linked output can become the ","type":"text"},{"inlineContent":[{"text":"merged binary","type":"text"}],"type":"strong"},{"text":".","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Static linker generates ","type":"text"},{"inlineContent":[{"type":"text","text":"metadata"}],"type":"strong"},{"text":" when creating the library (use option -make_mergeable). The metadata is within the binary, increasing its overall size. It allows the linker to treat the library similarly to a static library when it’s used as a link dependency.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With the metadata, users of the library can choose to statically link as normal dynamic libraries or merge them."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The merged binary output can be an executable, like an app, or another dynamic library, like a framework."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Merging is comparable to how static libraries get linked. In the end, you’re left with a ","type":"text"},{"inlineContent":[{"text":"binary that contains the segments of the libraries","type":"text"}],"type":"strong"},{"text":". And that output binary remains the same file type (-merge_library or -merge_framework).","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10268-mergeable-libraries","type":"image"}]},{"type":"heading","level":3,"anchor":"But-how-is-merging-better-than-just-linking","text":"But how is merging better than just linking?"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Smaller overall app bundle","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Metadata isn’t needed and can be removed after they’ve been merged","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The linker can de-duplicate content (it removes redundant symbol references**, Objective-C selectors, and objc_msgsend stubs)"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The image type of the final binary remains the same too. That means any already supported linker optimizations can be applied."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Positive impact on app launch because fewer frameworks are loaded"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reduces the work dyld and the kernel need to do when launching your app"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Reduces memory usage","type":"text"}]}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"text":"Mergeable libraries make this possible with minimal code and configuration changes. And this scales nicely as you adopt newer frameworks.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Let’s revisit the earlier diagram about dynamic linking. All of these embedded frameworks can become mergeable since the linker can generate metadata for them.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can create a framework that merges the contents of the other libraries. So you end up with "},{"inlineContent":[{"text":"only one framework to embed","type":"text"}],"type":"strong"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"Dyld only needs to load that one library containing all segments across the embedded frameworks. Merging, in this way, can greatly simplify large dependency chains.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10268-mergeable-libraries-2"}]},{"type":"heading","level":2,"anchor":"Using-mergeable-libraries-how-to-enable-mergeable-libraries-in-Xcode-15","text":"Using mergeable libraries: how to enable mergeable libraries in Xcode 15"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two ways to enable library merging in Xcode."}]},{"type":"heading","level":3,"anchor":"Automatic-merging","text":"Automatic merging"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Merge all direct dependencies that are embedded framework targets"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Works well on app targets","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Libraries link directly into app binary -> similar launch time performance to static libraries"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With Automatic merging the three forest frameworks will become mergeable (except SwiftUI since it’s a system library)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"These frameworks will be merged directly into the app binary. These frameworks won’t be needed at launch and can be removed from disk"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To enable Automatic merging inside Xcode 15 go to Build Settings, search for MERGED_BINARY_TYPE and change “Create Merged Binary” to “Automatic”. The section with these settings is called “Linking - Mergeable Libraries”."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"The exports of mergeable libraries are preserved in the app","type":"text"}]},{"type":"text","text":". It’s often not applicable that apps export symbols and it negatively impacts the size and build time. To prevent this, use the linker option -no_exported_symbols. This can be applied in Xcode by updating “Other Linker Flags” with “-Wl, -no_exported_symbols.”"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10268-automatic"}]},{"type":"heading","level":3,"anchor":"Manual-Merging","text":"Manual Merging"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Fine-grained approach to specifying the libraries to merge (when only some of your frameworks should be merged together)."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When some dependencies need to stay in the app bundle."}]}]}]},{"type":"paragraph","inlineContent":[{"text":"It is enabled by setting MERGED_BINARY_TYPE = manual on the overarching target. The libraries that should make up the final merged product are recognized by setting MERGEABLE_LIBRARY to YES and for libraries that should stay on disk, keep the default setting of MERGEABLE_LIBRARY to NO.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Consider now we have a XCTest target that depends on the Forest framework too; another example is when we have targets like app extensions that create a similar-looking dependency graph."}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"First I’ll isolate the app dependencies for the three Forest frameworks."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Then I’ll create a framework, ForestKit, that merges the libraries but will also satisfy my test dependency. ForestKit is considered a group library because it’ll encapsulate the mergeable libraries both my app and tests depend on."}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Click on “+” on XCode 15 above Targets section and select Framework template under macOS tab.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Under Link Binary With Libraries, add all the three frameworks"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Go to Build Setting, “Create Merged Binary” and set the value to Manual","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"As I’m enabling manual mode, I’ll need to explicitly set which frameworks to make mergeable (ForestBuilder, ForestUI, and Forest).","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For each framework I want to merge, go to the framework target, select Build Setting and set Build Mergeable Library to YES."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"These dependencies will be merged inside ForestKit","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10268-manual","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"I’m finished creating my merged ForestKit framework. But I need to update some dependencies. Because I’ve created a framework that encapsulates most of my dynamic libraries, I need to ensure my app and "},{"inlineContent":[{"type":"text","text":"tests link against ForestKit and not the others"}],"type":"strong"},{"type":"text","text":"."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Go inside the project target, select Build Phases and under “Link Binary with Libraries” remove the three frameworks and leave only the ForestKit. Do the same with the text target and add ForestKit if not present.","type":"text"}]}]}]},{"type":"heading","level":2,"anchor":"Debug-Mode","text":"Debug Mode"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Only during the release mode the libraries are merged then removed from disk"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"This prevents the build time overhead due to the merge when we are developing(like the static library)","type":"text"}]}]}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"To support iterative development in Xcode, the linker will not merge in debug mode","type":"text"}],"type":"strong"},{"text":". The build system tells the linker to re-export the libraries instead. Reexporting is a linker option that allows the implementation of code to live in one dynamic library but has it show up as if it’s implemented in another.","type":"text"}]}],"name":"Note","style":"note"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"In other words, this means all of the libraries’ APIs are reachable by just depending on the merged target, like your app extensions or tests.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This results in a similar build time benefit as with dynamic libraries."}]}]}]},{"type":"heading","level":3,"anchor":"Symbolication","text":"Symbolication"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Symbolication is the process of associating these machine instructions back to the original source code. This is useful to be able to understand crash logs or to profile and debug your code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"How does this work with merged binaries?"}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"When you enable merging, source location information is still preserved from the original library. ","type":"text"},{"type":"strong","inlineContent":[{"text":"That means your debugging experience remains the same","type":"text"}]},{"text":". But keep in mind, when library information is displayed, like for stack traces, it will ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"show the path to the merged binary"}]},{"text":". This information is presented in crash logs, inside Instruments, and in the debugger.","type":"text"}]}],"name":"Note","style":"note"},{"type":"heading","level":3,"anchor":"Considerations-for-mergeable-libraries-considerations-and-what-we-recommend-when-using-mergeable-libraries","text":"Considerations for mergeable libraries: considerations and what we recommend when using mergeable libraries"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Mergeable libraries as dependencies"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If some dependencies are not merged and they point to the merged framework, they need to update to depend on the merged framework, because mergeable ones are removed from disk."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Autolinking with mergeable libraries","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Autolinking finds frameworks from module imports; so if you’re importing a module from a mergeable library, ","type":"text"},{"inlineContent":[{"type":"text","text":"this could cause dynamic linking issues"}],"type":"strong"},{"text":". The solution is not to disable autolinking but link against the merged framework.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Go to the project target, select Build Phase and add in the “Link Binary with Libraries” and remove the mergeable ones if it’s there already."}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"APIs for runtime lookup"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you use dynamic linking APIs like dlopen, those input paths will also need to point to the merged framework target."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The new static linker","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Similarly, resource lookup could be impacted by library merging. This is because bundle is an API to have the runtime load a framework’s bundle.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Prior to iOS 12, framework binary was needed for lookup. In iOS 12, a hook was added to enable lookup for this scenario, so you rely on bundle lookup support. So your project must have iOS 12+ target in order to use mergeable libraries."}]},{"type":"paragraph","inlineContent":[{"text":"You can disable with a linker option -no_merged_libraries_hook. Add this option anyway to improve launch time performance.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside the toolchain there are two static linkers (new and old linking). The older linker is still supported for backwards compatibility. New linker doesn not support armv7k so the minimum deployment target is watchOS 9+."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Distributing frameworks","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can ship a mergeable library by creating an XCFramework in the Swift Package Manager or in Xcode. This allows you to build the framework including its metadata for distribution. When other developers use the framework, they can decide whether to enable merging.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Mergeable metadata roughly doubles the size of the dylib. This doesn’t impact the size of an app because metadata is discarded along with the mergeable library after building the app. Otherwise, that metadata does get stripped to prevent bloat when embedding them in apps."}]}]}]},{"type":"heading","level":3,"anchor":"Recommendations","text":"Recommendations"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Link against merged target throughout the project","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Update input in script phases to the merged binary","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Link any mergeable libraries into merged binary","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Metatada is stripped if not merged","type":"text"}],"type":"paragraph"}]}]},{"type":"heading","level":3,"anchor":"Wrap-up","text":"Wrap-up"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Mergeable libraries offer convenience and flexibility."}]}]},{"content":[{"inlineContent":[{"text":"With automatic and manual workflows, you can restructure and add mergeable libraries at your leisure and leave the necessary ones on disk.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can gradually adopting or profiling."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Ensure all dependents of those libraries are relying on the merged binary instead of the libraries that get removed."}],"type":"paragraph"}]}]},{"type":"aside","content":[{"inlineContent":[{"type":"text","text":"Mergeable libraries offer size, build, and runtime improvements when applied to framework and executable targets."}],"type":"paragraph"}],"name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"text":"For documentation about mergeable libraries, review ","type":"text"},{"inlineContent":[{"text":"“Configuring your project to use mergeable libraries.”","type":"text"}],"type":"emphasis"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And to learn more about static and dynamic linking, check out the session "},{"type":"emphasis","inlineContent":[{"type":"text","text":"“Link fast: Improve build and launch times.”"}]}]},{"type":"heading","level":2,"anchor":"Written-By","text":"Written By"},{"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"type":"image","identifier":"https:\/\/avatars.githubusercontent.com\/u\/49726419?v=4"}],"type":"paragraph"}]},{"size":4,"content":[{"type":"heading","anchor":"Marco-La-Gala","text":"Marco La Gala","level":3},{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/marcolg97","overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"overridingTitle":"Contributed Notes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/marcolg97","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/","type":"reference"}],"type":"paragraph"}]}],"numberOfColumns":5},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","isActive":true}]},{"type":"heading","level":2,"anchor":"Related-Sessions","text":"Related Sessions"},{"type":"links","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110362-Link-fast-Improve-build-and-launch-times"],"style":"list"},{"type":"small","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Legal Notice"}]}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"type":"text","text":"Discover how mergeable libraries combine the best parts of static and dynamic libraries to help improve your app’s productivity and runtime performance. Learn how you can enable faster development while shipping the smallest app. We’ll show you how to adopt mergeable libraries in Xcode 15 and share best practices for working with your code."}],"sampleCodeDownload":{"kind":"sampleDownload","action":{"isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc23\/10268","overridingTitle":"Watch Video (26 min)","type":"reference"}},"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10013-Meet-StoreKit-for-SwiftUI":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10013-Meet-StoreKit-for-SwiftUI","url":"\/documentation\/wwdcnotes\/wwdc23-10013-meet-storekit-for-swiftui","role":"sampleCode","kind":"article","title":"Meet StoreKit for SwiftUI","abstract":[{"text":"Discover how you can use App Store product metadata and Xcode Previews to add in-app purchases to your app with just a few lines of code. Explore a new collection of UI components in StoreKit and learn how you can easily merchandise your products, present subscriptions in a way that helps users make informed decisions, and more.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10099-Meet-RealityKit-Trace":{"abstract":[{"type":"text","text":"Discover how you can use RealityKit Trace to improve the performance of your spatial computing apps. Explore performance profiling guidelines for this platform and learn how the RealityKit Trace template can help you optimize rendering for your apps. We’ll also provide guidance on profiling various types of content in your app to help pinpoint performance issues."}],"kind":"article","role":"sampleCode","title":"Meet RealityKit Trace","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc23-10099-meet-realitykit-trace","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10099-Meet-RealityKit-Trace"},"https://":{"titleInlineContent":[{"text":"Blog","type":"text"}],"title":"Blog","identifier":"https:\/\/","type":"link","url":"https:\/\/"},"WWDC23-10268-automatic":{"variants":[{"url":"\/images\/WWDC23-10268-automatic.png","traits":["1x","light"]}],"identifier":"WWDC23-10268-automatic","alt":"Static vs Dynamic libraries","type":"image"},"https://developer.apple.com/wwdc23/10268":{"identifier":"https:\/\/developer.apple.com\/wwdc23\/10268","checksum":null,"type":"download","url":"https:\/\/developer.apple.com\/wwdc23\/10268"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10279-Meet-Safari-for-spatial-computing":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10279-Meet-Safari-for-spatial-computing","url":"\/documentation\/wwdcnotes\/wwdc23-10279-meet-safari-for-spatial-computing","role":"sampleCode","kind":"article","title":"Meet Safari for spatial computing","abstract":[{"text":"Discover the web for visionOS and learn how people can experience your web content in a whole new way. Explore the unique input model powering this platform and learn how you can optimize your website for spatial computing. We’ll also share how emerging standards are helping shape 3D experiences for the web.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10032-Meet-Assistive-Access":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10032-Meet-Assistive-Access","url":"\/documentation\/wwdcnotes\/wwdc23-10032-meet-assistive-access","role":"sampleCode","kind":"article","title":"Meet Assistive Access","abstract":[{"text":"Learn how Assistive Access can help people with cognitive disabilities more easily use iPhone and iPad. Discover the design principles that guide Assistive Access and find out how the system experience adapts to lighten cognitive load. We’ll show you how Assistive Access works and what you can do to support this experience in your app.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-111215-Meet-UIKit-for-spatial-computing":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-111215-Meet-UIKit-for-spatial-computing","url":"\/documentation\/wwdcnotes\/wwdc23-111215-meet-uikit-for-spatial-computing","role":"sampleCode","kind":"article","title":"Meet UIKit for spatial computing","abstract":[{"text":"Learn how to bring your UIKit app to visionOS. We’ll show you how to build for a new destination, explore APIs and best practices for spatial computing, and take your content into the third dimension when you use SwiftUI with UIKit in visionOS.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10109-Meet-SwiftUI-for-spatial-computing":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10109-Meet-SwiftUI-for-spatial-computing","url":"\/documentation\/wwdcnotes\/wwdc23-10109-meet-swiftui-for-spatial-computing","role":"sampleCode","kind":"article","title":"Meet SwiftUI for spatial computing","abstract":[{"text":"Take a tour of the solar system with us and explore SwiftUI for visionOS! Discover how you can build an entirely new universe of apps with windows, volumes, and spaces. We’ll show you how to get started with SwiftUI on this platform as we build an astronomy app, add 3D content, and create a fully immersive experience to transport people to the stars.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10039-Meet-device-management-for-Apple-Watch":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10039-Meet-device-management-for-Apple-Watch","url":"\/documentation\/wwdcnotes\/wwdc23-10039-meet-device-management-for-apple-watch","role":"sampleCode","kind":"article","title":"Meet device management for Apple Watch","abstract":[{"text":"Organizations can now deploy and configure Apple Watch in addition to other Apple devices. Learn how to implement device management for watchOS to help organizations improve productivity, support wellness, and provide additional support for their employees.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23":{"kind":"article","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23","role":"collectionGroup","title":"WWDC23","url":"\/documentation\/wwdcnotes\/wwdc23","abstract":[{"type":"text","text":"Xcode 15, Swift 5.9, iOS 17, macOS 14, tvOS 17, visionOS 1, watchOS 10."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"code":"SwiftData","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Observation"},{"type":"text","text":", "},{"type":"codeVoice","code":"StoreKit"},{"type":"text","text":" views, and more."}],"images":[{"type":"icon","identifier":"WWDCNotes.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10187-Meet-SwiftData":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10187-Meet-SwiftData","url":"\/documentation\/wwdcnotes\/wwdc23-10187-meet-swiftdata","role":"sampleCode","kind":"article","title":"Meet SwiftData","abstract":[{"text":"SwiftData is a powerful and expressive persistence framework built for Swift. We’ll show you how you can model your data directly from Swift code, use SwiftData to work with your models, and integrate with SwiftUI.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/marcolg97":{"abstract":[{"text":"iOS Developer - in love with SwiftUI","type":"text"}],"role":"sampleCode","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/marcolg97","url":"\/documentation\/wwdcnotes\/marcolg97","title":"Marco La Gala (1 note)","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10146-Meet-Core-Location-for-spatial-computing":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10146-Meet-Core-Location-for-spatial-computing","url":"\/documentation\/wwdcnotes\/wwdc23-10146-meet-core-location-for-spatial-computing","role":"sampleCode","kind":"article","title":"Meet Core Location for spatial computing","abstract":[{"text":"Discover how Core Location helps your app find its place in the world — literally. We’ll share how you can build a spatial computing app that uses a person’s location while respecting their privacy. You’ll also learn how your app can request location access and how Core Location adapts requests from compatible iPad and iPhone apps.","type":"text"}]},"WWDC23-10268-dynamic-linking":{"variants":[{"url":"\/images\/WWDC23-10268-dynamic-linking.png","traits":["1x","light"]}],"identifier":"WWDC23-10268-dynamic-linking","alt":"Static vs Dynamic libraries","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10184-Meet-ActivityKit":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10184-Meet-ActivityKit","url":"\/documentation\/wwdcnotes\/wwdc23-10184-meet-activitykit","role":"sampleCode","kind":"article","title":"Meet ActivityKit","abstract":[{"text":"Live Activities are a glanceable way for someone to keep track of the progress of a task within your app. We’ll teach you how you can create helpful experiences for the Lock Screen, the Dynamic Island, and StandBy. Learn how to update your app’s Live Activities, monitor activity state, and take advantage of WidgetKit and SwiftUI to build richer experiences.","type":"text"}]},"WWDC23-10268-mergeable-libraries":{"variants":[{"url":"\/images\/WWDC23-10268-mergeable-libraries.png","traits":["1x","light"]}],"identifier":"WWDC23-10268-mergeable-libraries","alt":"Static vs Dynamic libraries","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10082-Meet-ARKit-for-spatial-computing":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10082-Meet-ARKit-for-spatial-computing","url":"\/documentation\/wwdcnotes\/wwdc23-10082-meet-arkit-for-spatial-computing","role":"sampleCode","kind":"article","title":"Meet ARKit for spatial computing","abstract":[{"text":"Discover how you can use ARKit’s tracking and scene understanding features to develop a whole new universe of immersive apps and games. Learn how visionOS and ARKit work together to help you create apps that understand a person’s surroundings — all while preserving privacy. Explore the latest updates to the ARKit API and follow along as we demonstrate how to take advantage of hand tracking and scene geometry in your apps.","type":"text"}]},"WWDC23-10268-manual":{"variants":[{"url":"\/images\/WWDC23-10268-manual.png","traits":["1x","light"]}],"identifier":"WWDC23-10268-manual","alt":"Static vs Dynamic libraries","type":"image"},"WWDC23-10268-sweet-spot":{"variants":[{"url":"\/images\/WWDC23-10268-sweet-spot.png","traits":["1x","light"]}],"identifier":"WWDC23-10268-sweet-spot","alt":"Static vs Dynamic libraries","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10147-Meet-Core-Location-Monitor":{"type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10147-Meet-Core-Location-Monitor","url":"\/documentation\/wwdcnotes\/wwdc23-10147-meet-core-location-monitor","role":"sampleCode","abstract":[{"text":"Discover how Core Location Monitor can help you better understand location and beacon events in your app. Learn how to use Core Location Conditions to describe and track the state of events in your app, and find out how you can better respond to transitions in your apps through Swift semantics and improved reliability.","type":"text"}],"title":"Meet Core Location Monitor"},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","title":"WWDC Notes","url":"\/documentation\/wwdcnotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"images":[{"identifier":"WWDCNotes.png","type":"icon"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10083-Meet-Reality-Composer-Pro":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10083-Meet-Reality-Composer-Pro","url":"\/documentation\/wwdcnotes\/wwdc23-10083-meet-reality-composer-pro","role":"sampleCode","kind":"article","title":"Meet Reality Composer Pro","abstract":[{"text":"Discover how to easily compose, edit, and preview 3D content with Reality Composer Pro. Follow along as we explore this developer tool by setting up a new project, composing scenes, adding particle emitters and audio, and even previewing content on device.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10043-Meet-MapKit-for-SwiftUI":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10043-Meet-MapKit-for-SwiftUI","url":"\/documentation\/wwdcnotes\/wwdc23-10043-meet-mapkit-for-swiftui","role":"sampleCode","kind":"article","title":"Meet MapKit for SwiftUI","abstract":[{"text":"Discover how expanded SwiftUI support for MapKit has made it easier than ever for you to integrate Maps into your app. We’ll show you how to use SwiftUI to add annotations and overlays to a map, control the camera, and more.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110362-Link-fast-Improve-build-and-launch-times":{"url":"\/documentation\/wwdcnotes\/wwdc22-110362-link-fast-improve-build-and-launch-times","abstract":[{"text":"Discover how to improve your app’s build and runtime linking performance. We’ll take you behind the scenes to learn more about linking, your options, and the latest updates that improve the link performance of your app.","type":"text"}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110362-Link-fast-Improve-build-and-launch-times","kind":"article","title":"Link fast: Improve build and launch times","role":"sampleCode"},"https://github.com/marcolg97":{"titleInlineContent":[{"text":"GitHub","type":"text"}],"title":"GitHub","identifier":"https:\/\/github.com\/marcolg97","type":"link","url":"https:\/\/github.com\/marcolg97"},"https://wwdcnotes.github.io/WWDCNotes/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"title":"Contributions are welcome!","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","type":"link","url":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10026-Meet-watchOS-10":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10026-Meet-watchOS-10","url":"\/documentation\/wwdcnotes\/wwdc23-10026-meet-watchos-10","role":"sampleCode","kind":"article","title":"Meet watchOS 10","abstract":[{"text":"Discover some of the most significant changes to Apple Watch since its introduction as we tour the redesigned user interface and the new Smart Stack. Learn how Apple designers approached the design of watchOS 10 as we explore layout, navigation, and visual style, and find out how you can apply them to create a great app for Apple Watch.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10171-Meet-Swift-OpenAPI-Generator":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10171-Meet-Swift-OpenAPI-Generator","url":"\/documentation\/wwdcnotes\/wwdc23-10171-meet-swift-openapi-generator","role":"sampleCode","kind":"article","title":"Meet Swift OpenAPI Generator","abstract":[{"text":"Discover how Swift OpenAPI Generator can help you work with HTTP server APIs whether you’re extending an iOS app or writing a server in Swift. We’ll show you how this package plugin can streamline your workflow and simplify your codebase by generating code from an OpenAPI document.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10025-Meet-Push-Notifications-Console":{"abstract":[{"type":"text","text":"The Push Notifications Console is the best way to quickly test user notifications in your app. Learn how you can iterate on new ideas quickly by sending notifications directly from the console and analyze delivery logs to learn more about your pushes. We’ll also show you how to generate and validate tokens to successfully authenticate with Apple Push Notification service (APNs)."}],"kind":"article","role":"sampleCode","title":"Meet Push Notifications Console","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc23-10025-meet-push-notifications-console","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10025-Meet-Push-Notifications-Console"},"WWDC23-10268-mergeable-libraries-2":{"alt":"Static vs Dynamic libraries","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10268-mergeable-libraries-2.png"}],"identifier":"WWDC23-10268-mergeable-libraries-2","type":"image"},"WWDCNotes.png":{"alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"identifier":"WWDCNotes.png","type":"image"},"https://avatars.githubusercontent.com/u/49726419?v=4":{"alt":"Profile image of Marco La Gala","variants":[{"traits":["1x","light"],"url":"https:\/\/avatars.githubusercontent.com\/u\/49726419?v=4"}],"identifier":"https:\/\/avatars.githubusercontent.com\/u\/49726419?v=4","type":"image"},"WWDC23-10268-static-vs-dynamic":{"alt":"Static vs Dynamic libraries","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-10268-static-vs-dynamic.png"}],"identifier":"WWDC23-10268-static-vs-dynamic","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10191-Meet-Object-Capture-for-iOS":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10191-Meet-Object-Capture-for-iOS","url":"\/documentation\/wwdcnotes\/wwdc23-10191-meet-object-capture-for-ios","role":"sampleCode","kind":"article","title":"Meet Object Capture for iOS","abstract":[{"text":"Discover how you can offer an end-to-end Object Capture experience directly in your iOS apps to help people turn their objects into ready-to-use 3D models. Learn how you can create a fully automated Object Capture scan flow with our sample app and how you can assist people in automatically capturing the best content for their model. We’ll also discuss LiDAR data and provide best practices for scanning objects.","type":"text"}]}}}