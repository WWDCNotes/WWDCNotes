{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc23-10164-whats-new-in-swift"]}],"metadata":{"role":"sampleCode","title":"What‚Äôs new in Swift","roleHeading":"WWDC23","modules":[{"name":"WWDC Notes"}]},"sampleCodeDownload":{"kind":"sampleDownload","action":{"overridingTitle":"Watch Video (43 min)","isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc23\/10164","type":"reference"}},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10164-Whats-new-in-Swift","interfaceLanguage":"swift"},"sections":[],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"]]},"schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"type":"text","text":"Join us for an update on Swift. We‚Äôll show you how APIs are becoming more extensible and expressive with features like parameter packs and macros. We‚Äôll also take you through improvements to interoperability and share how we‚Äôre expanding Swift‚Äôs performance and safety benefits everywhere from Foundation to large-scale distributed programs on the server."}],"kind":"article","primaryContentSections":[{"content":[{"text":"Chapters","type":"heading","level":2,"anchor":"Chapters"},{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=39","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=164","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=232","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=293","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=574","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1187","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1405","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1679","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1961","type":"reference"},{"text":"","type":"text"},{"text":"\n","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=2300"}]},{"text":"Description","type":"heading","level":2,"anchor":"Description"},{"type":"paragraph","inlineContent":[{"text":"Explore cutting edge language features and new APIs of Swift programming language.","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift project update"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Expressive code"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Swift everywhere","type":"text"}]}]}]},{"text":"Swift project update","type":"heading","level":1,"anchor":"Swift-project-update"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift follows an open process for language evolution. New features or significant behavior changes are proposed and reviewed in the open on the Swift forums. If you want to follow along, you can find a dashboard of all the language proposals on the Swift website."}]},{"text":"swift.org\/swift-evolution","type":"heading","level":4,"anchor":"swiftorgswift-evolution"},{"type":"paragraph","inlineContent":[{"text":"A year ago, we saw a significant restructuring of the Swift Project governance. The core team announced the formation of the Language Steering Group, which took on primary responsibility for oversight of the Swift language and standard library evolution. Since then, the language group has overseen 40 new language proposals, and we‚Äôre going to talk about several of them today.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But sometimes, individual language proposals come together as part of a wider theme, like the addition of Swift concurrency, which was introduced through ten separate proposals."}]},{"type":"paragraph","inlineContent":[{"text":"For cases like this, the language steering group has introduced a new way of tying together these proposals, through vision documents.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"These documents lay out a proposal for larger changes to the language. The first one to be accepted by the language steering group was a vision of Swift macros, a new feature in Swift 5.9 that we‚Äôll be covering later in this talk.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-visionDocuments"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Of course, evolution of the language is only part of the work of the Swift community. A successful language needs much more than this. It needs great tooling, robust support for multiple platforms, and rich documentation. To oversee progress in this area, the core team is creating an ecosystem steering group parallel to the language steering group. This new structure was recently laid out in a blog post on Swift.org, a look out for further announcements about the formation of this new group soon."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-visionDocuments2"}]},{"text":"Expressive code","type":"heading","level":1,"anchor":"Expressive-code"},{"type":"paragraph","inlineContent":[{"text":"Swift 5.9 includes what is probably our most commonly requested language enhancement, allowing if\/else and switch statements to be used as expressions, providing a nice way to clean up your code.","type":"text"}]},{"text":"If\/else and switch statements can now be used as expressions","type":"heading","level":3,"anchor":"Ifelse-and-switch-statements-can-now-be-used-as-expressions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if you wanted to initialize a let variable based on some complex condition, you had to resort to tricks, like this hard-to-read compound ternary expression."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Before ü§Ø","let bullet =","    isRoot && (count == 0 || !willExpand) ? \"\"","        : count == 0 ? \"- \"","        : maxDepth <= 0 ? \"‚ñπ \" : \"‚ñø \"","","\/\/ After ü§©","let bullet =","    if isRoot && (count == 0 || !willExpand) { \"\" }","    else if count == 0 { \"- \" }","    else if maxDepth <= 0 { \"‚ñπ \" }","    else { \"‚ñø \" }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another place where this helps is if you‚Äôre initializing a global variable or a stored property. Single expressions work fine here, but if you wanted a condition, you had to use the trick of wrapping it in a closure that you then immediately executed."}]},{"syntax":"swift","type":"codeListing","code":["let attributedName =","    AttributedString(markdown: displayName)","\/\/ before","let attributedName = {","    if let displayName, !displayName.isEmpty {","        AttributedString (markdown: displayName)","    } else {","        \"Untitled\"","    }","}()    "]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that an if statement can be an expression, you can just drop that clutter, leaving you with neater code."}]},{"syntax":"swift","type":"codeListing","code":["let attributedName =","    if let displayName, !displayName.isEmpty {","        AttributedString (markdown: displayName)","    } else {","        \"Untitled\"","    }    "]},{"text":"Result builders enhancement","type":"heading","level":2,"anchor":"Result-builders-enhancement"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Faster type checking"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Improved code completion","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"More accurate error messages","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"Result builders have seen significant improvements including optimized type checking performance, code completion and improved error messages.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Previously, result builder code with errors would take a long time to fail, as the type checker explored the many possible invalid paths.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"As of Swift 5.8, invalid code type checks much faster, and error messages on invalid code are now more precise. For example, previously, some invalid code could lead to misleading errors in a completely different part of the result builder. In Swift 5.7, you‚Äôd receive an error like this:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-IMG_9B4379D3B587-1","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"when the mistake actually lies up here:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-IMG_FFC563B46E50-1","type":"image"}]},{"text":"Generic improvement","type":"heading","level":2,"anchor":"Generic-improvement"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Type inference enables using these types without needing to understand the advanced capabilities they‚Äôre built with. For example, the standard library Array type uses generics to provide an array that works with any type of data that you might want to store. When you use an array, all you need to do is provide the elements. There‚Äôs no need to specify an explicit argument for the element type because it can be inferred from the element values."},{"type":"text","text":"\n"},{"type":"text","text":"Here‚Äôs an example inspired by the Swift compiler‚Äôs own codebase: An API that takes a request type and evaluates it to produce a strongly typed value. So you can make a request for a Boolean value and get back a Boolean result."}]},{"syntax":"swift","type":"codeListing","code":["struct Request<Result> { ... }","","struct RequestEvaluator {","    func evaluate<Result>(_ request: Request<Result>) -> Result","}","","func evaluate(_ request: Request<Bool>) -> Bool {","    return RequestEvaluator ().evaluate(request)","}"]},{"type":"paragraph","inlineContent":[{"text":"Now, some APIs want to abstract not only over concrete types, but also the number of arguments that you pass in. So a function might take one request and return one result or two requests and return two results, or three and return three results.","type":"text"},{"text":"\n","type":"text"},{"text":"To support this, the generics system has to be used together with a mechanism to handle multiple argument lengths so that all of the types that you pass in are linked to the types that you get out.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let value = RequestEvaluator().evaluate(request)","","let (x, y) = RequestEvaluator().evaluate(r1, r2)","","let (x, Y, z) = RequestEvaluator().evaluate(rl, I2, I3)"]},{"type":"paragraph","inlineContent":[{"text":"Before Swift 5.9, the only way to accomplish this pattern was by adding an overload for each specific argument length the API supported. But this approach has limitations. It forces an artificial upper bound on the number of arguments you can pass, resulting in compiler errors if you pass too many.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct Request<Result> { ... }","struct RequestEvaluator {","    func evaluate<Result>(:) -> (Result)","    func evaluate<R1, R2> (_:_:) -> (R1, R2)","    func evaluate<R1, R2, R3> (_:_:_:) -> (R1, R2, R3)","    func evaluate<R1, R2, R3, R4>(_:_:_:_:)-> (R1, R2, R3, R4)","    func evaluate<R1, R2, R3, R4, R5>(_:_:_:_:_:) -> (R1, R2, R3, R4, R5)","    func evaluate<R1, R2, R3, R4, R5, R6>(_:_:_:_:_:_:) -> (R1, R2, R3, R4, R5, R6)","}","let results = evaluator. evaluate (r1, r2, r3, r4, r5, r6, r7)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift 5.9, the generics system is gaining first-class support for this API pattern by enabling generic abstraction over argument length. This is done with a new language concept that can represent multiple individual type parameters that are ‚Äúpacked‚Äù together. This new concept is called a "},{"type":"strong","inlineContent":[{"type":"text","text":"type parameter pack"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-eachResult"}]},{"type":"paragraph","inlineContent":[{"text":"Instead of accepting a single type parameter, Result, representing the result type of a single request, the evaluate function now accepts a separate request over ","type":"text"},{"code":"each Result","type":"codeVoice"},{"text":" type.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["func evaluate<each Result>(_: repeat Request<each Result>) -> (repeat each Result)"]},{"type":"paragraph","inlineContent":[{"text":"The function returns each result instance in parenthesis, which will either be a single value or a tuple containing each value.","type":"text"},{"text":"\n","type":"text"},{"text":"The evaluate function now handles all argument lengths with no artificial limit.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Before ü§Ø","struct Request<Result> { ... }","","struct RequestEvaluator {","    func evaluate<Result>(_:) -> (Result)","    func evaluate<R1, R2>(_:) -> (R1, R2)","    func evaluate<R1, R2, R3>(_:) -> (R1, R2, R3)","    func evaluate<R1, R2, R3, R4>(_:) -> (R1, R2, R3, R4)","}","","\/\/ Call side","let results = RequestEvaluator.evaluate(r1, r2, r3, r4)","","\/\/ After ü§©","struct RequestEvaluator {","    func evaluate<each Result>(_: repeat Request<each Result>) -> (repeat each Result)","}","","\/\/ Call side","let results = RequestEvaluator.evaluate(r1, r2, r3, r4)"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The evaluate func now handles all arg lengths with no artificial limit","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Type inference makes APIs using parameter packs natural to use, without needing to know that the API is using them, i.e call-side might not even aware you are using type parameter pack under the hood.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"To learn about how to write generic library APIs like these, check out:","type":"text"}]},{"type":"paragraph","inlineContent":[{"isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10168","type":"reference"}]},{"text":"Swift Macros","type":"heading","level":1,"anchor":"Swift-Macros"},{"type":"paragraph","inlineContent":[{"type":"text","text":"With macros, you can extend the capabilities of the language itself, eliminating boilerplate and unlocking more of Swift‚Äôs expressive power. Let‚Äôs consider the ever-present assert function, which checks whether a condition is true."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Normal assert func, not much info will be printed","assert(max(a, b) == c)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Assert will stop the program if the condition is false, but when that happens, you get very little information about what went wrong, just the file and line number. You‚Äôll need to add some logging or trap the program in the debugger to learn more."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-macroAssert","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"There have been attempts to improve on this. XCTest provides an assert-equal operation that takes the two values separately, so when things fail, you can at least see the two values that aren‚Äôt equal.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-macroAssert2","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"But we still don‚Äôt know which value is wrong here. Was it a, b, or the result of max? And this approach really doesn‚Äôt scale for all of the kinds of checks we perform in asserts. If we go back to the original assertion, there is so much information here in the source code that we‚Äôd like to see in the log when our assertion fails. What was the code? What are the values of a, and b, and c? What did max produce? We couldn‚Äôt improve this in Swift before without some custom feature, but macros make it possible.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ With \"hash-assert\" syntax is expanding the macro called \"assert\"","#assert(max(a, b) == c)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, the ‚Äúhash-assert‚Äù syntax is expanding the macro called ‚Äúassert.‚Äù The hash syntax might look familiar because Swift already has a few things with this same spelling, like hash-file, hash-selector, and hash-warning."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the program is showing the code for the failing assertion, along with each of the values that contributed to the result."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-macroAssert3","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, macros are APIs, just like types or functions, so you access them by importing the module that defines them. Like many other APIs, macros are distributed as packages. The assert macro here comes from the power asserts library, an open-source Swift package available on GitHub."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you were to look into the macro package, you would find a macro declaration for assert. It is introduced with the ‚Äúmacro‚Äù keyword, but it looks a lot like a function. There‚Äôs a single unlabeled Bool parameter for the condition to be checked. If this macro produced a value, that result type would be written with the usual arrow syntax."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Macro declarations","public macro assert(_ condition: Bool)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Uses of the macro will be type checked against the parameters."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most macros are defined as ‚Äúexternal macros,‚Äù specifying the module and type for a macro implementation via strings. The external macro types are defined in separate programs that act as compiler plugins. The Swift compiler passes the source code for the use of the macro to the plugin. The plugin produces new source code, which is then integrated back into the Swift program."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Macros are separate programs","public macro assert(_ condition: Bool) = #externalMacro(","    module: \"PowerAssertPlugin\",","    type: \"PowerAssertMacro\"",")"]},{"type":"paragraph","inlineContent":[{"text":"Here, the macro is expanding the assertion into code that captures the individual values and where they should be displayed in the source code. You wouldn‚Äôt want to write the boilerplate yourself, but the macro does it for you.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-macroAssert4","type":"image"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"You can extend the capabilities of the lang itself, eliminate boilerplate","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Assert macro looks and feels like the function version, but, as it‚Äôs a macro, it can provide a richer experience.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Macros are APIs, just like types or functions, you access them by importing the module that defines them","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Macros operate on well-typed inputs and produce code that augments your program (hence shipped with compile time type checking and helpful error message","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Most macros are defined as ‚Äúexternal macros‚Äù, so, you need to specify module and type for actual macro implementation via strings."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The external macro types are defined in separate programs, that act as compiler plugins. Swift compiler passes the source code (","type":"text"},{"code":"#assert(a == b)","type":"codeVoice"},{"text":" in our case) for the use of the macro to the plugin, and the plugin produces new source code (the implementation), and that code is then integrated back into the Swift program.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Macro declarations have one additional piece of info, their role.","type":"text"}]}]}]},{"text":"Freestanding macro roles","type":"heading","level":3,"anchor":"Freestanding-macro-roles"},{"syntax":"swift","type":"codeListing","code":["@freestanding(expression)","public macro assert(_ condition: Bool) = #externalMacro(","    module: \"PowerAssertPlugin\",","    type: \"PowerAssertMacro\"",")"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"assert","type":"codeVoice"},{"text":" is labelled as freestanding because it uses the ‚Äúhash‚Äù syntax. It is an expression macro as it can be used anywhere that one can produce a value.","type":"text"},{"text":" ","type":"text"},{"text":"If you wanna see example of an expression macro, check out the new Foundation Predicate APIs.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new Foundation Predicate APIs provide a great example of an expression macro. The predicate macro allows one to write predicates in a type-safe manner using closures. The resulting predicate values can then be used with a number of other APIs, including the Swift collection operations SwiftUI and SwiftData."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Predicate expression macro","@freestanding(expression)","public macro Predicate<each Input>(","    _ body: (repeat each Input) -> Bool",") -> Predicate<repeat each Input>","","","let pred = #Predicate<Person> {","    $0.favoriteColor == .blue","}","let blueLovers = people.filter(pred)"]},{"text":"Case detection attached macros","type":"heading","level":3,"anchor":"Case-detection-attached-macros"},{"type":"paragraph","inlineContent":[{"text":"Let‚Äôs take an example. I find that I use enums a lot in my own code, like this Path enum that captures either relative or absolute paths. But I‚Äôll often find myself needing to check for a specific case, say, by filtering all absolute paths from a collection. I can write this isAbsolute check as a computed property, of course. But sooner or later, I‚Äôm going to have to write another one.","type":"text"},{"text":"\n","type":"text"},{"text":"This is getting a bit tedious.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Testing for a specific enum case","enum Path {","    case relative(String)","    case absolute (String)","}","","let absPaths = paths.filter { $0.isAbsolute }","","extension Path {","    var isAbsolute: Bool {","        if case absolute = self { true }","        else { false }","    }","}","","extension Path {","    var isRelative: Bool {","    if case relative = self { true }","    else { false }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Case detection is an attached macro, written using the same custom-attribute syntax as property wrappers. Attached macros take as input the syntax of the declaration they apply to‚Äì here it‚Äôs the enum declaration itself‚Äì and will generate new code.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This macro-expanded code is normal Swift code, which the compiler integrates into your program. You can inspect the macro-generated code in your editor, debug into it, copy it out if you want to customize it further, and so on.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Testing for a specific enum case","@CaseDetection","enum Path {","    case relative(String)","    case absolute(String)","}","","let absPaths = paths.filter { $0.isAbsolute }"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Macro expand code (with use of "},{"type":"codeVoice","code":"@CaseDetection"},{"type":"text","text":" just like you define a property wrapper)"}],"type":"paragraph"}]}]},{"syntax":"swift","type":"codeListing","code":["\/\/ @CaseDetection expanded","var isAbsolute: Bool {","    if case absolute = self { true }","    else { false }","}","var isRelative: Bool {","    if case relative = self { true }","    else { false }","}"]},{"type":"paragraph","inlineContent":[]},{"text":"Attached macro roles","type":"heading","level":2,"anchor":"Attached-macro-roles"},{"type":"paragraph","inlineContent":[{"text":"Attached macros are classified into five different roles based on how they augment the declaration they are attached to.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-attachedMacroRoles"}]},{"type":"paragraph","inlineContent":[{"text":"The case detection macro we just discussed is a ‚Äúmember‚Äù attached macro, meaning that it creates new members in a type or extension.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Peer macros add new declarations alongside the declaration they‚Äôre attached to, for example, to create a completion-handler version of an async method or vice-versa.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Accessor macros can turn a stored property into a computed property, which can be used to perform specific actions on property access or abstract the actual storage in a manner similar to, but more flexible than property wrappers. And attached macros can introduce attributes onto specific members of a type, as well as add new protocol conformances.","type":"text"}]},{"text":"SwiftUI‚Äôs Observable macro","type":"heading","level":3,"anchor":"SwiftUIs-Observable-macro"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Observation has always been a part of SwiftUI. To be able to observe changes to the properties of a class, one need only make the type conform to ObservableObject, and mark every property at-Published, and use the ObservedObject property wrapper in your view."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Observation in SwiftUI","final class Person: ObservableObject {","    @Published var name: String","    @Published var age: Int","    @Published var isFavorite: Bool","}","","struct ContentView: View {","    @ObservedObject var person: Person","    ","    var body: some View {","        Text (\"Hello, \\(person.name)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"That‚Äôs a bunch of steps, and missing a step can mean that the UI doesn‚Äôt update as expected. We can do better with macro-based observation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Attaching the Observable macro to a class provides observation for all of its stored properties. There is no need to annotate each stored property or worry about what happens if you don‚Äôt because the Observable macro handles it all.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Observation in SwiftUI","@Observable final class Person {","    var name: String var age: Int ","    var isFavorite: Bool","}","","struct ContentView: View {","    var person: Person","    var body: some View {","        Text (\"Hello, \\(person.name)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Observable macro works through composition of three macro roles. Let‚Äôs dive into how these roles work together."}]},{"syntax":"swift","type":"codeListing","code":["@attached(member, names: ...) ","@attached(memberAttribute) ","@attached(conformance)","public macro Observable () = #externalMacro(...)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each macro role corresponds to a specific way in which the Person class is augmented by the Observable macro. The member role introduces new properties and methods."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Observable macro expansion","@Observable final class Person {","    var name: String ","    var age: Int ","    var isFavorite: Bool","}"]},{"type":"paragraph","inlineContent":[{"text":"The member attribute role will add the @ObservationTracked macro to the stored properties of the observed class, which in turn expands to getters and setters to trigger observation events. Finally, the conformance role introduces the conformance to the Observable protocol.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Observable macro expansion","Observable final class Person: Observable {","    @ObservationTracked var name: String { get { ... } set { ... } }","    @ObservationTracked var age: Int { get { . } set { ... } }","    @ObservationTracked var isFavorite: Bool { get { ... } set { .. } }","    ","    internal let _$observationRegistrar = ObservationRegistrar<Person>()","    internal func access<Member>(","        keyPath: KeyPath<Person, Member>","    ) {","        _$observationRegistrar.access(self, keyPath: keyPath)","    }","    internal func withMutation<Member, T>(","        keyPath: KeyPath<Person, Member>, ","        mutation: () throws -> T","    ) rethrows -> T {","        try _$observationRegistrar.withMutation(of: self, keyPath: keyPath, mutation)","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This may look like a lot of code, but it‚Äôs all just normal Swift code, and it‚Äôs neatly folded away behind the Observable macro.","type":"text"},{"text":"\n","type":"text"},{"text":"Whenever you need to see how any macro expands to better understand its effect on your program, it‚Äôs right there at your fingertips in Xcode.","type":"text"},{"text":"\n","type":"text"},{"text":"Whenever you need to see how any macro expands, Xcode 15 comes up with ‚ÄúExpand Macros‚Äù","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-expandMacros","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"This session will go deep into the design of Swift macros to answer all of those questions you must have:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10167","isActive":true}]},{"type":"paragraph","inlineContent":[{"text":"And you can get hands-on implementing your own macros with:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10166","isActive":true}]},{"text":"Swift everywhere","type":"heading","level":1,"anchor":"Swift-everywhere"},{"type":"paragraph","inlineContent":[{"text":"Swift is also efficient. It compiles natively, and its use of value types and of reference counting instead of garbage collection means it‚Äôs able to achieve a low memory footprint.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This scalability means we‚Äôre able to push Swift to more places than was previously possible with Objective-C, to low-level systems, where previously you might expect to have to use C or C++. This means bringing Swift‚Äôs clearer code and critical safety guarantees to more places.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We recently open sourced the start of a rewrite of the Foundation framework in Swift. This initiative will lead to a single shared implementation of Foundation on both Apple and non-Apple platforms. But it also meant rewriting large amounts of Objective-C and C code in Swift."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-swiftEverywhere","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As of MacOS Sonoma and iOS 17, there are new Swift-backed implementations of essential types like Date and Calendar, of formatting and internationalization essentials like Locale and AttributedString, and a new Swift implementation of JSON encoding and decoding. And the performance wins have been significant."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Swift foundation framework has significant performance improvement","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Calendar calculations: 20% faster","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Date formatting: 150% faster","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"JSON coding: 200-500% faster","type":"text"}],"type":"paragraph"}]}]}]}]},{"type":"paragraph","inlineContent":[{"text":"Foundation has a brand-new Swift implementation for JSONDecoder and JSONEncoder, eliminating costly roundtrips to and from the Objective-C collection types. The tight integration of parsing JSON in Swift for initializing Codable types improves performance too. In benchmarks parsing test data, the new implementation is between two and five times faster. These improvements came from both reducing the bridging cost from the old Objective-C implementation to Swift, but also by the new Swift-based implementations being faster.","type":"text"}]},{"text":"Benchmark: calling enumerateDates","type":"heading","level":3,"anchor":"Benchmark-calling-enumerateDates"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-swiftEverywhere2","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Now, sometimes, when you‚Äôre operating at lower levels of the system, you need more fine-grained control to achieve a necessary level of performance. Swift 5.9 introduces some new opt-in capabilities that help you achieve this level of control. These capabilities focus on the concept of ownership, that is, what part of the code ‚Äúowns‚Äù a value as it passes around your application.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here we have a very simple wrapper for a file descriptor that would allow us to give low-level system calls a nicer Swift interface. But there‚Äôs still some easy ways to make mistakes with this API. For example, you might try to write to the file after you‚Äôve called close. And you have to be careful to always close it manually by calling the close method before the type goes out of scope. Otherwise, you would get a resource leak."}]},{"syntax":"swift","type":"codeListing","code":["struct FileDescriptor {","    private var fd: CInt","    ","    init(descriptor: CInt) { self.fd = descriptor }","","    func write(buffer: [UInt8]) throws {","        let written = buffer.withUnsafeBufferPointer {","            Darwin.write(fd, S0.baseAddress, $0.count)","        }","    \/\/ ...","    }","","    func close() {","        Darwin.close(fd)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One solution would be to make it a class with a deinit that closes it automatically when the type goes out of scope."}]},{"type":"paragraph","inlineContent":[{"text":"But that has different downsides, like making an additional memory allocation, which is usually not a big problem, except in some very constrained systems contexts.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class FileDescriptor {","    private var fd: CInt","    ","    init(descriptor: CInt) { self.fd = descriptor }","    ","    func write(buffer: [UInt8]) throws {","        let written = buffer.withUnsafeBufferPointer {","            Darwin.write(fd, So.baseAddress, $0.count)","        }","        \/\/ ...","    }","    ","    func close() {","        Darwin.close(fd)","    }","    ","    deinit {","        self.close(fd)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Classes also have reference semantics. You might unintentionally end up sharing a file descriptor type across threads, leading to race conditions, or store it unintentionally."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But let‚Äôs go back and look at the struct version."}]},{"type":"paragraph","inlineContent":[{"text":"Really, this struct also behaves like a reference type. It holds an integer that references the true value, which is an open file. Making a copy of this type could also lead to unintentional sharing of mutable state across your app in ways that could lead to bugs. What you want is to suppress the ability to make a copy of this struct.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Swift types, whether structs or classes, are copyable by default. This is the right choice most of the time.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But sometimes that implicit copy isn‚Äôt what you want‚Äìin particular, when making copies of a value might lead to correctness issues, like with our file descriptor wrapper. In Swift 5.9, you can do that with this new syntax that can be applied to struct and enum declarations and that suppresses the implicit ability to copy a type."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"~Copyable"},{"type":"text","text":" (can be applied to struct and enum declarations) suppresses the implicit ability to copy a type. Once the type is non-copyable, you can give it a deinit (which will run when a value of the type goes out of scope), like you can a class."}]},{"syntax":"swift","type":"codeListing","code":["struct FileDescriptor: ~Copyable {","    private var fd: CInt","    ","    init(descriptor: CInt) { self.fd = descriptor }","","    func write(buffer: [UInt8]) throws {","        \/\/ ...","    }","","    func close() {","        Darwin.close(fd)","    }","    ","    deinit {","        Darwin.close(fd)","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The close operation can be marked as consuming. Calling a ","type":"text"},{"code":"consuming","type":"codeVoice"},{"text":" method or argument gives up ownership of a value to the method you called. Since our type is non-copyable, giving up ownership means you can no longer use the value.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct FileDescriptor: ~Copyable {","    private var fd: CInt","","    init(descriptor: CInt) { self.fd = descriptor }","","    func write(buffer: [UInt8]) throws {","        \/\/ ...","    }","","    consuming func close() {","        Darwin.close(fd)","    }","","    deinit {","        Darwin.close(fd)","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This means, if you close the file first and then attempt to call another method, like write, you‚Äôll get an error message at compile time, rather than a runtime failure. The compiler will also indicate where the consuming use occurred.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-consuming"}]},{"text":"C++ Interoperability","type":"heading","level":1,"anchor":"C++-Interoperability"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use C++ APIs directly from Swift"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Expose most Swift APIs directly to C++"}]}]},{"content":[{"inlineContent":[{"text":"Join us on the forums","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Many apps also have core business logic implemented in C++, and interfacing to that has not been so easy. Often it meant adding an extra manual bridging layer, going from Swift, through Objective-C, and then into C++, and all the way back."},{"type":"text","text":" "},{"type":"text","text":"Swift 5.9 introduces the ability to interact with C++ types and funcs directly from Swift."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC23-10164-interactWithCplusplus","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"C++ is a large language with its own notions of ideas like classes, methods, containers, and so on. The Swift compiler understands common C++ idioms, so many types can be used directly. For example, this Person type defines the five special member functions expected of a C++ value type: Copy and move constructors, assignment operators, and a destructor.","type":"text"}]},{"syntax":"C++","type":"codeListing","code":["\/\/ Using C++ from Swift","","\/\/ Person.h","struct Person {","    Person (const Person &);","    Person (Person &&);","    Person &operator=(const Person &);","    Person &operator=(Person &&);","    ~Person ();","    ","    std::string name;","    unsigned getAge() const;","};","","std::vector<Person> everyone();"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The Swift compiler treats this as a value type and will automatically call the right special member function at the right time. Additionally, C++ containers like vectors and maps are accessible as Swift collections."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Calling C++ from Swift:"},{"type":"text","text":" "},{"type":"text","text":"The result of all of this is that we can write straightforward Swift code that makes direct use of C++ functions and types. We can filter over the vector of Person instances, calling C++ member functions and accessing data members directly."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Client.swift","func greetAdults() {","    for person in everyone().filter { $0.getAge() >= 18 } {","        print (\"Hello, \\(person.name)!\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Calling Swift from C++"},{"type":"text","text":" "},{"type":"text","text":"In the other direction, using Swift code from C++ is based on the same mechanism as with Objective-C. The Swift compiler will produce a ‚Äúgenerated header‚Äù that contains a C++ view on the Swift APIs. However, unlike with Objective-C, you don‚Äôt need to restrict yourself to only using Swift classes annotated with the objc attribute. C++ can directly use most Swift types and their full APIs, including properties, methods, and initializers, without any bridging overhead."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Geometry.swift","","struct LabeledPoint {","    var x = 0.0, y = 0.0","    var label: String = \"origin\"","","    mutating func moveBy(x deltaX: Double, y deltaY: Double) { ... }","    var magnitude: Double { ... }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here we can see how C++ can make use of our Point struct. After including the generated header, C++ can call Swift initializers to create Point instances, invoke mutating methods, and access both stored and computed properties, all without any change to the Swift code itself."}]},{"syntax":"C++","type":"codeListing","code":["\/\/ C++ client","#include <Geometry-Swift.h>","void test() {","    Point origin = Point ()","    Point unit = Point::init(1.0, 1.0, \"unit\")","    unit.moveBy(2, -2)","    std::cout << unit.label <‚Äπ \" moved to \" << unit.magnitude() << std:: endl;","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Many C++ idioms can be directly expressed in Swift, often automatically, but occasionally requiring some annotations to indicate the desired semantics. And Swift APIs can be directly accessed from C++, no annotation or code changes required."},{"type":"text","text":"\n"},{"type":"text","text":"C++ interoperability is an evolving story, guided by the C++ interoperability workgroup. For more information, please see the session"}]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10172"}]},{"type":"paragraph","inlineContent":[{"text":"or join us in the discussion on the Swift forums.","type":"text"}]},{"text":"CMake","type":"heading","level":2,"anchor":"CMake"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Can integrate Swift code into CMake build by declaring Swift as one of the languages for the project and putting Swift files into a target."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ CMake","","project(PingPong LANGUAGES Swift)","","add_library(PingPong","    Ping.swift","    Pong.swift",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can mix C++ and Swift within a single target, and CMake will be sure to compile each separately and link all of the appropriate supporting libraries and runtimes for both languages."},{"type":"text","text":"\n"},{"type":"text","text":"We‚Äôre also providing a sample repository with CMake projects containing Swift and mixed C++\/Swift targets, including using the bridging and generated headers, to help you get started."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ CMake","","project(PingPong LANGUAGES CXX Swift)","","add_library(PingPong","    Ping.swift","    Pong.swift","    TableTennisUtils.cpp",")"]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Can mix C++ and Swift within a single target, and CMake will be compiled separately and link all of the appropriate supporting libraries and runtimes for both."}],"type":"paragraph"}]}]},{"text":"Actors and Concurrency updates","type":"heading","level":1,"anchor":"Actors-and-Concurrency-updates"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift‚Äôs concurrency model is an abstract model, which can be adapted to different environments and libraries. The abstract model has two main pieces: Tasks and actors. Tasks represent a sequential unit of work that can conceptually run anywhere. Tasks can be suspended whenever there‚Äôs an ‚Äúawait‚Äù in the program, and then resume once the task can continue."}]},{"type":"paragraph","inlineContent":[{"text":"Actors are a synchronization mechanism that provide mutually-exclusive access to isolated state. Entering an actor from the outside requires an ‚Äúawait‚Äù because it may suspend the task.","type":"text"}]},{"text":"Abstract concurrency model:","type":"heading","level":3,"anchor":"Abstract-concurrency-model"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Sequential unit of work that can run anywhere","type":"text"},{"text":" ","type":"text"},{"text":"Actors:","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Mutually exclusive access to isolated state","type":"text"}]}]}]},{"text":"Tasks in different environments","type":"heading","level":3,"anchor":"Tasks-in-different-environments"},{"type":"paragraph","inlineContent":[{"text":"Global concurrency pool determines scheduling:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dispatch on Apple platforms"}]}]},{"content":[{"inlineContent":[{"text":"Single-threaded cooperative queue in restricted environments","type":"text"},{"text":"\n","type":"text"},{"text":"Tasks are executed on the global concurrent pool. How that global concurrent pool decides to schedule work is up to the environment. For Apple‚Äôs platforms, the Dispatch library provides optimized scheduling for the whole operating system, and has been extensively tuned for each platform.","type":"text"},{"text":"\n","type":"text"},{"text":"In more restrictive environments, the overhead of a multithreaded scheduler may not be acceptable. There Swift‚Äôs concurrency model is implemented with a single-threaded cooperative queue.","type":"text"},{"text":"\n","type":"text"},{"text":"The same Swift code works in both environments because the abstract model is flexible enough to map to diverse runtime environments.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Additionally, interoperability with callback-based libraries was built into Swift‚Äôs async\/await support from the beginning. The withCheckedContinuation operations allow one to suspend a task, and then resume it later in response to a callback. This enables integration with existing libraries that manage tasks themselves."}]},{"syntax":"swift","type":"codeListing","code":["withCheckedContinuation { continuation in","    sendMessage (msg) { response in","        continuation.resume (returning: response)","    }","}"]},{"text":"Actors","type":"heading","level":2,"anchor":"Actors"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Actors can be implemented in different ways","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Custom actor executors allows a particular actor to implement its own synchronization mechanism"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The standard implementation of actors in the Swift concurrency runtime is a lock-free queue of tasks to execute on the actor, but it‚Äôs not the only possible implementation."},{"type":"text","text":"\n"},{"type":"text","text":"In a more restricted environment, one might not have atomics, and instead could use another concurrency primitive such as spinlocks. If that environment were single-threaded, no synchronization is needed, but the actor model maintains the abstract concurrency model for the program regardless."},{"type":"text","text":"\n"},{"type":"text","text":"You could still take that same code to another environment that is multi-threaded."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With Swift 5.9, custom actor executors allow a particular actor to implement its own synchronization mechanism. This makes actors more flexible and adaptable to existing environments. Let‚Äôs take an example."},{"type":"text","text":"\n"},{"type":"text","text":"Here we consider an actor that manages a database connection. Swift ensures mutually-exclusive access to the storage of this actor, so there won‚Äôt be any concurrent access to the database."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Custom actor executors","actor MyConnection {","    private var database: UnsafeMutablePointer<sqlite3>","    ","    init(filename: String) throws { ... }","    ","    func pruneOldEntries() { ... }","    func fetchEntry<Entry>(named: String, type: Entry.Type) -> Entry? { ... }","}","await connection.pruneOldEntries()"]},{"type":"paragraph","inlineContent":[{"text":"However, what if you need more control over the specific way in which synchronization is done? For example, what if you want to use a specific dispatch queue for your database connection, perhaps because that queue is shared with other code that hasn‚Äôt adopted actors? With custom actor executors, you can.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here we‚Äôve added a serial dispatch queue to our actor and an implementation of the unowned executor property that produces the executor corresponding to that dispatch queue. With this change, all of the synchronization for our actor instances will happen through that queue."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Custom actor executors","actor MyConnection {","    private var database: UnsafeMutablePointer<sqlite3> ","    private let queue: DispatchSerialQueue","    ","    nonisolated var unownedExecutor: UnownedSerialExecutor { queue.asUnownedSerialExecutor() }","    ","    init(filename: String, queue: DispatchSerialQueue) throws { ... }","    ","    func pruneOldEntries () { ... }","    func fetchEntry<Entry> (named: String, type: Entry.Type) -> Entry? { ... }","}","","await connection.pruneOldEntries()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you ‚Äúawait‚Äù on the call to pruneOldEntries from outside the actor, this will now perform a dispatch-async on the corresponding queue. This gives you more control over how individual actors provide synchronization, and even lets you synchronize an actor with other code that isn‚Äôt using actors yet, perhaps because it‚Äôs written in Objective-C or C++."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Executor protocols","protocol Executor: AnyObject, Sendable {","    func enqueue(_ job: consuming ExecutorJob)","}","","protocol SerialExecutor: Executor {","    func asUnownedSerialExecutor() -> UnownedSerialExecutor ","    func isSameExclusiveExecutionContext(other executor: Self) -> Bool","}","","extension DispatchSerialQueue: SerialExecutor { ... }"]},{"type":"paragraph","inlineContent":[{"text":"The synchronization of actors via dispatch queues is made possible because dispatch queue conforms to the new SerialExecutor protocol.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can provide your own synchronization mechanism to use with actors by defining a new type that conforms to this protocol which has only few core operations: Checking whether the code is already executing in the context of the executor."}]},{"type":"paragraph","inlineContent":[{"text":"Are we running on the main thread? Extracting an unowned reference to the executor to allow access to it without excess reference-counting traffic. And the most core operation, enqueue, which takes ownership of an executor ‚Äújob.‚Äù A job is part of an asynchronous task that needs to run synchronously on the executor. At the point where enqueue is called, it‚Äôs the responsibility of the executor to run that job at some point when there‚Äôs no other code running on the serial executor.","type":"text"},{"text":"\n","type":"text"},{"text":"For example, enqueue for a dispatch queue would call dispatch async on that queue.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For more information, please see","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10254","isActive":true,"type":"reference"},{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"and:","type":"text"},{"text":"\n","type":"text"},{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10170","isActive":true,"type":"reference"}]},{"text":"A case study","type":"heading","level":2,"anchor":"A-case-study"},{"type":"paragraph","inlineContent":[{"text":"FoundationDB is a distributed database, providing a scalable solution for very large key-value stores running on commodity hardware and supporting a variety of platforms, including MacOS, Linux, and Windows.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"FoundationDB is an open-source project with a large code base written in C++. The code is heavily asynchronous, with its own form of distributed actors and runtime that provides a critically important deterministic simulation environment for testing purposes."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-caseStudy"}]},{"type":"paragraph","inlineContent":[{"text":"A complete rewrite would be a big, risky endeavor. Instead, we leveraged Swift‚Äôs interoperability to integrate into the existing code base. For example, here‚Äôs a part of the C++ implementation of FoundationDB‚Äôs ‚Äúmaster data‚Äù actor.","type":"text"},{"text":" ","type":"text"},{"text":"This function can be directly implemented as an async function in Swift.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC23-10164-caseStudy2"}]},{"text":"Wrap-up","type":"heading","level":2,"anchor":"Wrap-up"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Create more expressive APIs"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Tune low-level performance","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Interoperate with existing c++ code bases","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Adapt concurrency to your environment"}],"type":"paragraph"}]}]},{"text":"Resources","type":"heading","level":2,"anchor":"Resources"},{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/www.swift.org\/blog\/evolving-swift-project-workgroups\/","isActive":true,"type":"reference"},{"type":"text","text":""},{"type":"text","text":"\n"},{"identifier":"https:\/\/developer.apple.com\/forums\/create\/question?&tag1=235&tag2=678030","isActive":true,"type":"reference"},{"type":"text","text":""},{"type":"text","text":"\n"},{"identifier":"https:\/\/developer.apple.com\/forums\/tags\/wwdc2023-10164","isActive":true,"type":"reference"},{"type":"text","text":""},{"type":"text","text":"\n"},{"identifier":"https:\/\/github.com\/apple\/swift-cmake-examples","isActive":true,"type":"reference"},{"type":"text","text":""},{"type":"text","text":"\n"},{"identifier":"https:\/\/apple.github.io\/swift-evolution\/","isActive":true,"type":"reference"},{"type":"text","text":""},{"type":"text","text":"\n"},{"identifier":"https:\/\/www.swift.org\/blog\/future-of-foundation\/","isActive":true,"type":"reference"}]},{"text":"Related Videos","type":"heading","level":1,"anchor":"Related-Videos"},{"type":"paragraph","inlineContent":[{"overridingTitleInlineContent":[{"type":"text","text":"Beyond the basics of structured concurrency - WWDC23"}],"overridingTitle":"Beyond the basics of structured concurrency - WWDC23","type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10170","isActive":true},{"text":"","type":"text"},{"text":"\n","type":"text"},{"overridingTitleInlineContent":[{"text":"Expand on Swift macros - WWDC23","type":"text"}],"overridingTitle":"Expand on Swift macros - WWDC23","type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10167","isActive":true},{"text":"","type":"text"},{"text":"\n","type":"text"},{"overridingTitleInlineContent":[{"text":"Generalize APIs with parameter packs - WWDC23","type":"text"}],"overridingTitle":"Generalize APIs with parameter packs - WWDC23","type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10168","isActive":true},{"text":"","type":"text"},{"text":"\n","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10187","isActive":true},{"text":"","type":"text"},{"text":"\n","type":"text"},{"overridingTitleInlineContent":[{"text":"Mix Swift and C++","type":"text"}],"overridingTitle":"Mix Swift and C++","type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10172","isActive":true},{"text":"","type":"text"},{"text":"\n","type":"text"},{"overridingTitleInlineContent":[{"text":"Write Swift macros - WWDC23","type":"text"}],"overridingTitle":"Write Swift macros - WWDC23","type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10166","isActive":true},{"text":"","type":"text"},{"text":"\n","type":"text"},{"overridingTitleInlineContent":[{"text":"Swift concurrency: Behind the scenes - WWDC21","type":"text"}],"overridingTitle":"Swift concurrency: Behind the scenes - WWDC21","type":"reference","identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10254","isActive":true}]},{"text":"Written By","type":"heading","level":2,"anchor":"Written-By"},{"type":"row","numberOfColumns":5,"columns":[{"content":[{"inlineContent":[{"identifier":"kyaw-codes","type":"image"}],"type":"paragraph"}],"size":1},{"content":[{"anchor":"Kyaw-Zay-Ya-Lin-Tun","type":"heading","text":"Kyaw Zay Ya Lin Tun","level":3},{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/kyaw-codes","isActive":true,"overridingTitle":"Contributed Notes","type":"reference","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}]},{"type":"text","text":" "},{"type":"text","text":"|"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/kyaw-codes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/kyaw-codes.github.io\/","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/x.com\/KyawTheMonkey","type":"reference"}]}],"size":4}]},{"type":"row","numberOfColumns":5,"columns":[{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"multitudes"}]}],"size":1},{"content":[{"text":"laurent b","type":"heading","anchor":"laurent-b","level":3},{"type":"paragraph","inlineContent":[{"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"type":"reference","isActive":true,"overridingTitle":"Contributed Notes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/multitudes"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/multitudes"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/laurentbrusa.hashnode.dev\/"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/x.com\/wrmultitudes"}]}],"size":4}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}]},{"text":"Related Sessions","type":"heading","level":2,"anchor":"Related-Sessions"},{"type":"links","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10148-Whats-new-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10166-Write-Swift-macros","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10167-Expand-on-Swift-macros","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10168-Generalize-APIs-with-parameter-packs","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10172-Mix-Swift-and-C++","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10187-Meet-SwiftData","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"],"style":"list"},{"type":"small","inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright ¬© 2012 ‚Äì 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"references":{"https://developer.apple.com/videos/play/wwdc2023/10164/?time=1405":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1405","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1405","type":"link","title":"23:25 - Ownership","titleInlineContent":[{"type":"text","text":"23:25 - Ownership"}]},"kyaw-codes.jpeg":{"alt":null,"identifier":"kyaw-codes.jpeg","type":"image","variants":[{"url":"\/images\/kyaw-codes.jpeg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=1679":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1679","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1679","type":"link","title":"27:59 - C++ interoperability","titleInlineContent":[{"type":"text","text":"27:59 - C++ interoperability"}]},"WWDC23-10164-expandMacros":{"alt":"Expand Macros","identifier":"WWDC23-10164-expandMacros","type":"image","variants":[{"url":"\/images\/WWDC23-10164-expandMacros.jpeg","traits":["1x","light"]}]},"multitudes":{"alt":"Profile image of laurent b","identifier":"multitudes","type":"image","variants":[{"url":"\/images\/multitudes.jpeg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=1961":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1961","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1961","type":"link","title":"32:41 - What‚Äôs new in Swift Concurrency","titleInlineContent":[{"type":"text","text":"32:41 - What‚Äôs new in Swift Concurrency"}]},"https://developer.apple.com/videos/play/wwdc2023/10187":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10187","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10187","type":"link","title":"Meet SwiftData - WWDC23","titleInlineContent":[{"type":"text","text":"Meet SwiftData - WWDC23"}]},"WWDC23-10164-attachedMacroRoles":{"alt":"attachedMacroRoles","identifier":"WWDC23-10164-attachedMacroRoles","type":"image","variants":[{"url":"\/images\/WWDC23-10164-attachedMacroRoles.jpeg","traits":["1x","light"]}]},"https://github.com/apple/swift-cmake-examples":{"identifier":"https:\/\/github.com\/apple\/swift-cmake-examples","url":"https:\/\/github.com\/apple\/swift-cmake-examples","type":"link","title":"Swift CMake Examples","titleInlineContent":[{"type":"text","text":"Swift CMake Examples"}]},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","title":"Contributions are welcome!","titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}]},"https://laurentbrusa.hashnode.dev/":{"identifier":"https:\/\/laurentbrusa.hashnode.dev\/","url":"https:\/\/laurentbrusa.hashnode.dev\/","type":"link","title":"Blog","titleInlineContent":[{"type":"text","text":"Blog"}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=164":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=164","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=164","type":"link","title":"2:44 - Using if\/else and switch statements as expressions","titleInlineContent":[{"type":"text","text":"2:44 - Using if\/else and switch statements as expressions"}]},"https://www.swift.org/blog/evolving-swift-project-workgroups/":{"identifier":"https:\/\/www.swift.org\/blog\/evolving-swift-project-workgroups\/","url":"https:\/\/www.swift.org\/blog\/evolving-swift-project-workgroups\/","type":"link","title":"Evolving Swift Project Workgroups","titleInlineContent":[{"type":"text","text":"Evolving Swift Project Workgroups"}]},"WWDC23-10164-caseStudy2":{"alt":"case study with C++","identifier":"WWDC23-10164-caseStudy2","type":"image","variants":[{"url":"\/images\/WWDC23-10164-caseStudy2.jpg","traits":["1x","light"]}]},"WWDC23-10164-eachResult":{"alt":"Each Result","identifier":"WWDC23-10164-eachResult","type":"image","variants":[{"url":"\/images\/WWDC23-10164-eachResult.jpg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10170":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10170","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10170","type":"link","title":"Beyond the basics of structured concurrency - WWDC23","titleInlineContent":[{"type":"text","text":"Beyond the basics of structured concurrency - WWDC23"}]},"https://developer.apple.com/videos/play/wwdc2023/10167":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10167","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10167","type":"link","title":"Expand on Swift macros - WWDC23","titleInlineContent":[{"type":"text","text":"Expand on Swift macros - WWDC23"}]},"https://developer.apple.com/videos/play/wwdc2021/10254":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10254","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2021\/10254","type":"link","title":"Swift concurrency: Behind the scenes - WWDC21","titleInlineContent":[{"type":"text","text":"Swift concurrency: Behind the scenes - WWDC21"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23":{"abstract":[{"text":"Xcode 15, Swift 5.9, iOS 17, macOS 14 (Sonoma), tvOS 17, visionOS 1, watchOS 10.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"New APIs: "},{"type":"codeVoice","code":"SwiftData"},{"text":", ","type":"text"},{"code":"Observation","type":"codeVoice"},{"text":", ","type":"text"},{"code":"StoreKit","type":"codeVoice"},{"text":" views, and more.","type":"text"}],"images":[{"type":"icon","identifier":"WWDC23-Icon.png"},{"type":"card","identifier":"WWDC23.jpeg"}],"role":"collectionGroup","kind":"article","type":"topic","title":"WWDC23","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23","url":"\/documentation\/wwdcnotes\/wwdc23"},"https://github.com/multitudes":{"identifier":"https:\/\/github.com\/multitudes","url":"https:\/\/github.com\/multitudes","type":"link","title":"GitHub","titleInlineContent":[{"type":"text","text":"GitHub"}]},"WWDCNotes.png":{"alt":null,"identifier":"WWDCNotes.png","type":"image","variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=232":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=232","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=232","type":"link","title":"3:52 - Result builders","titleInlineContent":[{"type":"text","text":"3:52 - Result builders"}]},"https://developer.apple.com/forums/create/question?&tag1=235&tag2=678030":{"identifier":"https:\/\/developer.apple.com\/forums\/create\/question?&tag1=235&tag2=678030","url":"https:\/\/developer.apple.com\/forums\/create\/question?&tag1=235&tag2=678030","type":"link","title":"Have a question? Ask with tag wwdc2023-10164","titleInlineContent":[{"type":"text","text":"Have a question? Ask with tag wwdc2023-10164"}]},"doc://WWDCNotes/documentation/WWDCNotes/kyaw-codes":{"title":"Kyaw Zay Ya Lin Tun (3 notes)","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/kyaw-codes","type":"topic","url":"\/documentation\/wwdcnotes\/kyaw-codes","abstract":[{"text":"Senior iOS Developer @sgcodigo | Programming Mentor | Swift enthusiast","type":"text"}],"role":"sampleCode","images":[{"identifier":"kyaw-codes.jpeg","type":"card"},{"identifier":"kyaw-codes.jpeg","type":"icon"}]},"https://x.com/KyawTheMonkey":{"identifier":"https:\/\/x.com\/KyawTheMonkey","url":"https:\/\/x.com\/KyawTheMonkey","type":"link","title":"X\/Twitter","titleInlineContent":[{"type":"text","text":"X\/Twitter"}]},"WWDC23.jpeg":{"alt":null,"identifier":"WWDC23.jpeg","type":"image","variants":[{"url":"\/images\/WWDC23.jpeg","traits":["1x","light"]}]},"WWDC23-10164-consuming":{"alt":"consuming","identifier":"WWDC23-10164-consuming","type":"image","variants":[{"url":"\/images\/WWDC23-10164-consuming.jpeg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=1187":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1187","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=1187","type":"link","title":"19:47 - Swift foundation","titleInlineContent":[{"type":"text","text":"19:47 - Swift foundation"}]},"doc://WWDCNotes/documentation/WWDCNotes/multitudes":{"kind":"article","type":"topic","url":"\/documentation\/wwdcnotes\/multitudes","abstract":[{"text":"student at 42Berlin üê¨ | üçé Swift(UI) app dev  | speciality coffee ‚òïÔ∏è & cycling üö¥üèª‚Äç‚ôÇÔ∏è","type":"text"}],"title":"laurent b (33 notes)","role":"sampleCode","images":[{"type":"card","identifier":"multitudes.jpeg"},{"type":"icon","identifier":"multitudes.jpeg"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/multitudes"},"https://apple.github.io/swift-evolution/":{"identifier":"https:\/\/apple.github.io\/swift-evolution\/","url":"https:\/\/apple.github.io\/swift-evolution\/","type":"link","title":"Swift Evolution","titleInlineContent":[{"type":"text","text":"Swift Evolution"}]},"WWDC23-10164-macroAssert4":{"alt":"Macro Assert","identifier":"WWDC23-10164-macroAssert4","type":"image","variants":[{"url":"\/images\/WWDC23-10164-macroAssert4.jpg","traits":["1x","light"]}]},"WWDC23-10164-visionDocuments2":{"alt":"vision documents","identifier":"WWDC23-10164-visionDocuments2","type":"image","variants":[{"url":"\/images\/WWDC23-10164-visionDocuments2.jpg","traits":["1x","light"]}]},"WWDC23-10164-macroAssert":{"alt":"Macro Assert","identifier":"WWDC23-10164-macroAssert","type":"image","variants":[{"url":"\/images\/WWDC23-10164-macroAssert.jpg","traits":["1x","light"]}]},"https://x.com/wrmultitudes":{"identifier":"https:\/\/x.com\/wrmultitudes","url":"https:\/\/x.com\/wrmultitudes","type":"link","title":"X\/Twitter","titleInlineContent":[{"type":"text","text":"X\/Twitter"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10254-Swift-concurrency-Behind-the-scenes":{"title":"Swift concurrency: Behind the scenes","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes","kind":"article","abstract":[{"type":"text","text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We‚Äôll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps."}]},"WWDC23-10164-visionDocuments":{"alt":"vision documents","identifier":"WWDC23-10164-visionDocuments","type":"image","variants":[{"url":"\/images\/WWDC23-10164-visionDocuments.jpg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10166":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10166","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10166","type":"link","title":"Write Swift macros - WWDC23","titleInlineContent":[{"type":"text","text":"Write Swift macros - WWDC23"}]},"WWDC23-10164-macroAssert2":{"alt":"Macro Assert","identifier":"WWDC23-10164-macroAssert2","type":"image","variants":[{"url":"\/images\/WWDC23-10164-macroAssert2.jpg","traits":["1x","light"]}]},"https://www.swift.org/blog/future-of-foundation/":{"identifier":"https:\/\/www.swift.org\/blog\/future-of-foundation\/","url":"https:\/\/www.swift.org\/blog\/future-of-foundation\/","type":"link","title":"The Future of Foundation","titleInlineContent":[{"type":"text","text":"The Future of Foundation"}]},"https://kyaw-codes.github.io/":{"identifier":"https:\/\/kyaw-codes.github.io\/","url":"https:\/\/kyaw-codes.github.io\/","type":"link","title":"Blog","titleInlineContent":[{"type":"text","text":"Blog"}]},"WWDC23-10164-swiftEverywhere":{"alt":"Swift everywhere","identifier":"WWDC23-10164-swiftEverywhere","type":"image","variants":[{"url":"\/images\/WWDC23-10164-swiftEverywhere.jpg","traits":["1x","light"]}]},"WWDC23-Icon.png":{"alt":null,"identifier":"WWDC23-Icon.png","type":"image","variants":[{"url":"\/images\/WWDC23-Icon.png","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10187-Meet-SwiftData":{"type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10187-Meet-SwiftData","title":"Meet SwiftData","url":"\/documentation\/wwdcnotes\/wwdc23-10187-meet-swiftdata","abstract":[{"type":"text","text":"SwiftData is a powerful and expressive persistence framework built for Swift. We‚Äôll show you how you can model your data directly from Swift code, use SwiftData to work with your models, and integrate with SwiftUI."}],"role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10166-Write-Swift-macros":{"kind":"article","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc23-10166-write-swift-macros","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10166-Write-Swift-macros","role":"sampleCode","title":"Write Swift macros","abstract":[{"type":"text","text":"Discover how you can use Swift macros to make your codebase more expressive and easier to read. Code along as we explore how macros can help you avoid writing repetitive code and find out how to use them in your app. We‚Äôll share the building blocks of a macro, show you how to test it, and take you through how you can emit compilation errors from macros."}]},"WWDC23-10164-caseStudy":{"alt":"case study with C++","identifier":"WWDC23-10164-caseStudy","type":"image","variants":[{"url":"\/images\/WWDC23-10164-caseStudy.jpg","traits":["1x","light"]}]},"https://github.com/kyaw-codes":{"identifier":"https:\/\/github.com\/kyaw-codes","url":"https:\/\/github.com\/kyaw-codes","type":"link","title":"GitHub","titleInlineContent":[{"type":"text","text":"GitHub"}]},"WWDC23-10164-macroAssert3":{"alt":"Macro Assert","identifier":"WWDC23-10164-macroAssert3","type":"image","variants":[{"url":"\/images\/WWDC23-10164-macroAssert3.jpg","traits":["1x","light"]}]},"kyaw-codes":{"alt":"Profile image of Kyaw Zay Ya Lin Tun","identifier":"kyaw-codes","type":"image","variants":[{"url":"\/images\/kyaw-codes.jpeg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=293":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=293","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=293","type":"link","title":"4:53 - type parameter packs","titleInlineContent":[{"type":"text","text":"4:53 - type parameter packs"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10167-Expand-on-Swift-macros":{"url":"\/documentation\/wwdcnotes\/wwdc23-10167-expand-on-swift-macros","abstract":[{"text":"Discover how Swift macros can help you reduce boilerplate in your codebase and adopt complex features more easily. Learn how macros can analyze code, emit rich compiler errors to guide developers towards correct usage, and generate new code that is automatically incorporated back into your project. We‚Äôll also take you through important concepts like macro roles, compiler plugins, and syntax trees.","type":"text"}],"role":"sampleCode","title":"Expand on Swift macros","type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10167-Expand-on-Swift-macros"},"WWDC23-10164-interactWithCplusplus":{"alt":"interact with C++","identifier":"WWDC23-10164-interactWithCplusplus","type":"image","variants":[{"url":"\/images\/WWDC23-10164-interactWithCplusplus.jpeg","traits":["1x","light"]}]},"https://developer.apple.com/forums/tags/wwdc2023-10164":{"identifier":"https:\/\/developer.apple.com\/forums\/tags\/wwdc2023-10164","url":"https:\/\/developer.apple.com\/forums\/tags\/wwdc2023-10164","type":"link","title":"Search the forums for tag wwdc2023-10164","titleInlineContent":[{"type":"text","text":"Search the forums for tag wwdc2023-10164"}]},"https://developer.apple.com/videos/play/wwdc2023/10168":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10168","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10168","type":"link","title":"Generalize APIs with parameter packs - WWDC23","titleInlineContent":[{"type":"text","text":"Generalize APIs with parameter packs - WWDC23"}]},"https://developer.apple.com/wwdc23/10164":{"identifier":"https:\/\/developer.apple.com\/wwdc23\/10164","url":"https:\/\/developer.apple.com\/wwdc23\/10164","type":"download","checksum":null},"doc://WWDCNotes/documentation/WWDCNotes":{"role":"collection","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"url":"\/documentation\/wwdcnotes","title":"WWDC Notes","type":"topic","kind":"symbol"},"WWDC23-10164-IMG_FFC563B46E50-1":{"alt":null,"identifier":"WWDC23-10164-IMG_FFC563B46E50-1","type":"image","variants":[{"url":"\/images\/WWDC23-10164-IMG_FFC563B46E50-1.jpeg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10168-Generalize-APIs-with-parameter-packs":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10168-Generalize-APIs-with-parameter-packs","role":"sampleCode","abstract":[{"type":"text","text":"Swift parameter packs are a powerful tool to expand what is possible in your generic code while also enabling you to simplify common generic patterns. We‚Äôll show you how to abstract over types as well as the number of arguments in generic code and simplify common generic patterns to avoid overloads."}],"title":"Generalize APIs with parameter packs","url":"\/documentation\/wwdcnotes\/wwdc23-10168-generalize-apis-with-parameter-packs","kind":"article","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10172-Mix-Swift-and-C++":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10172-Mix-Swift-and-C++","type":"topic","title":"Mix Swift and C++","role":"sampleCode","abstract":[{"type":"text","text":"Learn how you can use Swift in your C++ and Objective-C++ projects to make your code safer, faster, and easier to develop. We‚Äôll show you how to use C++ and Swift APIs to incrementally incorporate Swift into your app."}],"kind":"article","url":"\/documentation\/wwdcnotes\/wwdc23-10172-mix-swift-and-c++"},"multitudes.jpeg":{"alt":null,"identifier":"multitudes.jpeg","type":"image","variants":[{"url":"\/images\/multitudes.jpeg","traits":["1x","light"]}]},"WWDC23-10164-swiftEverywhere2":{"alt":"Swift everywhere","identifier":"WWDC23-10164-swiftEverywhere2","type":"image","variants":[{"url":"\/images\/WWDC23-10164-swiftEverywhere2.jpg","traits":["1x","light"]}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=39":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=39","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=39","type":"link","title":"0:39 - Swift project update","titleInlineContent":[{"type":"text","text":"0:39 - Swift project update"}]},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=2300":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=2300","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=2300","type":"link","title":"38:20 - FoundationDB: A case study","titleInlineContent":[{"type":"text","text":"38:20 - FoundationDB: A case study"}]},"WWDC23-10164-IMG_9B4379D3B587-1":{"alt":null,"identifier":"WWDC23-10164-IMG_9B4379D3B587-1","type":"image","variants":[{"url":"\/images\/WWDC23-10164-IMG_9B4379D3B587-1.jpeg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10148-Whats-new-in-SwiftUI":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10148-Whats-new-in-SwiftUI","type":"topic","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc23-10148-whats-new-in-swiftui","title":"What‚Äôs new in SwiftUI","role":"sampleCode","abstract":[{"text":"Learn how you can use SwiftUI to build great apps for all Apple platforms. Explore the latest updates to SwiftUI and discover new scene types for visionOS. Simplify your data models with the latest data flow options and learn about the Inspector view. We‚Äôll also take you through enhanced animation APIs, powerful ScrollView improvements, and a host of refinements to help you make tidier tables, improve focus and keyboard input, and so much more.","type":"text"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10170-Beyond-the-basics-of-structured-concurrency":{"url":"\/documentation\/wwdcnotes\/wwdc23-10170-beyond-the-basics-of-structured-concurrency","role":"sampleCode","kind":"article","abstract":[{"type":"text","text":"It‚Äôs all about the task tree: Find out how structured concurrency can help your apps manage automatic task cancellation, task priority propagation, and useful task-local value patterns. Learn how to manage resources in your app with useful patterns and the latest task group APIs. We‚Äôll show you how you can leverage the power of the task tree and task-local values to gain insight into distributed systems."}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","title":"Beyond the basics of structured concurrency"},"https://developer.apple.com/videos/play/wwdc2023/10164/?time=574":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=574","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10164\/?time=574","type":"link","title":"9:34 - Swift macros","titleInlineContent":[{"type":"text","text":"9:34 - Swift macros"}]},"https://developer.apple.com/videos/play/wwdc2023/10172":{"identifier":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10172","url":"https:\/\/developer.apple.com\/videos\/play\/wwdc2023\/10172","type":"link","title":"Mix Swift and C++","titleInlineContent":[{"type":"text","text":"Mix Swift and C++"}]}}}