{"metadata":{"roleHeading":"WWDC20","modules":[{"name":"WWDC Notes"}],"role":"sampleCode","title":"Triage test failures with XCTIssue"},"abstract":[{"type":"text","text":"Put your test failures to work: Learn how to triage and diagnose uncaught issues in your app using the latest testing APIs in Xcode. We’ll show you how to help ease your testing workflow and put failures into context to help you deliver the best quality product."}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc20-10687-triage-test-failures-with-xctissue"]}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20"]]},"sections":[],"kind":"article","sampleCodeDownload":{"action":{"identifier":"https:\/\/developer.apple.com\/wwdc20\/10687","overridingTitle":"Watch Video (12 min)","isActive":true,"type":"reference"},"kind":"sampleDownload"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10687-Triage-test-failures-with-XCTIssue"},"primaryContentSections":[{"content":[{"level":2,"text":"Overview","anchor":"Overview","type":"heading"},{"inlineContent":[{"text":"Maintaining any active project requires investigating test failures, either locally or in Continuous Integration (CI). Investigating test failures requires answering the following questions:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"What failed?"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"How did it fail?","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Why did it fail?"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Where","type":"text"}]},{"text":" did it fail?","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Xcode 12 makes answering these questions more efficient. This talk covers the following 4 topics:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Swift errors in tests"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Rich failure objects"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Failure call stacks","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Advanced workflows","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"level":2,"text":"Presenting Test Failures in Xcode 12","anchor":"Presenting-Test-Failures-in-Xcode-12","type":"heading"},{"level":3,"text":"Issue Navigator","anchor":"Issue-Navigator","type":"heading"},{"inlineContent":[{"type":"text","text":"This is an example of a test failure. Notice how the annotation is gray. This indicates that the failure happened underneath the indicated line. On the left, the issue navigator shows a call stack under the failed test."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10687-gray_line"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Clicking on a frame takes the source editor to that location. Now, the annotation is red because this is the actual source of the error."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10687-error_source"}],"type":"paragraph"},{"level":3,"text":"Test Report","anchor":"Test-Report","type":"heading"},{"inlineContent":[{"text":"The Test Report is another way to explore test failures, and is especially useful when working with the results of a CI failure.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here, we can see a list of failing tests, each with a call stack. When you hover over a stack frame, you can see two buttons to the right. The Jump button, indicated with an arrow, jumps to the source of the error. The second button, called the Assistant button, is new in Xcode 12. This does the same thing as the Jump button, but opens a secondary editor next to the Test Report so you don’t have to go back and forth. Clicking on a different stack frame changes the secondary editor immediately."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10687-assistant_button"}],"type":"paragraph"},{"level":2,"text":"1. Using Swift Errors in your tests","anchor":"1-Using-Swift-Errors-in-your-tests","type":"heading"},{"inlineContent":[{"type":"text","text":"XCTest makes it possible for test functions to throw. When a test does throw, the error is used to formulate the error message."}],"type":"paragraph"},{"inlineContent":[{"text":"This means you can replace boilerplate like this in your tests…","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func testExample() {","  do {","    try codeThatThrows()","  } catch {","    XCTFail(\"\\(error)\")","  }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"…with this:"}],"type":"paragraph"},{"syntax":"swift","code":["func testExample() throws {","  try codeThatThrows()","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"However, until recently, these failures could not provide the source code location for thrown errors in tests. That has now been fixed with the Swift runtime improvements in the following platforms:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"iOS and tvOS 13.4"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"macOS 10.15.4"}]}]}],"type":"unorderedList"},{"level":3,"text":"Throwing from setUp and tearDown","anchor":"Throwing-from-setUp-and-tearDown","type":"heading"},{"inlineContent":[{"text":"Similar improvements have also been brought to ","type":"text"},{"type":"codeVoice","code":"setUp()"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"tearDown()"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC20-10687-throwing_setup_teardown","type":"image"}],"type":"paragraph"},{"level":2,"text":"2. Rich Failure Objects","anchor":"2-Rich-Failure-Objects","type":"heading"},{"inlineContent":[{"type":"text","text":"XCTest has always recorded test failures as 4 discrete values:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Failure message","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"File path"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Line number where the failure was recorded","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"“Expected” flag to indicate if the failure was expected.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"text":"These values were passed into the ","type":"text"},{"code":"recordFailure","type":"codeVoice"},{"text":" API, which ensures that failures are logged and routed to Xcode for display:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["open class XCTestCase: XCTest {","","  open func recordFailure(","    withDescription: String,","    inFile: String,","    atLine: Int,","    expected: Bool","  )","","}"],"type":"codeListing"},{"inlineContent":[{"text":"In Xcode 12, these values have been encapsulated into a new struct ","type":"text"},{"type":"codeVoice","code":"XCTIssue"},{"text":". This new type also adds:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Distinct types"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Detailed description"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Associated error","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Attachments"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"text":"`XCTAttachment`","anchor":"XCTAttachment","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Can capture arbitrary data"}]}]},{"content":[{"inlineContent":[{"text":"Add this attachment to the test itself or an ","type":"text"},{"code":"XCTActivity","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"XCTIssue","type":"codeVoice"},{"type":"text","text":" supports attachments, which allows customized diagnostics for test failures."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"text":"Recording `XCTIssue`s","anchor":"Recording-XCTIssues","type":"heading"},{"inlineContent":[{"text":"There is a new API on ","type":"text"},{"code":"XCTestCase","type":"codeVoice"},{"text":" for recording test failures, which is called by all types of asserts. The old ","type":"text"},{"code":"recordFailure","type":"codeVoice"},{"text":" API has been deprecated.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["open class XCTestCase: XCTest {","","  open func record(_ issue: XCTIssue)","","}"],"type":"codeListing"},{"level":3,"text":"Modifying issues","anchor":"Modifying-issues","type":"heading"},{"inlineContent":[{"type":"text","text":"In Swift, issues are immutable or mutable depending on your use of "},{"code":"let","type":"codeVoice"},{"type":"text","text":" or "},{"code":"var","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["let issue = XCTIssue(...)  \/\/ immutable","","var issue = XCTIssue(...)  \/\/ mutable"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In Objective-C, there is a special subclass for mutable issues which conforms to ","type":"text"},{"type":"codeVoice","code":"NSMutableCopy"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"objectivec","code":["XCTIssue *issue = [[XCTIssue alloc] init ...];  \/\/ immutable","","XCTMutableIssue *mutableIssue = [issue mutableCopy];  \/\/ mutable"]},{"type":"heading","anchor":"3-Failures-and-Source-Code","level":2,"text":"3. Failures and Source Code"},{"type":"paragraph","inlineContent":[{"text":"One of the most important questions to answer about a test failure is “where did it happen?”.","type":"text"}]},{"type":"heading","anchor":"Before-XCTIssue","level":3,"text":"Before `XCTIssue`"},{"type":"paragraph","inlineContent":[{"text":"Core test failure data always included file path and line number, which is great for simple tests. This is not enough for functions that are shared by more than one test.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here are two tests calling the same shared function:"}]},{"type":"codeListing","syntax":"swift","code":["func testThingA() throws {","  let thing = Thing(\"a\")","  try assertProperties(for: thing)","}","","func testThingB() throws {","  let thing = Thing(\"b\")","  try assertProperties(for: thing)","}","","\/\/ Shared function","func assertProperties(for thing: Thing) throws {","  XCTAssertNotNil(thing.name)","  XCTAssertNotNil(thing.order)","}"]},{"type":"paragraph","inlineContent":[{"text":"Before, the test method would be marked as failing even though the failure occurred somewhere else. This has no further information to help the developer figure out ","type":"text"},{"type":"strong","inlineContent":[{"text":"where","type":"text"}]},{"text":" the failure happened.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC20-10687-shared_failure","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"This can be mitigated if the helper functions captures information from where it was invoked and explicitly uses that information in its assertion calls. However, if the helper has more than 1 assertion, there is now a different ambiguity: which assertion failed in the helper?","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC20-10687-capture_helper"}]},{"type":"heading","anchor":"Now-with-XCTIssue","level":3,"text":"Now with `XCTIssue`"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"code":"XCTIssue","type":"codeVoice"},{"text":" captures and symbolicates call stacks","type":"text"}]},{"type":"text","text":" so the point of failure is more clear. Here, the same code now has a gray annotation to demonstrate that the failure happens lower in the call stack, and a red annotation where the failure actually occurs."}]},{"type":"paragraph","inlineContent":[{"identifier":"WWDC20-10687-failure_with_xctissue","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Most importantly, no extra effort was required to get this information.","type":"text"}]},{"type":"heading","anchor":"4-Advanced-Workflows-with-new-APIs","level":2,"text":"4. Advanced Workflows with new APIs"},{"type":"heading","anchor":"Advanced-Workflow-1-Custom-Assertions","level":3,"text":"Advanced Workflow 1: Custom Assertions"},{"type":"paragraph","inlineContent":[{"text":"You can make your own assertions by creating ","type":"text"},{"code":"XCTIssue","type":"codeVoice"},{"text":" directly and then ","type":"text"},{"code":"record(_ issue:)","type":"codeVoice"},{"text":". In this example, the custom assertion validates some data and then includes the failure as an attachment to the issue that it records.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func assertSomething(","  about data: Data,","  file: StaticString = #filePath,","  line: UInt = #line",") {","  \/\/ Call out to custom validation function.","  guard !isValid(data) else { return }","","  \/\/ Create issue, declare with `var` for mutability.","  var issue = XCTIssue(type: .assertionFailure, compactDescription: \"Invalid data\")","","  \/\/ Attach the invalid data.","  issue.add(XCTAttachment(data: data))","","  \/\/ Capture the call site location as the point of failure.","  let location = XCTSourceCodeLocation(filepath: file, lineNumber: line)","  issue.sourceCodeContext = XCTSourceCodeContext(location: location)","","  \/\/ Record the issue.","  self.record(issue)","}"]},{"type":"heading","anchor":"Advanced-Workflow-2-Overriding-record-issue","level":3,"text":"Advanced Workflow 2: Overriding `record(_ issue:)`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can observe, suppress, or modify failures recorded in your test class. This method is the funnel point through which all issues pass, so overrides have total control over the output of the test class."}]},{"type":"heading","anchor":"Example-1-Overriding-for-Observation","level":4,"text":"Example 1: Overriding for Observation"},{"type":"codeListing","syntax":"swift","code":["override func record(_ issue: XCTIssue) {","  \/\/ Observe, introspect, log, etc:","  if shouldLog(issue) {","    print(\"I just observed an issue!\")","  }","","  \/\/ Don't forget to call super!","  super.record(issue)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use "},{"code":"XCTestObservationCenter","type":"codeVoice"},{"type":"text","text":", but this approach is more useful if you only want to observe failures in one class."}]},{"type":"paragraph","inlineContent":[{"text":"If your override does ","type":"text"},{"type":"strong","inlineContent":[{"text":"not","type":"text"}]},{"text":" call ","type":"text"},{"code":"super","type":"codeVoice"},{"text":", you will have suppressed the issue. It will not continue along the recording chain, and nothing will be sent to Xcode.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["override func record(_ issue: XCTIssue) {","  \/\/ If you don't want to record it, just return.","  if shouldSuppress(issue) {","    return","  }","","  \/\/ Otherwise, pass it to `super`.","  super.record(issue)","}"]},{"type":"heading","anchor":"Example-2-Overriding-for-Modification","level":4,"text":"Example 2: Overriding for Modification"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is the most common reason for overriding because you can add attachments, which can be great diagnostic aids."}]},{"type":"codeListing","syntax":"swift","code":["override func record(_ issue: XCTIssue) {","  \/\/ Redeclare using `var` to enable mutation.","  var issue = issue","","  \/\/ Add a simple attachment.","  issue.add(XCTAttachment(string: \"hello\"))","","  \/\/ Pass it to `super`.","  super.record(issue)","}"]},{"type":"heading","anchor":"Wrap-Up","level":2,"text":"Wrap Up"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Triaging test failures is important!"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Call stacks help answer “where?”"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"This helps support more natural factoring of test code, such as code reuse and other best practices"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Attachments improve “how?” and “why?”","type":"text"}]}]}]},{"type":"heading","anchor":"Written-By","level":2,"text":"Written By"},{"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"identifier":"skhillon","type":"image"}],"type":"paragraph"}]},{"size":4,"content":[{"text":"Sarthak Khillon","anchor":"Sarthak-Khillon","level":3,"type":"heading"},{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/github.com\/skhillon","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"https:\/\/x.com\/SarthakKhillon","type":"reference"}],"type":"paragraph"}]}],"numberOfColumns":5},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"isActive":true,"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}]},{"type":"heading","anchor":"Related-Sessions","level":2,"text":"Related Sessions"},{"type":"links","style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10077-Eliminate-animation-hitches-with-XCTest","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10091-Write-tests-to-fail","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10164-XCTSkip-your-tests","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10220-Handle-interruptions-and-alerts-in-UI-tests","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10221-Get-your-test-results-faster"]},{"type":"small","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Legal Notice"}]}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"references":{"WWDC20.jpeg":{"type":"image","alt":null,"identifier":"WWDC20.jpeg","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20.jpeg"}]},"https://www.linkedin.com/in/sarthakkhillon/":{"type":"link","title":"Blog","titleInlineContent":[{"text":"Blog","type":"text"}],"url":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/"},"doc://WWDCNotes/documentation/WWDCNotes/skhillon":{"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","images":[{"type":"card","identifier":"skhillon.jpeg"},{"type":"icon","identifier":"skhillon.jpeg"}],"abstract":[{"type":"text","text":"No Bio on GitHub"}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/skhillon","title":"Sarthak Khillon (19 notes)","type":"topic"},"https://github.com/skhillon":{"type":"link","title":"GitHub","titleInlineContent":[{"text":"GitHub","type":"text"}],"url":"https:\/\/github.com\/skhillon","identifier":"https:\/\/github.com\/skhillon"},"WWDC20-10687-error_source":{"type":"image","alt":null,"identifier":"WWDC20-10687-error_source","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-error_source.png"}]},"WWDC20-Icon.png":{"type":"image","alt":null,"identifier":"WWDC20-Icon.png","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-Icon.png"}]},"WWDC20-10687-gray_line":{"type":"image","alt":null,"identifier":"WWDC20-10687-gray_line","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-gray_line.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10221-Get-your-test-results-faster":{"abstract":[{"text":"Improve your testing suite to speed up your feedback loop and get fixes in faster. Learn more about the latest improvements to testing in Xcode, including how to leverage test plans, Xcodebuild updates, and APIs to eliminate never-ending and badly-behaved tests. We’ll explore Test Timeouts and Execution Time Allowances in XCTest, examine device parallelization, and detail recommended practices for balancing performance with clear fault localization.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc20-10221-get-your-test-results-faster","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10221-Get-your-test-results-faster","kind":"article","title":"Get your test results faster","role":"sampleCode"},"WWDC20-10687-capture_helper":{"type":"image","alt":null,"identifier":"WWDC20-10687-capture_helper","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-capture_helper.png"}]},"WWDC20-10687-failure_with_xctissue":{"type":"image","alt":null,"identifier":"WWDC20-10687-failure_with_xctissue","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-failure_with_xctissue.png"}]},"WWDC20-10687-shared_failure":{"type":"image","alt":null,"identifier":"WWDC20-10687-shared_failure","variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-shared_failure.png"}]},"https://developer.apple.com/wwdc20/10687":{"type":"download","checksum":null,"url":"https:\/\/developer.apple.com\/wwdc20\/10687","identifier":"https:\/\/developer.apple.com\/wwdc20\/10687"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10164-XCTSkip-your-tests":{"url":"\/documentation\/wwdcnotes\/wwdc20-10164-xctskip-your-tests","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10164-XCTSkip-your-tests","abstract":[{"type":"text","text":"Get the test results that matter — and skip the ones that don’t. Discover how you can implement XCTSkip to conditionally avoid tests at runtime. We’ll take you through how to return this new test result and better document tests beyond pass and fail within your test bundle."}],"role":"sampleCode","title":"XCTSkip your tests","kind":"article"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20":{"kind":"article","type":"topic","title":"WWDC20","role":"collectionGroup","images":[{"type":"icon","identifier":"WWDC20-Icon.png"},{"type":"card","identifier":"WWDC20.jpeg"}],"abstract":[{"type":"text","text":"Xcode 12, Swift 5.3, iOS 14, macOS 11 (Big Sur), tvOS 14, watchOS 7."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"code":"WidgetKit","type":"codeVoice"},{"type":"text","text":", "},{"code":"StoreKit Testing","type":"codeVoice"},{"type":"text","text":", and more."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20","url":"\/documentation\/wwdcnotes\/wwdc20"},"skhillon":{"identifier":"skhillon","type":"image","alt":"Profile image of Sarthak Khillon","variants":[{"traits":["1x","light"],"url":"\/images\/skhillon.jpeg"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10091-Write-tests-to-fail":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10091-Write-tests-to-fail","abstract":[{"text":"Plan for failure: Design great tests to help you find and diagnose even the toughest bugs. Learn how to improve your automated tests with XCTest to find hidden issues in even the best code. We’ll explain how to prepare your tests for failure to make triaging issues easier, letting you solve interface issues and deliver fixes quickly.","type":"text"}],"type":"topic","kind":"article","role":"sampleCode","title":"Write tests to fail","url":"\/documentation\/wwdcnotes\/wwdc20-10091-write-tests-to-fail"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10220-Handle-interruptions-and-alerts-in-UI-tests":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10220-Handle-interruptions-and-alerts-in-UI-tests","abstract":[{"text":"Learn how to anticipate potential interruptions to your app’s interface and build smart tests to identify them. UI interruptions often appear indeterminately, typically during onboarding or first launch, which can make them hard to track down. Learn how to understand interruptions, write stronger tests with UI interruption handlers, and manage expected alerts.","type":"text"}],"type":"topic","kind":"article","role":"sampleCode","title":"Handle interruptions and alerts in UI tests","url":"\/documentation\/wwdcnotes\/wwdc20-10220-handle-interruptions-and-alerts-in-ui-tests"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"title":"Contributions are welcome!"},"skhillon.jpeg":{"identifier":"skhillon.jpeg","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/skhillon.jpeg"}]},"WWDC20-10687-assistant_button":{"identifier":"WWDC20-10687-assistant_button","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-assistant_button.png"}]},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","type":"topic","title":"WWDC Notes","role":"collection","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","url":"\/documentation\/wwdcnotes"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10077-Eliminate-animation-hitches-with-XCTest":{"title":"Eliminate animation hitches with XCTest","url":"\/documentation\/wwdcnotes\/wwdc20-10077-eliminate-animation-hitches-with-xctest","type":"topic","abstract":[{"type":"text","text":"Animations can dramatically enhance the user experience of your app, provide a sense of direct manipulation, and help people to better understand the results of their actions. Animation hitches can break that experience. Discover how to use XCTest to detect interruptions to smooth scrolling and animations, and learn how to catch regressions before they affect the people relying on your app."}],"role":"sampleCode","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10077-Eliminate-animation-hitches-with-XCTest"},"WWDC20-10687-throwing_setup_teardown":{"identifier":"WWDC20-10687-throwing_setup_teardown","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC20-10687-throwing_setup_teardown.png"}]},"https://x.com/SarthakKhillon":{"identifier":"https:\/\/x.com\/SarthakKhillon","url":"https:\/\/x.com\/SarthakKhillon","type":"link","titleInlineContent":[{"text":"X\/Twitter","type":"text"}],"title":"X\/Twitter"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}]}}}