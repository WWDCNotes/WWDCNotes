{"kind":"article","identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10648-Unsafe-Swift","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc20-10648-unsafe-swift"]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"sampleCodeDownload":{"kind":"sampleDownload","action":{"isActive":true,"identifier":"https:\/\/developer.apple.com\/wwdc20\/10648","overridingTitle":"Watch Video (22 min)","type":"reference"}},"primaryContentSections":[{"content":[{"text":"Overview","type":"heading","level":2,"anchor":"overview"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"To get the most out of this session, you should have some familiarity with Swift and the C programming language.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The following notes will assume you understand pointers in C.","type":"text"}]}],"name":"Note"},{"text":"`Unsafe` and `Safe`","type":"heading","level":2,"anchor":"Unsafe-and-Safe"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The distinction between safe and unsafe constructs is the way their implementations deal with invalid input."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Most operations in the standard library fully validate their input before executing."}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Safe","type":"text"}],"type":"strong"},{"text":" operations have ","type":"text"},{"inlineContent":[{"type":"text","text":"well-defined"}],"type":"strong"},{"text":" behavior on ","type":"text"},{"inlineContent":[{"text":"all","type":"text"}],"type":"strong"},{"text":" input.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Unsafe"}],"type":"strong"},{"type":"text","text":" operations have "},{"inlineContent":[{"text":"undefined","type":"text"}],"type":"strong"},{"type":"text","text":" behavior on "},{"inlineContent":[{"type":"text","text":"some"}],"type":"strong"},{"type":"text","text":" input."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Force unwrap operator is "},{"type":"strong","inlineContent":[{"type":"text","text":"safe"}]},{"type":"text","text":" because we can fully describe its behavior for all possible inputs."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Optional provides an "},{"type":"strong","inlineContent":[{"type":"text","text":"unsafe"}]},{"type":"text","text":" force-unwrapping operation through its "},{"type":"codeVoice","code":"unsafelyUnwrapped"},{"type":"text","text":" property. This property does "},{"type":"strong","inlineContent":[{"text":"not","type":"text"}]},{"type":"text","text":" verify the underlying value to be non-nil."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"By using ","type":"text"},{"code":"unsafe","type":"codeVoice"},{"text":" properties, you assume full responsibility to fulfill its requirements.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","code":["\/\/ Optional's force unwrapping operator","","let value: Int? = nil","","print(value!) \/\/ Fatal error: Unexpectedly found nil while unwrapping an Optional value"],"type":"codeListing"},{"syntax":"swift","code":["\/\/ Unsafe force-unwrapping","","let value: String? = \"Hello\"","","print(value.unsafelyUnwrapped) \/\/ Hello"],"type":"codeListing"},{"syntax":"swift","code":["\/\/ Invalid use of unsafe force-unwrapping","","let value: String? = nil","","print(value.unsafelyUnwrapped) \/\/ Guaranteed fatal error only in debug builds"],"type":"codeListing"},{"text":"Benefits of `unsafe` interfaces","type":"heading","level":3,"anchor":"Benefits-of-unsafe-interfaces"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Interoperability with code written in C or Objective-C."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Control over runtime performance."}]}]}],"type":"unorderedList"},{"text":"Safe code ≠ no crashes","type":"heading","level":3,"anchor":"Safe-code-%E2%89%A0-no-crashes"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Safe APIs guarantee to stop execution by raising a fatal runtime error."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift is a safe programming language means its language and library-level features fully validate their input."}]}]}],"type":"unorderedList"},{"text":"Unsafe Pointers","type":"heading","level":2,"anchor":"Unsafe-Pointers"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unsafe pointer types are roughly on the same level of abstraction as pointers in the C programming language."}]}]}],"type":"unorderedList"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Treat it as a C pointer. Think about "},{"type":"codeVoice","code":"malloc()"},{"type":"text","text":", "},{"type":"codeVoice","code":"calloc()"},{"type":"text","text":", "},{"type":"codeVoice","code":"free()"},{"type":"text","text":", how C treats an array and array arithmetic in C."}]}],"name":"Note"},{"text":"Memory","type":"heading","level":3,"anchor":"Memory"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC20-10648-memory"}]},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"This picture shows memory from lower memory address (top) to higher memory address (bottom).","type":"text"}]}],"name":"Note"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Swift has a flat memory model."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A linear address space of individually addressable 8-bit bytes (64-bit)."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Memory address is a hexadecimal integer value."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"As app executes, the state of its memory keeps evolving.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Manual memory management example","type":"heading","level":3,"anchor":"Manual-memory-management-example"},{"syntax":"swift","code":["let ptr = UnsafeMutablePointer<Int>.allocate(capacity: 1)","ptr.initialize(to: 42)","print(ptr.pointee) \/\/ 42","ptr.deallocate()","ptr.pointee = 23 \/\/ UNDEFINED BEHAVIOR"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Allocating an "},{"code":"UnsafeMutablePointer<Int>","type":"codeVoice"},{"type":"text","text":" creates a storage location and gives back a pointer to it."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Pointer gets invalidated as the underlying memory is deinitialized and deallocated."}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"ptr.pointee"},{"type":"text","text":" is dereferencing pointer "},{"type":"codeVoice","code":"ptr"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Dereferencing a ","type":"text"},{"type":"codeVoice","code":"NULL"},{"text":" pointer is a serious programming error.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Xcode provides Address Sanitizer to help you catch memory corruption errors."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For more, refer to "},{"type":"reference","identifier":"..\/10167\/","isActive":true},{"type":"text","text":" session."}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"WWDC20-10648-address_sanitizer"}]},{"text":"Mapping C pointers to Swift","type":"heading","level":3,"anchor":"Mapping-C-pointers-to-Swift"},{"type":"paragraph","inlineContent":[{"text":"A big reason to use pointers in Swift is interoperability with unsafe languages like C or Objective-C.","type":"text"},{"text":" ","type":"text"},{"identifier":"WWDC20-10648-c_pointers_mapping","type":"image"}]},{"syntax":"swift","code":["\/\/ C:","void process_integers(const int *start, size_t count);","","\/\/ Swift:","func process_integers(_ start: UnsafePointer<CInt>!, _ count: Int)"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"C function processes a buffer of integer values."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"const int *start","type":"codeVoice"},{"type":"text","text":" gets translated into an implicitly unwrapped Optional unsafe pointer type in Swift."}]}]}],"type":"unorderedList"},{"text":"Use a pointer","type":"heading","level":2,"anchor":"Use-a-pointer"},{"syntax":"swift","code":["let start = UnsafeMutablePointer<CInt>.allocate(capacity: 4)","","start.initialize(to: 0)","(start + 1).initialize(to: 2)","(start + 2).initialize(to: 4)","(start + 3).initialize(to: 6)","","process_integers(start, 4)","","start.deinitialize(count: 4)","start.deallocate()"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Use "},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/unsafemutablepointer","isActive":true},{"type":"text","text":" to allocate a dynamic buffer suitable for holding integer values."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Use pointer arithmetic and dedicated initialization methods to set up the buffer’s elements to particular values."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Call the C function, passing it the pointer to the initialized buffer."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Deinitialize and deallocate the buffer.","type":"text"}]}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"🚨 Every step is fundamentally ","type":"text"},{"inlineContent":[{"text":"unsafe","type":"text"}],"type":"strong"},{"text":":","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The lifetime of the allocated buffer is not managed by the return pointer.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remember to manually deallocate it at the appropriate time, or it will cause a memory leak."}]}]},{"content":[{"inlineContent":[{"text":"Initialization cannot automatically verify that the addressed location is allocated.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Deinitialization only makes sense if the underlying memory has been previously initialized with values the correct type."}]}]}],"type":"unorderedList"},{"text":"Buffer Pointers","type":"heading","level":2,"anchor":"Buffer-Pointers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift Standard Library provides four unsafe buffer pointer types:"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafeBufferPointer<Element>"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafeMutableBufferPointer<Element>"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafeRawBufferPointer<Element>"},{"type":"text","text":" "},{"type":"codeVoice","code":"UnsafeMutableRawBufferPointer <Element>"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Buffer pointers check against out-of-bounds access through their subscript operation, which adds a little safety to it.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Accessing contiguous collection storage","type":"heading","level":2,"anchor":"Accessing-contiguous-collection-storage"},{"syntax":"swift","code":["Sequence.withContiguousStorageIfAvailable(_:)","MutableCollection.withContiguousMutableStorageIfAvailable(_:)","","String.withCString(_:)","String.withUTF8(_:)","","Array.withUnsafeBytes(_:)","Array.withUnsafeBufferPointer(_:)","Array.withUnsafeMutableBytes(_:)","Array.withUnsafeMutableBufferPointer(_:)"],"type":"codeListing"},{"text":"Temporary pointers","type":"heading","level":2,"anchor":"Temporary-pointers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Get a temporary pointer to an individual Swift value, then pass to C functions."}]},{"syntax":"swift","code":["withUnsafePointer(to:_:)","withUnsafeMutablePointer(to:_:)","withUnsafeBytes(of:_:)","withUnsafeMutableBytes(of:_:)"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"text":"Generated pointers is only valid for the duration of the closure’s execution. (Before it get deallocated from stack.)","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","code":["\/\/ C:","void process_integers(const int *start, size_t count);","","\/\/ Swift:","let values: [CInt] = [0, 2, 4, 6]","","values.withUnsafeBufferPointer { buffer in","  print_integers(buffer.baseAddress!, buffer.count)","}"],"type":"codeListing"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Store input data in an Array value.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Use ","type":"text"},{"code":"withUnsafeBufferPointer","type":"codeVoice"},{"text":" method to temporarily get direct access to the array’s underlying storage.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Extract the start address and count values, pass them directly to the C function."}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Special syntax:","type":"heading","level":3,"anchor":"Special-syntax"},{"syntax":"swift","code":["let values: [CInt] = [0, 2, 4, 6]","","print_integers(values, values.count)"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"text":"Simply pass an array value to a function expecting an unsafe pointer.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The compiler will automatically generate the equivalent "},{"type":"codeVoice","code":"withUnsafeBufferPointer"},{"type":"text","text":" for us."}]}]}],"type":"unorderedList"},{"text":"Implicit value-to-pointer conversions:","type":"heading","level":3,"anchor":"Implicit-value-to-pointer-conversions"},{"type":"paragraph","inlineContent":[{"identifier":"WWDC20-10648-value_to_pointer","type":"image"}]},{"text":"Example","type":"heading","level":2,"anchor":"Example"},{"type":"paragraph","inlineContent":[{"text":"Here is a C function provided by the Darwin module that we can use to query or update low-level information about the running system.","type":"text"}]},{"syntax":"swift","code":["\/\/ C:","int sysctl(int *name, u_int namelen,","\t\t\t\t void *oldp, size_t *oldlenp,","\t\t\t\t void *newp, size_t *newlen);","","\/\/ Swift:","func sysctl(","  _ name: UnsafeMutablePointer<CInt>!,","  _ namelen: CUnsignedInt,","  _ oldp: UnsafeMutableRawPointer!,","  _ oldlenp: UnsafeMutablePointer<Int>!,","  _ newp: UnsafeMutableRawPointer!,","  _ newlen: Int",") -> CInt"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a function that retrieves the size of a cache line for the processor architecture we are running on."}]},{"syntax":"swift","code":["import Darwin","","func cachelineSize() -> Int {","\t\/\/ The information is available under the identifier 'CACHELINE' in the hardware section.","    var query = [CTL_HW, HW_CACHELINE]","    \/\/ The information we want to retrieve is a C integer value.","    var result: CInt = 0","    \/\/ The size of integer type buffer.","    var resultSize = MemoryLayout<CInt>.size","    ","    let r = sysctl(&query, CUnsignedInt(query.count), &result, &resultSize, nil, 0)","    ","    \/\/ Sysctl is documented to return zero value on success.","    precondition(r == 0, \"Cannot query cache line size\")","    \/\/ Expect the call to set as many bytes as there are in a C integer value.","    precondition(resultSize == MemoryLayout<CInt>.size)","    ","    return Int(result)","}","","print(cachelineSize()) \/\/ 64"],"type":"codeListing"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The function will set ","type":"text"},{"type":"codeVoice","code":"resultSize"},{"text":" to the number of bytes it copied into ","type":"text"},{"type":"codeVoice","code":"result"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Because we only want to retrieve the current value, not set it, we supply nil value for the ","type":"text"},{"code":"new value","type":"codeVoice"},{"text":" buffer, and set its size to zero.","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"Expand the code above into explicit closure based calls:","type":"text"}]},{"syntax":"swift","code":["import Darwin","","func cachelineSize() -> Int {","    var query = [CTL_HW, HW_CACHELINE]","    return query.withUnsafeMutableBufferPointer { buffer in","        var result: CInt = 0","        withUnsafeMutablePointer(to: &result) { resultptr in","            var resultSize = MemoryLayout<CInt>.size","            let r = withUnsafeMutablePointer(to: &resultSize) { sizeptr in","                sysctl(buffer.baseAddress, CUnsignedInt(buffer.count),","                       resultptr, sizeptr,","                       nil, 0)","            }","            precondition(r == 0, \"Cannot query cache line size\")","            precondition(resultSize == MemoryLayout<CInt>.size)","        }","        return Int(result)","    }","}","","print(cachelineSize()) \/\/ 64"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This code is functionally equivalent to the code above."}]},{"text":"Clousure-based vs. implicit pointers","type":"heading","level":2,"anchor":"Clousure-based-vs-implicit-pointers"},{"syntax":"swift","code":["var value = 42","withUnsafeMutablePointer(to: &value) { p in","  p.pointee += 1","}","print(value)  \/\/ 43"],"type":"codeListing"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure-based design makes the actual lifetime of the resulting pointer far more explicit."}]}]},{"content":[{"inlineContent":[{"text":"Helping us avoid lifetime issues.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","code":["var value2 = 42","let p = UnsafeMutablePointer(&value2) \/\/ BROKEN -- dangling pointer!","p.pointee += 1","print(value2)"],"type":"codeListing"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Passing a temporary pointer to the mutable pointer initializer escapes its value out of the initializer call.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Accessing the resulting dangling pointer value is undefined behavior.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Prefer to use closure-based APIs in pure Swift code."}]}]},{"text":"Initializing contiguous collection storage","type":"heading","level":2,"anchor":"Initializing-contiguous-collection-storage"},{"type":"paragraph","inlineContent":[{"text":"New initializers that allow us to create an ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" or a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value by directly copying data into their underlying uninitalized storage.","type":"text"}]},{"syntax":"swift","code":["Array.init(unsafeUninitializedCapacity:initializingWith:)","String.init(unsafeUninitializedCapacity:initializingUTF8With:)"],"type":"codeListing"},{"text":"Example","type":"heading","level":3,"anchor":"Example"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Find out the kernel version of the operating system we’re running on."}]},{"syntax":"swift","code":["import Darwin","","func kernelVersion() -> String {","\t\/\/ Identified by VERSION entry in the kernel section.","    var query = [CTL_KERN, KERN_VERSION]","    var length = 0","    let r = sysctl(&query, 2, nil, &length, nil, 0)","    precondition(r == 0, \"Error retrieving kern.version\")","    ","    \/\/ The initializer gives us a buffer point that we can pass through the sysctl function.","    return String(unsafeUninitializedCapacity: length) { buffer in","        var length = buffer.count","        \/\/ The function will copy the version string directly into this buffer.","        let r = sysctl(&query, 2, buffer.baseAddress, &length, nil, 0)","        precondition(r == 0, \"Error retrieving kern.version\")","        precondition(length > 0 && length <= buffer.count)","        \/\/ Check the last byte is zero, corresponding to the NUL character terminating a C string.","        precondition(buffer[length - 1] == 0)","        \/\/ Discard the NUL character.","        return length - 1","    }","}","","print(kernelVersion())","\/\/ Darwin Kernel Version 19.5.0: Thu Apr 30 18:25:59 PDT 2020; root:xnu-6153.121.1~7\/RELEASE_X86_64"],"type":"codeListing"},{"items":[{"content":[{"inlineContent":[{"text":"We don’t know the size of the version string in advance, so we need to cause this control twice.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"On the first ","type":"text"},{"code":"sysctl","type":"codeVoice"},{"text":" return, the ","type":"text"},{"code":"length","type":"codeVoice"},{"text":" variable will get set to the number of bytes required to store the string.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Don’t need for manual memory management, by using this new String initializer.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Get direct access to a buffer that will eventually become storage for a regular Swift string instance."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Don’t need to manually allocate or deallocate memory.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Summary","type":"heading","level":2,"anchor":"Summary"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Follow the requirements of each unsafe interface."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Keep unsafe API usage to the minimum.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"code":"UnsafeBufferPointer","type":"codeVoice"},{"type":"text","text":" for memory buffers."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Test with the sanitizers."}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Written By","type":"heading","level":2,"anchor":"Written-By"},{"type":"row","numberOfColumns":5,"columns":[{"content":[{"inlineContent":[{"type":"image","identifier":"dasautoooo"}],"type":"paragraph"}],"size":1},{"content":[{"type":"heading","text":"Leonard Chen","anchor":"Leonard-Chen","level":3},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/dasautoooo","isActive":true,"overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/dasautoooo","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/x.com\/DasAutoooo","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/wut.im","isActive":true}]}],"size":4}]},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","isActive":true}]},{"text":"Related Sessions","type":"heading","level":2,"anchor":"Related-Sessions"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10163-Advancements-in-the-ObjectiveC-runtime","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10167-Safely-manage-pointers-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-416-Understanding-Swift-Performance"],"type":"links"},{"type":"small","inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2025 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"sections":[],"abstract":[{"text":"What exactly makes code “unsafe”? Join the Swift team as we take a look at the programming language’s safety precautions — and when you might need to reach for unsafe operations. We’ll take a look at APIs that can cause unexpected states if not used correctly, and how you can write code more specifically to avoid undefined behavior. Learn how to work with C APIs that use pointers and the steps to take when you want to use Swift’s unsafe pointer APIs.","type":"text"}],"metadata":{"roleHeading":"WWDC20","title":"Unsafe Swift","role":"sampleCode","modules":[{"name":"WWDC Notes"}]},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20"]]},"references":{"../10167/":{"identifier":"..\/10167\/","type":"link","titleInlineContent":[{"type":"text","text":"Safely manage pointers in Swift"}],"url":"..\/10167\/","title":"Safely manage pointers in Swift"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"type":"link","title":"Contributions are welcome!","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"dasautoooo.jpeg":{"alt":null,"identifier":"dasautoooo.jpeg","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/dasautoooo.jpeg"}],"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","role":"collection","url":"\/documentation\/wwdcnotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"images":[{"identifier":"WWDCNotes.png","type":"icon"}],"title":"WWDC Notes","type":"topic","kind":"symbol"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20":{"url":"\/documentation\/wwdcnotes\/wwdc20","title":"WWDC20","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20","images":[{"type":"icon","identifier":"WWDC20-Icon.png"},{"type":"card","identifier":"WWDC20.jpeg"}],"type":"topic","role":"collectionGroup","kind":"article","abstract":[{"type":"text","text":"Xcode 12, Swift 5.3, iOS 14, macOS 11 (Big Sur), tvOS 14, watchOS 7."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"code":"WidgetKit","type":"codeVoice"},{"type":"text","text":", "},{"code":"StoreKit Testing","type":"codeVoice"},{"type":"text","text":", and more."}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10163-Advancements-in-the-ObjectiveC-runtime":{"abstract":[{"type":"text","text":"Dive into the microscopic world of low-level bits and bytes that underlie every Objective-C and Swift class. Find out how recent changes to internal data structures, method lists, and tagged pointers provide better performance and lower memory usage. We’ll demonstrate how to recognize and fix crashes in code that depend on internal details, and show you how to keep your code unaffected by changes to the runtime."}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10163-Advancements-in-the-ObjectiveC-runtime","role":"sampleCode","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc20-10163-advancements-in-the-objectivec-runtime","title":"Advancements in the Objective-C runtime"},"WWDC20-10648-c_pointers_mapping":{"alt":null,"identifier":"WWDC20-10648-c_pointers_mapping","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC20-10648-c_pointers_mapping.png"}],"type":"image"},"https://x.com/DasAutoooo":{"identifier":"https:\/\/x.com\/DasAutoooo","type":"link","titleInlineContent":[{"type":"text","text":"X\/Twitter"}],"url":"https:\/\/x.com\/DasAutoooo","title":"X\/Twitter"},"WWDC20-10648-memory":{"type":"image","variants":[{"url":"\/images\/WWDCNotes\/WWDC20-10648-memory.png","traits":["1x","light"]}],"alt":null,"identifier":"WWDC20-10648-memory"},"WWDC20.jpeg":{"alt":null,"identifier":"WWDC20.jpeg","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC20.jpeg"}],"type":"image"},"dasautoooo":{"identifier":"dasautoooo","alt":"Profile image of Leonard Chen","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/dasautoooo.jpeg"}]},"https://developer.apple.com/wwdc20/10648":{"type":"download","checksum":null,"identifier":"https:\/\/developer.apple.com\/wwdc20\/10648","url":"https:\/\/developer.apple.com\/wwdc20\/10648"},"WWDC20-Icon.png":{"alt":null,"identifier":"WWDC20-Icon.png","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC20-Icon.png"}],"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10167-Safely-manage-pointers-in-Swift":{"title":"Safely manage pointers in Swift","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10167-Safely-manage-pointers-in-Swift","kind":"article","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc20-10167-safely-manage-pointers-in-swift","abstract":[{"type":"text","text":"Come with us as we delve into unsafe pointer types in Swift. Discover the requirements for each type and how to use it correctly. We’ll discuss typed pointers, drop down to raw pointers, and finally circumvent pointer type safety entirely by binding memory."}]},"WWDC20-10648-value_to_pointer":{"type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes\/WWDC20-10648-value_to_pointer.png"}],"alt":null,"identifier":"WWDC20-10648-value_to_pointer"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","alt":null,"type":"image","variants":[{"url":"\/images\/WWDCNotes\/WWDCNotes.png","traits":["1x","light"]}]},"https://wut.im":{"url":"https:\/\/wut.im","identifier":"https:\/\/wut.im","titleInlineContent":[{"type":"text","text":"Blog"}],"title":"Blog","type":"link"},"doc://WWDCNotes/documentation/WWDCNotes/dasautoooo":{"abstract":[{"text":"💻 Programmer | 🕹 Lifetime Gamer","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/dasautoooo","kind":"article","title":"Leonard Chen (6 notes)","images":[{"identifier":"dasautoooo.jpeg","type":"card"},{"identifier":"dasautoooo.jpeg","type":"icon"}],"url":"\/documentation\/wwdcnotes\/dasautoooo","role":"sampleCode","type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC16-416-Understanding-Swift-Performance":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC16-416-Understanding-Swift-Performance","abstract":[{"type":"text","text":"In this advanced session, find out how structs, classes, protocols, and generics are implemented in Swift. Learn about their relative costs in different dimensions of performance. See how to apply this information to speed up your code."}],"type":"topic","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc16-416-understanding-swift-performance","title":"Understanding Swift Performance","role":"sampleCode"},"https://developer.apple.com/documentation/swift/unsafemutablepointer":{"type":"link","title":"UnsafeMutablePointer","titleInlineContent":[{"type":"codeVoice","code":"UnsafeMutablePointer"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/unsafemutablepointer","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/unsafemutablepointer"},"WWDC20-10648-address_sanitizer":{"identifier":"WWDC20-10648-address_sanitizer","alt":null,"type":"image","variants":[{"url":"\/images\/WWDCNotes\/WWDC20-10648-address_sanitizer.png","traits":["1x","light"]}]},"https://github.com/dasautoooo":{"url":"https:\/\/github.com\/dasautoooo","identifier":"https:\/\/github.com\/dasautoooo","titleInlineContent":[{"type":"text","text":"GitHub"}],"title":"GitHub","type":"link"}}}