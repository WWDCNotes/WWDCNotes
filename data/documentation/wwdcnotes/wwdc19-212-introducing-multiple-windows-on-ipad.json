{"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-212-Introducing-Multiple-Windows-on-iPad","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"text":"Introduction","level":2,"anchor":"Introduction","type":"heading"},{"items":[{"content":[{"inlineContent":[{"text":"On iPadOS 12 and earlier, when going to the app switcher, all we could see were apps (and apps in split view).","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"From iPadOS 13 and later, what we see are windows, also called scenes (and scenes in split view).","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"What is a scene? A scene is ","type":"text"},{"inlineContent":[{"text":"UI instance","type":"text"}],"type":"strong"},{"text":" of our app, an app can have multiple scenes, potentially on screen at the same time.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"There must be a “default” scene where the user has to be able to do anything:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"If your app requires multiple scenes\/windows in order to access all its functionality, then something went wrong.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"In Apple example, all scenes are exact clones of each other, this is possibly the right (and easiest) thing to do.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"An example of different scene is the “Compose Scene” in the mail.app: this scene serves the only purpose to write and send an email. It will even “auto explode” once the email has been sent.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We can have multiple compose windows at the same time."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Drag and drop between multiple windows of the same app is supported"}]}]}],"type":"unorderedList"},{"text":"Adoption","level":3,"anchor":"Adoption","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"First of all, we must always ask ourselves: does it make sense for our app to support Scenes?"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Supporting multiple windows will make your iPad app much friendlier to macOS once you cross that bridge with Catalyst."}],"type":"paragraph"},{"text":"How to create new windows?","level":2,"anchor":"How-to-create-new-windows","type":"heading"},{"items":[{"content":[{"inlineContent":[{"text":"Natively with iOS:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Hold the app icon and drag it on the side of the screen","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Tap the + button on App Exposé:","type":"text"},{"text":" ","type":"text"},{"identifier":"WWDC19-212-plus","type":"image"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Custom actions (that our app must support):"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"mainly by dragging and dropping things: cells, tabs etc"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"by explicit user action e.g. a “Open in New Window” button."}]}]}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Never force the user to use multiple window, make sure the user understands how to do whatever they need in the current window, and, alternatively, give an option to “Open in New Window”.","type":"text"}],"type":"paragraph"},{"text":"Behind The Scenes: UI Hierarchy","level":2,"anchor":"Behind-The-Scenes-UI-Hierarchy","type":"heading"},{"inlineContent":[{"text":"iOS 12 (and earlier)","type":"text"},{"text":" ","type":"text"},{"identifier":"WWDC19-212-12","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"iOS 13 (and later)"},{"type":"text","text":" "},{"type":"image","identifier":"WWDC19-212-13"}],"type":"paragraph"},{"inlineContent":[{"text":"The new hierarchy looks like this:","type":"text"},{"text":" ","type":"text"},{"type":"image","identifier":"WWDC19-212-hiearchy"}],"type":"paragraph"},{"text":"What’s New","level":2,"anchor":"Whats-New","type":"heading"},{"inlineContent":[{"text":"Three new classes:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"UIWindowScene","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"UIScene","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"code":"UISceneSession","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"UIScene"},{"type":"text","text":" contains the UI and is created\/destroyed by the system."},{"text":" ","type":"text"},{"text":"A ","type":"text"},{"code":"UIScene","type":"codeVoice"},{"text":" is aware of other scenes, every single scene is actually a ","type":"text"},{"code":"UISceneSession","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"text":"`UISceneSession`","level":2,"anchor":"UISceneSession","type":"heading"},{"inlineContent":[{"type":"text","text":"A "},{"code":"UISceneSession","type":"codeVoice"},{"type":"text","text":" is the persisted interface state. The UI itself can be created\/destroyed by the system, however the "},{"code":"UISceneSession","type":"codeVoice"},{"type":"text","text":" remains as long as the app itself is killed, the scene kills itself, or the user closes the scene."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Each scene has a defined system role:"},{"type":"text","text":"\n"},{"type":"text","text":"apparently, this is to say where the scene is. On the main device or in an external display."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Every time a new window is created\/destroyed, your application is informed via the app delegate that a new session had been made\/destroyed."}],"type":"paragraph"},{"text":"`UIApplication` vs `UIScene`","level":2,"anchor":"UIApplication-vs-UIScene","type":"heading"},{"inlineContent":[{"type":"text","text":"Since now we have multiple windows, many events that previously were delivered to the application delegate have been transferred to the scene delegate. (like for "},{"code":"UIApplication","type":"codeVoice"},{"type":"text","text":", we normally don’t subclass the "},{"code":"UIApplication","type":"codeVoice"},{"type":"text","text":" but we implement a "},{"code":"UIApplicationDelegate","type":"codeVoice"},{"type":"text","text":". In this we have a "},{"code":"UISceneDelegate","type":"codeVoice"},{"type":"text","text":", which is a protocol that we implement ourselves in a custom "},{"code":"UIResponder","type":"codeVoice"},{"type":"text","text":" class)."}],"type":"paragraph"},{"inlineContent":[{"text":"Lots of things that were previously managed in the application delegate are now managed in the scene delegate (free refactoring!).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC19-212-delegates","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"Also other things like the status bar state are now to be asked to the scene, not the application. Basically everything UI-related is on the scene.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC19-212-concept"}],"type":"paragraph"},{"text":"`NSUserActivity`","level":2,"anchor":"NSUserActivity","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"From now on the ","type":"text"},{"code":"NSUserActivity","type":"codeVoice"},{"text":" restorations are no longer done in the application delegate but in the scene delegate.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To handle user activities, we must do so in our scene delegate on will connect:"}]}]}],"type":"unorderedList"},{"syntax":"swift","code":["func scene(","  _ scene: UIScene,","  willConnectTo session: UISceneSession,","  options connectionOptions: UIScene.ConnectionOptions",") {","  if let userActivity = connectionOptions.userActivities.first ?? session.stateRestorationActivity { ","    configure(window: window, with: userActivity) ","  }","}"],"type":"codeListing"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Note how we can also use the session for state restoration. Which means the ","type":"text"},{"type":"codeVoice","code":"UISceneSession"},{"text":" was destroyed by the system and now it’s being reinitialized.","type":"text"}]}]}],"type":"unorderedList"},{"text":"Coding Time","level":2,"anchor":"Coding-Time","type":"heading"},{"inlineContent":[{"text":"First things first, we must enable multi windows support in the project:","type":"text"},{"text":" ","type":"text"},{"identifier":"WWDC19-212-project","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"This updates the app ","type":"text"},{"code":"info.plist","type":"codeVoice"},{"text":" manifest with a new key\/value telling the system about window support.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Once this is done, it’s time to declare the different supported scenes, which can be done statically by adding different Scene Configurations in the "},{"type":"codeVoice","code":"info.plist"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"identifier":"WWDC19-212-infoPlist","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"This can also be done via code.","type":"text"}],"type":"paragraph"},{"text":"Creating New Scenes (Programmatically)","level":3,"anchor":"Creating-New-Scenes-Programmatically","type":"heading"},{"inlineContent":[{"text":"Create new scenes (note that this and the following are called in ","type":"text"},{"code":"UIApplication","type":"codeVoice"},{"text":"):","type":"text"}],"type":"paragraph"},{"text":"`requestSceneSessionActivation(_:userActivity:options:errorHandler:)`","level":4,"anchor":"requestSceneSessionActivationuserActivityoptionserrorHandler","type":"heading"},{"items":[{"content":[{"inlineContent":[{"text":"This will either create a new scene or bring forward an existing scene with that matches the give parameters.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"if we pass nil on the first parameter, we will create a new session\/window","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"the ","type":"text"},{"code":"userActivity","type":"codeVoice"},{"text":" parameter is used to pass the desired activity in the new scene (which will be used to “restore” the new scene to the proper state)","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"the ","type":"text"},{"type":"codeVoice","code":"options"},{"text":" parameter is used for example to pass which scene has triggered the call and more","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","code":["\/\/ Open a New Window ","","@IBAction func handleLongPress(forDocumentAt url: URL) {","  if let existingSession = findSession(for: url) { ","    UIApplication.shared.requestSceneSessionActivation(","      existingSession, ","      userActivity: nil, ","      options: nil","    )","  } else { ","    let activity = NUserActivity(activityType: \"com.example.MyApp.EditDocument\")","    activity.userInfo[\"url\"] = url ","    ","    UIApplication.shared.requestSceneSessionActivation(","      nil, ","      userActivity: activity, ","      options: nil","    ) ","  }","}"],"type":"codeListing"},{"inlineContent":[{"text":"Once called, a new Scene session is created. However, iOS still doesn’t know what configuration you’d like to use in your new scene, which is why iOS lets you specify so by calling the app delegate ","type":"text"},{"code":"configurationForSession:","type":"codeVoice"},{"text":" method.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In this method we will get the user activity that we passed in the ","type":"text"},{"code":"requestSceneSessionActivation","type":"codeVoice"},{"text":" call, which then we can use to inspect and decide which configuration to return.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This method is also called on the first launch of the app as well, to let the app decide with what configuration we should fill in the first session."}],"type":"paragraph"},{"inlineContent":[{"text":"This configuration specifies:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"What scene delegate…","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"What storyboard…"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"What scene subclass…"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"…you want to call the scene with."}],"type":"paragraph"},{"inlineContent":[{"text":"You can declare these configurations dynamically in code or statically via ","type":"text"},{"code":"info.plist","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you use define them in the "},{"code":"info plist","type":"codeVoice"},{"type":"text","text":", all you have to do in this method is decide which configuration to call and return it by explicitly saying the name of that config:"}],"type":"paragraph"},{"syntax":"swift","code":["return UISceneConfiguration(name: \"Default\", sessionRole: connectingSceneSession.role)"],"type":"codeListing"},{"inlineContent":[{"text":"This is because all the above is already declared in the ","type":"text"},{"code":"info.plist","type":"codeVoice"},{"text":" (if you’ve chosen that route).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If the configuration declares a storyboard, then everything else will be done automatically."}],"type":"paragraph"},{"inlineContent":[{"text":"The new scene delegate will receive a ","type":"text"},{"code":"sceneWillConnectToSession:","type":"codeVoice"},{"text":" call with, again, the same ","type":"text"},{"code":"UserActivity","type":"codeVoice"},{"text":" passed in order to restore the session.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If the session existed already, all of this is skipped and we jump straight to the scene delegate’s ","type":"text"},{"code":"sceneWillConnectToSession:","type":"codeVoice"},{"text":" call. If the session was still connected (aka was not killed meanwhile by iOS) instead of ","type":"text"},{"code":"sceneWillConnectToSession:","type":"codeVoice"},{"text":" the ","type":"text"},{"code":"continueUserActivity:","type":"codeVoice"},{"text":" will be called (in the same scene delegate).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note how in ","type":"text"},{"code":"willConnect","type":"codeVoice"},{"text":" we need to setup the window ourselves:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["  func scene (","    _ scene: UIScene,","    willConnectTo session: UISceneSession,","    options: .ConnectionOptions","  ) {","    window = UIWindow(windowScene: scene as! UIWindowScene)","","    if let activity = options.userActivities.first ?? session.stateRestorationActivity {","      configure(window: window, with: activity) ","    }","  }"],"type":"codeListing"},{"text":"On Scene Disconnection\/Destruction","level":3,"anchor":"On-Scene-DisconnectionDestruction","type":"heading"},{"inlineContent":[{"text":"When the scene gets disconnected, it means that the system simply killed the scene (“claim back the resources”), before doing that, the scene delegate gets a last call ","type":"text"},{"code":"sceneDidDisconnect:","type":"codeVoice"}],"type":"paragraph"},{"inlineContent":[{"text":"In this method we should free any resource that was active because of this scene but was held somewhere else in the app. Don’t delete user data, as the scene might connect again in the future.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If the scene is destroyed (because the user swiped up from the app switcher or else) then the ","type":"text"},{"code":"UIApplication","type":"codeVoice"},{"text":" delegate will be called and then, and only then, it is ok to delete the scene user data.","type":"text"}],"type":"paragraph"},{"text":"Updating Existing Scenes","level":3,"anchor":"Updating-Existing-Scenes","type":"heading"},{"inlineContent":[{"type":"text","text":"This might be needed when a shared resources has been updated and the change should be reflected in other scenes as well."}],"type":"paragraph"},{"inlineContent":[{"text":"It is used by iOS to capture a new snapshot of the scene (displayed in the app switcher).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Call ","type":"text"},{"type":"codeVoice","code":"requestSceneSessionRefresh(_:)"}],"type":"paragraph"},{"text":"Close Scenes","level":3,"anchor":"Close-Scenes","type":"heading"},{"inlineContent":[{"text":"Used to close the given scene (note how this is, again, called on ","type":"text"},{"code":"UIApplication","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"requestSceneSessionDestruction(_:options:errorHandler:)"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The options let us specify an animation for the given scene destruction, this is cool to display the user what has happened to the scene data for example) ."}],"type":"paragraph"},{"inlineContent":[{"text":"Animation happens if the scene is in the foreground.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Close a Window ","","func closeWindow(and action: DraftAction) {","  let options = UIWindowScene.DestructionRequestOptions()","","  switch action { ","    case .send: options.windowDismissalAnimation = .commit","    case .save: options.windowDismissalAnimation = .decline","    case .delete: options.windowDismissalAnimation = .standard ","  }","","  let session = view.window!.windowScene!.session","  UIApplication.shared.requestSceneSessionDestruction(session, options: options)","}"],"type":"codeListing"},{"text":"State restoration","level":2,"anchor":"State-restoration","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We use "},{"type":"codeVoice","code":"NSUserActivity"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"We also have a ","type":"text"},{"code":"userInfo","type":"codeVoice"},{"text":" dictionary that we can use, this can be used, for example, for per scene customization. This ","type":"text"},{"code":"UISceneSession","type":"codeVoice"},{"text":" ","type":"text"},{"code":"userInfo","type":"codeVoice"},{"text":" is not wiped when our scene is destroyed.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Apple suggests to put things that we currently set in ","type":"text"},{"code":"NSUserDefautls","type":"codeVoice"},{"text":" in here (when it makes sense, for your app, use the map preference in here).","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","code":["\/\/ State Restoration ","","class UISceneSession { ","  var stateRestorationUserActivity: NSUserActivity","  ","  var persistentIdentifier: String { get } ","","  \/\/\/ Values must be property list type.","  var userInfo: [String: AnyHashable]","}"],"type":"codeListing"},{"text":"Choose Which Scene to Activate: `UISceneActivationConditions`","level":2,"anchor":"Choose-Which-Scene-to-Activate-UISceneActivationConditions","type":"heading"},{"inlineContent":[{"text":"Let’s say that we receive a notification and the user taps on it. Which scene should the system choose to handle the notification?","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"UIScene","type":"codeVoice"},{"text":" come with a","type":"text"},{"code":" UISceneActivationConditions","type":"codeVoice"},{"text":" object that tells the system what the specific scene capabilities are.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"UISceneActivationConditions","type":"codeVoice"},{"type":"text","text":" comes in two parts:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"the CAN predicate"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"the PREFER predicate","type":"text"}]}]}],"type":"unorderedList"},{"syntax":"swift","code":["class UISceneActivationConditions : NSObject { ","  var canActivateForTargetContentIdentifierPredicate : NSPredicate ","  var prefersToActivateForTargetContentIdentifierPredicate : NSPredicate ","} "],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The CAN predicate tells the system what kind of content the scene can display."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The PREFER predicate tells what content the scene prefers and at which level, so to choose between different available scenes."}],"type":"paragraph"},{"inlineContent":[{"text":"Both predicates work around the ","type":"text"},{"code":"TargetContentIdentifier","type":"codeVoice"},{"text":", which is a (string) structured way to represent data in your model (think of it as a link).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Going back to the notification example, the system will run this string to each available scene in order to determine which scene to use.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"From iOS 13, if push notifications come with a “notification-content-id” key, iOS will use that as the ","type":"text"},{"type":"codeVoice","code":"TargetContentIdentifier"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Other places where this is used (and where we must declare it):","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"UIApplicationShortcutItem"},{"type":"text","text":" (3d touch)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"NSUserActivity","type":"codeVoice"}]}]}],"type":"unorderedList"},{"text":"Restrictions: `NSPredicate`","level":2,"anchor":"Restrictions-NSPredicate","type":"heading"},{"items":[{"content":[{"inlineContent":[{"text":"Block Based Predicates","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Regular Expression Predicates"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The only keypath you can reference is ","type":"text"},{"type":"codeVoice","code":"“SELF”"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Written By","level":2,"anchor":"Written-By","type":"heading"},{"numberOfColumns":5,"columns":[{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"zntfdr"}]}],"size":1},{"content":[{"text":"Federico Zanetello","type":"heading","level":3,"anchor":"Federico-Zanetello"},{"inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","isActive":true,"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"overridingTitle":"Contributed Notes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/zntfdr","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/zntfdr.dev","isActive":true,"type":"reference"}],"type":"paragraph"}],"size":4}],"type":"row"},{"inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"isActive":true,"identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","type":"reference"}],"type":"paragraph"},{"text":"Related Sessions","level":2,"anchor":"Related-Sessions","type":"heading"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10057-Take-your-iPad-apps-to-the-next-level","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-221-Introducing-PencilKit","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-233-Mastering-Xcode-Previews","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-721-Combine-in-Practice"],"type":"links"},{"inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}],"kind":"content"}],"abstract":[{"text":"Multitasking is an exciting way to add power to your iPad app. It is easy to enable your app to run two instances of your interface side-by-side, and your customers will love it. Learn how to take your existing features like drag and drop and use them to easily create a second window. Find out how supporting multiple windows changes the app lifecycle and what that means for all applications. Hear about some common mistakes and how to solve them, setting you and your customers up for a fantastic experience.","type":"text"}],"sampleCodeDownload":{"kind":"sampleDownload","action":{"overridingTitle":"Watch Video (42 min)","identifier":"https:\/\/developer.apple.com\/wwdc19\/212","type":"reference","isActive":true}},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc19-212-introducing-multiple-windows-on-ipad"]}],"metadata":{"title":"Introducing Multiple Windows on iPad","roleHeading":"WWDC19","role":"sampleCode","modules":[{"name":"WWDC Notes"}]},"kind":"article","hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19"]]},"references":{"WWDC19-212-hiearchy":{"identifier":"WWDC19-212-hiearchy","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-hiearchy.png"}]},"WWDC19-212-project":{"identifier":"WWDC19-212-project","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-project.png"}]},"WWDC19-212-delegates":{"identifier":"WWDC19-212-delegates","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-delegates.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19":{"abstract":[{"text":"Xcode 11, Swift 5.1, iOS 13, macOS 10.15 (Catalina), tvOS 13, watchOS 6.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"Combine","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Core Haptics","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Create ML","type":"codeVoice"},{"text":", and more.","type":"text"}],"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19","role":"collectionGroup","kind":"article","images":[{"type":"icon","identifier":"WWDC19-Icon.png"},{"type":"card","identifier":"WWDC19.jpeg"}],"title":"WWDC19","url":"\/documentation\/wwdcnotes\/wwdc19"},"WWDC19-Icon.png":{"identifier":"WWDC19-Icon.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-Icon.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-221-Introducing-PencilKit":{"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc19-221-introducing-pencilkit","type":"topic","title":"Introducing PencilKit","abstract":[{"text":"Meet PencilKit, Apple’s feature-rich drawing and annotation framework. With just a few lines of code, you can add a full drawing experience to your app — with access to a canvas, responsive inks, rich tool palette and drawing model. Hear the technical details that make a great Apple Pencil experience. Learn about the new screenshot editor and how you can adopt just a few small APIs to enable your full content to be captured beyond the size of the screen, with or without your app’s user interface.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-221-Introducing-PencilKit","kind":"article"},"zntfdr.jpeg":{"identifier":"zntfdr.jpeg","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}]},"WWDC19-212-12":{"identifier":"WWDC19-212-12","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-12.png"}]},"WWDC19.jpeg":{"identifier":"WWDC19.jpeg","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19.jpeg"}]},"https://wwdcnotes.github.io/WWDCNotes/documentation/wwdcnotes/contributing":{"title":"Contributions are welcome!","identifier":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","url":"https:\/\/wwdcnotes.github.io\/WWDCNotes\/documentation\/wwdcnotes\/contributing","type":"link","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}]},"https://github.com/zntfdr":{"title":"GitHub","identifier":"https:\/\/github.com\/zntfdr","url":"https:\/\/github.com\/zntfdr","type":"link","titleInlineContent":[{"text":"GitHub","type":"text"}]},"WWDC19-212-concept":{"identifier":"WWDC19-212-concept","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-concept.png"}]},"doc://WWDCNotes/documentation/WWDCNotes":{"title":"WWDC Notes","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"role":"collection","type":"topic","kind":"symbol","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","url":"\/documentation\/wwdcnotes"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-721-Combine-in-Practice":{"url":"\/documentation\/wwdcnotes\/wwdc19-721-combine-in-practice","kind":"article","role":"sampleCode","abstract":[{"type":"text","text":"Expand your knowledge of Combine, Apple’s new unified, declarative framework for processing values over time. Learn about how to correctly handle errors, schedule work and integrate Combine into your app today."}],"title":"Combine in Practice","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-721-Combine-in-Practice","type":"topic"},"zntfdr":{"identifier":"zntfdr","type":"image","alt":"Profile image of Federico Zanetello","variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}]},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"url":"\/documentation\/wwdcnotes\/zntfdr","type":"topic","kind":"article","title":"Federico Zanetello (332 notes)","abstract":[{"text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more.","type":"text"}],"role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","images":[{"identifier":"zntfdr.jpeg","type":"card"},{"identifier":"zntfdr.jpeg","type":"icon"}]},"WWDC19-212-plus":{"identifier":"WWDC19-212-plus","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-plus.png"}]},"https://developer.apple.com/wwdc19/212":{"identifier":"https:\/\/developer.apple.com\/wwdc19\/212","url":"https:\/\/developer.apple.com\/wwdc19\/212","type":"download","checksum":null},"WWDC19-212-13":{"identifier":"WWDC19-212-13","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-13.png"}]},"WWDC19-212-infoPlist":{"identifier":"WWDC19-212-infoPlist","type":"image","alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC19-212-infoPlist.png"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10057-Take-your-iPad-apps-to-the-next-level":{"abstract":[{"type":"text","text":"Make even better iPad apps: Learn how you can adopt prominent scenes for uninterrupted, focused interactions. Help people stay engaged and fast with keyboard shortcuts and the keyboard shortcut interface. Explore how the latest in pointer enhancements can help your app boost productivity."}],"url":"\/documentation\/wwdcnotes\/wwdc21-10057-take-your-ipad-apps-to-the-next-level","title":"Take your iPad apps to the next level","kind":"article","role":"sampleCode","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10057-Take-your-iPad-apps-to-the-next-level"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-233-Mastering-Xcode-Previews":{"url":"\/documentation\/wwdcnotes\/wwdc19-233-mastering-xcode-previews","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-233-Mastering-Xcode-Previews","kind":"article","role":"sampleCode","type":"topic","title":"Mastering Xcode Previews","abstract":[{"type":"text","text":"Xcode 11 displays previews of your user interface right in the editor, streamlining the edit-debug-run cycle into a seamless workflow. Learn how previews work, how to optimize the structure of your SwiftUI app for previews, and how to add preview support to your existing views and view controllers."}]},"https://zntfdr.dev":{"title":"Blog","identifier":"https:\/\/zntfdr.dev","url":"https:\/\/zntfdr.dev","type":"link","titleInlineContent":[{"text":"Blog","type":"text"}]}}}