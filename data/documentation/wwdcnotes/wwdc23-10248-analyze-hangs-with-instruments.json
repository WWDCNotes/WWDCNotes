{"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc23-10248-analyze-hangs-with-instruments"]}],"schemaVersion":{"patch":0,"minor":3,"major":0},"sampleCodeDownload":{"kind":"sampleDownload","action":{"type":"reference","identifier":"https:\/\/developer.apple.com\/wwdc23\/10248","overridingTitle":"Watch Video (42 min)","isActive":true}},"primaryContentSections":[{"kind":"content","content":[{"level":1,"text":"What is a hang?","anchor":"What-is-a-hang","type":"heading"},{"inlineContent":[{"text":"When dealing with hangs, there’re three steps you need to follow; find a hang, analyze a hang to understand how it happens, and then, fix it. This talk will be focusing on the analyzing part and some fixes.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Hang == Delay. What kind of delay is acceptable depends on the circumstances.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"For a discrete interaction, a delay below","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"~","type":"codeVoice"},{"type":"text","text":" 100ms → You will usually feel instant"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"~"},{"type":"text","text":" 250ms → It depends on the circumstances,"}],"type":"paragraph"},{"inlineContent":[{"text":"longer than 250ms → It becomes noticeable at least subconsciously","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Delay above 250ms doesn’t feel instant anymore. That’s why most of instrument tools start reporting hangs by default starting at 250ms."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"To enable our UI elements to react “instantly”, it is vital to keep the main thread free from non-UI work.","type":"text"}],"type":"paragraph"},{"level":1,"text":"Event handling and rendering loop","anchor":"Event-handling-and-rendering-loop","type":"heading"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Given that every update to a UI element needs some time on the main thread, and we want these updates to happen within 100 ms to feel real. Ideally, ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"no work on the main thread should take longer than 100 ms"}]},{"text":". If you can be faster, even better. Long-running work on the main thread can also cause hitches.","type":"text"}],"type":"paragraph"},{"level":1,"text":"Profiling your app on Xcode","anchor":"Profiling-your-app-on-Xcode","type":"heading"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Shortly, Xcode will install your app on device, but, it will not launch it. Instead, you will see an instrument template chooser on your screen. Choose “Time Profiler”. Time profiler is a good starting point if you don’t yet know what you are looking for and want to get a better understanding of what your app is doing."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"It will create a new time profiler document, which includes time profiler and hangs profiler, both of which will be useful for addressing hangs.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Hit record button at the top-left of the tool bar. It will launch the configured application and start capturing data. And use you app as you normally would. Instruments will record all of your app’s data. Once you found the hang, hit the stop recording button in the toolbar. In this talk, he used Backyard Birds app to demonstrate hangs.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Instruments has also detected the hang. It measures the hang duration, and labels the corresponding intervals according to the severity. In this case, instruments shows us a “Server Hang” has happened (see above screenshot).","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"There are two main cases for an unresponsive main thread:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The most simple case is that the main thread is simply still busy doing other work. In this case, the main thread will show a bunch of CPU activity."}]}]},{"content":[{"inlineContent":[{"text":"The other case is the main thread being blocked. This is usually because the main thread is waiting for some other work to be done elsewhere. When the thread is blocked, there will be little to no CPU activity on the main thread.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In order to identify the hang, first select the Backyard Birds on the left panel, tap the disclosure indicator to unfold all the threads, select main thread, then click to the ugly red area (hang-interval in the timeline) to show the context menu, hold option key and click “Set inspection range and zoom” (as shown in the above screenshot)."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This zooms into the interval’s range and filters the data displayed in the detail view to the selected time range."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"After you have done above two steps, it will filter out all functions from the system libraries, making it a lot easier for you to inspect just on your hanging code.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As you can see, the "},{"type":"codeVoice","code":"BackgroundThumbnailView.body.getter"},{"type":"text","text":" takes the longest. It is the Busy Main Thread problem. There are two potential scenarios to cause this hang."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"How we should reduce the work on the main thread depends on which case we have."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For a long running function, we want to look at its implementation and its callees. We need to look further down."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If a function is called a lot of times, it is more beneficial to look at what is calling it and determine whether we can do so less often. We need to look further up."}],"type":"paragraph"},{"inlineContent":[{"text":"Bad news is time profiler cannot tell us which case we have. Time profiler gathers data by checking what’s running on the CPU in regular intervals. And for each sample, it checks which function is currently running on the CPU.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To measure the executing time of a specific function, use os_signposts. Let’s add SwiftUI View Body instruments to see what’s going on in our SwiftUI View.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Click the view body instrument and drag it into the document window to add it. We gotta record again."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"You can see a lot of orange intervals all labelled BackgroundThumbnailView. This tells us precisely how many body executions there were and how long each one took. The orange color indicates that the runtime of that specific body execution took a little longer than what we are aiming for with SwiftUI. The bigger problem is how many intervals there are.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We can now address to that problematic code."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Let’s just use lazy VGrid to solve the issue.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s profile the updated code."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We still have a micro-hang. Let’s profile it on our iPad."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We still experience the hang on iPad. That’s because now our screen is bigger and there’re a lot more thumbnails to be rendered. Instruments also recorded this hang (see in below screenshot). We see more BackgroundThumbnailView bodies again."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The same code performed mostly OK on an iPhone but was slow on an iPad, simply because the screen was bigger. This is one of the reasons why you should also fix micro hangs. Let’s find out what we can do to make each individual execution faster."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We seem to be computing a thumbnail on the fly here, which is quite time consuming. This is work we should rather be doing in the background and not keep the main thread busy with. To better understand what change we can make, let’s look at the context how the thumbnail getter is called."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"And update our code to show progress view while loading the actual image."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Let’s try out the updated code. You will our progress indicators, and a few seconds later, our thumbnails were displayed.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"This is the slightly different type of hangs. The way Instruments’ hang detection works is that it looks at all works items on the main thread and check whether they are too long. If so, it marks them as potential hang. Hang detection also detects these asynchronous or delayed cases, but it only measures the potential delay, not the actually experienced delay.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"The problem (executing asynchronous task on main thread)","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"The solution","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This should allow the “thumbnail” getter to execute on Swift Concurrency’s concurrent thread pool inside of the main thread. Let’s try it out again."}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"To determine whether a blocked thread is a responsiveness issue or not, look to the Hang instruments, not the thread states instruments. So a blocked main thread doesn’t imply an unresponsive main thread. High CPU usage also doesn’t imply that the main thread is unresponsive. If the main thread is unresponsive, that means it was either blocked or the main thread was busy.","type":"text"}],"type":"paragraph"},{"inlineContent":[],"type":"paragraph"},{"inlineContent":[{"text":"Whatever work you are doing on the main thread, it should be done in less than 100ms to free the main thread for event handling again. The shorter the better. Determine whether the main thread is busy or blocked. Hangs can surface synchronously or asynchronously. Do less, move work to the background, sometimes, even both. measure first and check whether there is actually a hang before optimizing.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Written By","anchor":"Written-By","type":"heading"},{"columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"kyaw-codes"}]}]},{"size":4,"content":[{"text":"Kyaw Zay Ya Lin Tun","anchor":"Kyaw-Zay-Ya-Lin-Tun","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/kyaw-codes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"overridingTitle":"Contributed Notes","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/kyaw-codes","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/kyaw-codes.github.io\/","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/x.com\/KyawTheMonkey","isActive":true}]}]}],"numberOfColumns":5,"type":"row"},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}],"type":"paragraph"},{"level":2,"text":"Related Sessions","anchor":"Related-Sessions","type":"heading"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10099-Meet-RealityKit-Trace","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10160-Demystify-SwiftUI-performance","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10082-Track-down-hangs-with-Xcode-and-ondevice-detection","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10258-Understand-and-eliminate-hangs-from-your-app","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10031-Stacks-Grids-and-Outlines-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-411-Getting-Started-with-Instruments"],"type":"links"},{"inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}]}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"]]},"metadata":{"role":"sampleCode","title":"Analyze hangs with Instruments","roleHeading":"WWDC23","modules":[{"name":"WWDC Notes"}]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10248-Analyze-hangs-with-Instruments"},"abstract":[{"type":"text","text":"User interface elements often mimic real-world interactions, including real-time responses. Apps with a noticeable delay in user interaction — a hang — can break that illusion and create frustration. We’ll show you how to use Instruments to analyze, understand, and fix hangs in your apps on all Apple platforms. Discover how you can efficiently navigate an Instruments trace document, interpret trace data, and record additional profiling data to better understand your specific hang."}],"sections":[],"references":{"doc://WWDCNotes/documentation/WWDCNotes":{"title":"WWDC Notes","kind":"symbol","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"type":"topic","role":"collection","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","url":"\/documentation\/wwdcnotes"},"https://developer.apple.com/wwdc23/10248":{"checksum":null,"type":"download","identifier":"https:\/\/developer.apple.com\/wwdc23\/10248","url":"https:\/\/developer.apple.com\/wwdc23\/10248"},"https://kyaw-codes.github.io/":{"titleInlineContent":[{"type":"text","text":"Blog"}],"type":"link","identifier":"https:\/\/kyaw-codes.github.io\/","title":"Blog","url":"https:\/\/kyaw-codes.github.io\/"},"doc://WWDCNotes/documentation/WWDCNotes/kyaw-codes":{"abstract":[{"type":"text","text":"Senior iOS Developer @sgcodigo | Programming Mentor | Swift enthusiast"}],"title":"Kyaw Zay Ya Lin Tun (3 notes)","type":"topic","role":"sampleCode","url":"\/documentation\/wwdcnotes\/kyaw-codes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/kyaw-codes","kind":"article","images":[{"identifier":"kyaw-codes.jpeg","type":"card"},{"identifier":"kyaw-codes.jpeg","type":"icon"}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110350-Visualize-and-optimize-Swift-concurrency":{"kind":"article","type":"topic","abstract":[{"type":"text","text":"Learn how you can optimize your app with the Swift Concurrency template in Instruments. We’ll discuss common performance issues and show you how to use Instruments to find and resolve these problems. Learn how you can keep your UI responsive, maximize parallel performance, and analyze Swift concurrency activity within your app."}],"title":"Visualize and optimize Swift concurrency","url":"\/documentation\/wwdcnotes\/wwdc22-110350-visualize-and-optimize-swift-concurrency","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","role":"sampleCode"},"https://x.com/KyawTheMonkey":{"titleInlineContent":[{"type":"text","text":"X\/Twitter"}],"type":"link","identifier":"https:\/\/x.com\/KyawTheMonkey","title":"X\/Twitter","url":"https:\/\/x.com\/KyawTheMonkey"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10099-Meet-RealityKit-Trace":{"role":"sampleCode","abstract":[{"type":"text","text":"Discover how you can use RealityKit Trace to improve the performance of your spatial computing apps. Explore performance profiling guidelines for this platform and learn how the RealityKit Trace template can help you optimize rendering for your apps. We’ll also provide guidance on profiling various types of content in your app to help pinpoint performance issues."}],"type":"topic","title":"Meet RealityKit Trace","url":"\/documentation\/wwdcnotes\/wwdc23-10099-meet-realitykit-trace","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10099-Meet-RealityKit-Trace"},"https://github.com/kyaw-codes":{"titleInlineContent":[{"type":"text","text":"GitHub"}],"type":"link","identifier":"https:\/\/github.com\/kyaw-codes","title":"GitHub","url":"https:\/\/github.com\/kyaw-codes"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-411-Getting-Started-with-Instruments":{"title":"Getting Started with Instruments","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-411-Getting-Started-with-Instruments","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc19-411-getting-started-with-instruments","kind":"article","abstract":[{"type":"text","text":"The Instruments app in Xcode provides a rich set of tools and templates for profiling your app performance. Learn all about Instruments and gain strategies for identifying bottlenecks in your code. See just how to leverage the power of time profiling and points of interest tracking to make meaningful changes to your code that can dramatically improve app responsiveness."}]},"WWDC23-Icon.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23-Icon.png"}],"type":"image","alt":null,"identifier":"WWDC23-Icon.png"},"kyaw-codes.jpeg":{"variants":[{"traits":["1x","light"],"url":"\/images\/kyaw-codes.jpeg"}],"type":"image","alt":null,"identifier":"kyaw-codes.jpeg"},"kyaw-codes":{"variants":[{"traits":["1x","light"],"url":"\/images\/kyaw-codes.jpeg"}],"type":"image","alt":"Profile image of Kyaw Zay Ya Lin Tun","identifier":"kyaw-codes"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23":{"role":"collectionGroup","abstract":[{"type":"text","text":"Xcode 15, Swift 5.9, iOS 17, macOS 14 (Sonoma), tvOS 17, visionOS 1, watchOS 10."},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"SwiftData","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Observation","type":"codeVoice"},{"text":", ","type":"text"},{"code":"StoreKit","type":"codeVoice"},{"text":" views, and more.","type":"text"}],"type":"topic","title":"WWDC23","url":"\/documentation\/wwdcnotes\/wwdc23","kind":"article","images":[{"identifier":"WWDC23-Icon.png","type":"icon"},{"identifier":"WWDC23.jpeg","type":"card"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10160-Demystify-SwiftUI-performance":{"url":"\/documentation\/wwdcnotes\/wwdc23-10160-demystify-swiftui-performance","abstract":[{"type":"text","text":"Learn how you can build a mental model for performance in SwiftUI and write faster, more efficient code. We’ll share some of the common causes behind performance issues and help you triage hangs and hitches in SwiftUI to create more responsive views in your app."}],"kind":"article","title":"Demystify SwiftUI performance","type":"topic","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10160-Demystify-SwiftUI-performance"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10031-Stacks-Grids-and-Outlines-in-SwiftUI":{"url":"\/documentation\/wwdcnotes\/wwdc20-10031-stacks-grids-and-outlines-in-swiftui","kind":"article","type":"topic","role":"sampleCode","title":"Stacks, Grids, and Outlines in SwiftUI","abstract":[{"text":"Display detailed data in your SwiftUI apps more quickly and efficiently with improved stacks and new list and outline views. Now available on iOS and iPadOS for the first time, outlines are a new multi-platform tool for expressing hierarchical data that work alongside stacks and lists. Learn how to use new and improved tools in SwiftUI to display more content on screen when using table views, create smooth-scrolling and responsive stacks, and build out list views for content that needs more than a vStack can provide. Take your layout options even further with the new grid view, as well as disclosure groups.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10031-Stacks-Grids-and-Outlines-in-SwiftUI"},"WWDC23.jpeg":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC23.jpeg"}],"type":"image","alt":null,"identifier":"WWDC23.jpeg"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10258-Understand-and-eliminate-hangs-from-your-app":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10258-Understand-and-eliminate-hangs-from-your-app","url":"\/documentation\/wwdcnotes\/wwdc21-10258-understand-and-eliminate-hangs-from-your-app","role":"sampleCode","title":"Understand and eliminate hangs from your app","abstract":[{"text":"Discover how you can track down hangs and delays in your app. We’ll show you tools and methods to discover hangs and their causes, learn about anti-patterns that can lead to hangs, explore best practices for eliminating hangs like GCD, and provide guidance on when you should consider asynchronous code to improve your app performance.","type":"text"}],"kind":"article"},"WWDCNotes.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"type":"image","alt":null,"identifier":"WWDCNotes.png"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10254-Swift-concurrency-Behind-the-scenes":{"kind":"article","type":"topic","abstract":[{"type":"text","text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We’ll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps."}],"title":"Swift concurrency: Behind the scenes","url":"\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-10082-Track-down-hangs-with-Xcode-and-ondevice-detection":{"url":"\/documentation\/wwdcnotes\/wwdc22-10082-track-down-hangs-with-xcode-and-ondevice-detection","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10082-Track-down-hangs-with-Xcode-and-ondevice-detection","abstract":[{"text":"Learn how you can increase responsiveness and eliminate hangs in your app and make even better experiences. Hang out with the Performance Tools team as we explore how you can track down these issues — and even stop them from occurring in the first place. We’ll take you through the latest detection mechanisms for iOS to help track hangs during pre-release testing, show you how to identify issues in release builds using the Xcode Organizer, and more.","type":"text"}],"title":"Track down hangs with Xcode and on-device detection","role":"sampleCode","type":"topic"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}}}