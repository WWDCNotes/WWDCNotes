{"metadata":{"roleHeading":"WWDC21","modules":[{"name":"WWDC Notes"}],"title":"Swift concurrency: Behind the scenes","role":"sampleCode"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21"]]},"kind":"article","primaryContentSections":[{"content":[{"text":"Threading model","type":"heading","anchor":"Threading-model","level":2},{"inlineContent":[{"text":"How threads are brought up to handle work on GCD queues:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"When work is enqueued onto a queue in Grand Central Dispatch, the system will bring up a thread to service that work item","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Since a concurrent queue can handle multiple work items at once, the system will bring up several threads until we have saturated all the CPU cores","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"If a thread blocks and there is more work to be done on the concurrent queue, GCD will bring up more threads to drain the remaining work items","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"What does ‚Äúa thread is blocked‚Äù mean? If a thread is blocked, it is suspended by the operating system (OS) (i.e. it is marked as not eligible for running, so that OS scheduler ignores it when selecting threads to run) until the thread can be unblocked - the OS is responsible for scheduling threads","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"By giving your process another thread, we ensure that each cpu core continues to have a thread that executes work at any given time"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"In GCD, it‚Äôs easy to have excessive concurrency:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Overcommitting the system with more threads than CPU cores (e.g., Apple Watch only has 2 cores)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Risk of thread explosion","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Too many threads come with performance costs:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Memory overhead - as each blocked thread is holding onto valuable memory and resources while waiting to run again","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Scheduling overhead - as new threads are brought up, the CPU need to perform a ","type":"text"},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Context_switch","type":"reference","isActive":true},{"text":" in order to switch away from the old thread to start executing the new thread","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"https:\/\/en.wikipedia.org\/wiki\/Time-sharing"},{"type":"text","text":" - with limited cores and a lot of threads, the scheduling latencies of these threads outweigh the amount of useful work they would do, therefore, resulting in the CPU running less efficiently as well"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"excessive context switching - the cost of swapping threads (for timesharing the cpu) is not negligible","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"rows":[[[{"inlineContent":[{"type":"image","identifier":"WWDC21-10254-gcd-timeline"}],"type":"paragraph"}],[{"inlineContent":[{"type":"image","identifier":"WWDC21-10254-swift-concurrency-timeline"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Grand Central Dispatch","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Swift Concurrency"}],"type":"paragraph"}]]],"type":"table","header":"row"},{"inlineContent":[{"type":"text","text":"Swift concurrency aims to:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"have one thread running on each cpu core - create only as many threads as there are CPU cores","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"replace blocked threads with lightweight objects called ","type":"text"},{"text":"continuations","type":"text"},{"text":" to track resumption of work - this way threads are be able to cheaply and efficiently switch between work items when they are blocked","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"no context switches - instead of a full thread context switch, swapping continuations comes has the cost of a function call","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"In order to achieve this behavior, the operating system needs a runtime contract that threads will not block, and that is only possible if the language is able to provide us with that. Swift‚Äôs concurrency model and the semantics around it have therefore been designed with this goal in mind."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Two of Swift‚Äôs language-level features that enable us to maintain this runtime contract:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"await"},{"type":"text","text":" and non-blocking of threads"}],"type":"paragraph"}]}],"type":"orderedList"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"await","type":"codeVoice"},{"text":" is an asynchronous wait","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"await","type":"codeVoice"},{"text":" does not block the current thread while waiting for results from the ","type":"text"},{"code":"async","type":"codeVoice"},{"text":" function - Instead, the function may be suspended and the thread will be freed up to execute other tasks","type":"text"}]}]}],"type":"unorderedList"},{"items":[{"content":[{"inlineContent":[{"text":"the ","type":"text"},{"text":"Task tree","type":"text"},{"text":" - tracking of dependencies in Swift task model","type":"text"}],"type":"paragraph"}]}],"type":"orderedList","start":2},{"text":"1. How `await` is designed to ensure efficient suspension and resumption","type":"heading","anchor":"1-How-await-is-designed-to-ensure-efficient-suspension-and-resumption","level":3},{"inlineContent":[{"text":"How sync functions work:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Every thread in a running program has one ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Call_stack"},{"text":", which it uses to store state for function calls","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When the thread executes a function call, a new frame is pushed onto its stack"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"This newly created stack frame can be used by the function to store parameters, local variables, the return address, and any other information that is needed"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Once the function finishes executing and returns, its stack frame is popped","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"How async functions work:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"like for non-async functions, the stack frame stores local variables that do not need to be available across suspension points (a.k.a. "},{"type":"codeVoice","code":"await"},{"type":"text","text":" calls)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"async functions will also have an associated frame stored in the ","type":"text"},{"isActive":true,"identifier":"https:\/\/en.wikipedia.org\/w\/index.php?title=Heap_(memory_management)","type":"reference"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"async frames (a.k.a. the async function frame in the heap) store information that does need to be available across suspension points"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"instead of adding new stack frames across function calls, the top most stack frame is replaced when any variables that will be needed in the future will already have been stored in the list of async frames","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"suppose the execution of an ","type":"text"},{"type":"codeVoice","code":"async"},{"text":" function is suspended, and the thread is reused to do some other useful work instead of being blocked","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"since all information that is maintained across a suspension point is stored on the heap, it can be used to continue execution at a later stage","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this also means that the stack frame can be (and is) safely destroyed"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"this list of async frames is the runtime representation of a "},{"type":"text","text":"continuation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"once we resume (in the same or another thread), we create again its stack frame and continue its execution with the info from the heap"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Since Swift continues to use the operating system stack, both ","type":"text"},{"code":"async","type":"codeVoice"},{"text":" and sync Swift code can efficiently call into C and Objective-C","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"C and Objective-C code can also continue efficiently calling sync Swift code","type":"text"}]}]}]}]}],"type":"unorderedList"},{"text":"2. Swift runtime‚Äôs tracking of dependencies between tasks","type":"heading","anchor":"2-Swift-runtimes-tracking-of-dependencies-between-tasks","level":3},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Functions can be broken up into continuations at an "},{"code":"await","type":"codeVoice"},{"type":"text","text":", also known as a potential suspension point:"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"swift","type":"codeListing","code":["let (data, response) = try await URLSession.shared.data(from: feed.url) \/\/ Suspension point","","let articles = try deserializeArticles(from: data)                      \/\/ Continuation","await updateDatabase(with: articles,. for: feed)                        \/\/ Continuation (it's ok to have other suspensions points in a continuation)","\/\/ ...                                                                  \/\/ Continuation"]},{"items":[{"content":[{"inlineContent":[{"text":"Within a ","type":"text"},{"code":"TaskGroup","type":"codeVoice"},{"text":", a parent task may create several child tasks and each of those child tasks needs to complete before a parent task can proceed","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"These are dependencies tracked by the Swift concurrency runtime"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"In Swift, tasks can only await other tasks that are known to the Swift runtime ‚Äì be it continuations or child tasks"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Thanks to this clear understanding of the dependency chain between the tasks, the executing thread is able to reason about task dependencies and pick up a different task instead"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Code written with Swift concurrency can maintain a runtime contract that threads are always able to make forward progress"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"thanks to this runtime contract, Swift concurrency has built-in OS support, which comes in form of a "},{"type":"text","text":"Cooperative thread pool"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"This Cooperative thread pool is the default executor for Swift"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With limited to the number of CPU cores - the thread pool will only spawn as many threads as there are CPU cores"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Controlled granularity of concurrency","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Worker threads don‚Äôt block","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Avoid thread explosion and excessive context switches","type":"text"}]}]}],"type":"unorderedList"}]}]}]}],"type":"unorderedList"},{"text":"Things to consider when adopting Swift Concurrency","type":"heading","anchor":"Things-to-consider-when-adopting-Swift-Concurrency","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"performance","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"concurrency comes with costs - such as there will be additional memory allocations and logic execution in the Swift runtime"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"ensure that benefits of concurrency outweighs (OS) costs of managing it","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"profile your code as you adapt Swift concurrency"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"await","type":"codeVoice"},{"text":" and atomicity","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"no guarantee that the thread which executed the code before the "},{"type":"codeVoice","code":"await"},{"type":"text","text":" will execute the continuation as well (could resume in another thread)"}]}]},{"content":[{"inlineContent":[{"text":"Swift concurrency breaks atomicity by voluntarily descheduling the task","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"do not hold locks across ","type":"text"},{"code":"await","type":"codeVoice"},{"text":"s","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"thread-specific data is not hold across "},{"type":"codeVoice","code":"await"},{"type":"text","text":"s"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"preserve the runtime contract (always make forward progress):"}]}]}],"type":"unorderedList"},{"rows":[[[{"inlineContent":[{"type":"text","text":"‚úÖ Safe primitives"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"‚ö†Ô∏è Caution required"}],"type":"paragraph"}],[{"inlineContent":[{"text":"üõë Unsafe primitives","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"await","type":"codeVoice"},{"type":"text","text":", "},{"code":"Actor","type":"codeVoice"},{"type":"text","text":"s, "},{"code":"Task","type":"codeVoice"},{"type":"text","text":" groups"}],"type":"paragraph"}],[{"inlineContent":[{"code":"os_unfair_lock","type":"codeVoice"},{"text":", ","type":"text"},{"code":"NSLock","type":"codeVoice"},{"text":" in synchronous code","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"DispatchSemaphore"},{"text":", ","type":"text"},{"type":"codeVoice","code":"pthread_cond"},{"text":", ","type":"text"},{"type":"codeVoice","code":"NSCondition"},{"text":", ","type":"text"},{"type":"codeVoice","code":"pthread_rw_loc"},{"text":", ‚Ä¶","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Compiler enforced","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"No compiler support","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"No compiler support","type":"text"}],"type":"paragraph"}]]],"type":"table","header":"row"},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"Using a lock in synchronous code is safe when used for data synchronization around a tight, well-known critical section. This is because the thread holding the lock is always able to make forward progress towards releasing the lock. As such, while the primitive may block a thread for a short period of time under contention, it does not violate the runtime contract of forward progress.","type":"text"}],"type":"paragraph"}],"name":"Note"},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"These unsafe primitives hide dependency information from the Swift runtime, but introduce a dependency in execution in your code. Since the runtime is unaware of this dependency, it cannot make the right scheduling decisions and resolve them. In particular, do not use primitives that create unstructured tasks and then retroactively introduce a dependency across task boundaries by using a semaphore or an unsafe primitive.","type":"text"}],"type":"paragraph"}],"name":"Note"},{"inlineContent":[{"text":"To help you identify uses of unsafe primitives, run your app with this environment variable (set it in your Xcode run scheme ","type":"text"},{"text":"Environment variables","type":"text"},{"text":" section):","type":"text"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["LIBDISPATCH_COOPERATIVE_POOL_STRICT=1"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"This runs your app under a modified debug runtime, which enforces the invariant of forward progress.","type":"text"}]}],"name":"Note"},{"text":"Synchronization","type":"heading","anchor":"Synchronization","level":2},{"text":"Mutual exclusion with Actors","type":"heading","anchor":"Mutual-exclusion-with-Actors","level":3},{"inlineContent":[{"type":"text","text":"Mutual exclusion is guaranteed by actors"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"an actor may be executing at most one method call at a time","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"mutual exclusion means that the actor‚Äôs state is not accessed concurrently, preventing data races"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Comparison"}],"type":"paragraph"},{"inlineContent":[{"text":"|  |  Locks, Serial Queue sync { ‚Ä¶} | Serial Queue async (‚Ä¶ } | Actors using cooperative pool |","type":"text"},{"text":" ","type":"text"},{"text":"| No contention (the queue is not already running) | ‚úÖ Reuse thread | ‚ö†Ô∏è Request new thread | ‚úÖ Reuse thread |","type":"text"},{"text":" ","type":"text"},{"text":"| Under contention (the queue is already running) | üõë Blocking | ‚úÖ Non-blocking | ‚úÖ Non-blocking |","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"When you call a method on an actor that is not running (no contention), the calling thread can be reused to execute the method call","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"In the case where the called actor is already running (under contention), the calling thread can suspend the function it is executing and pick up other work","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Actor hopping","type":"heading","anchor":"Actor-hopping","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"execution switching from one actor to another","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Let‚Äôs say that actor A make an await call to actor B:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"No contention case:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"the thread can directly hop from actor A to actor B","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The thread does not block while hopping actors"}]}]},{"content":[{"inlineContent":[{"text":"Hopping does not require a different thread","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The runtime can directly suspend the work item for actor A and create a new work item for the actor B","type":"text"}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Under contention case:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the thread cannot hop to actor B, because actor B is already working on another work item (on another thread)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"a new actor B work item will be created, and will be kept pending","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"actor A will be suspended and the thread it was executing on is now freed up to do other work"}]}]},{"content":[{"inlineContent":[{"text":"when the previous actor B work item completes, the runtime may choose to start executing the pending work item for actor A","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"text":"Reentrancy and prioritization","type":"heading","anchor":"Reentrancy-and-prioritization","level":2},{"inlineContent":[{"text":"Ideally, high-priority work such as that involving user interaction, would take precedence over background work, such as saving backups.","type":"text"},{"text":"\n","type":"text"},{"text":"Actors are designed to allow the system to prioritize work well due to the notion of ","type":"text"},{"text":"reentrancy","type":"text"},{"text":".","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"how actors work under the hood"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"how actors compare to existing synchronization primitives you already may be familiar with ‚Äì like serial dispatch queues ‚Äì"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"some things to keep in mind when writing code with actors","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"How GCD Serial dispatch queues reentrancy and prioritization work:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Dispatch queues execute the items received in a strict first-in, first-out order","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Even if a work item is high-priority, it will need to wait for other work items that came earlier to complete"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"if those earlier work items are low-priority, we‚Äôre in a ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/en.wikipedia.org\/wiki\/Priority_inversion"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Serial queues work around priority inversion by boosting\/upgrading the priority of all of the work in the queue that‚Äôs ahead of the high-priority work"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In practice, this means that the work in the queue will be done sooner; However, this does not resolve the main issue, which is that low-priority items still need to complete before the original high-priority item can start executing"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Actor reentrancy aims to solve this kind of problem"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Actor reentrancy:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"actors can execute items in an order that is not strictly first-in, first-out","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"actor new work items can make progress, and even complete, while one or more older work items on it are suspended"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The actor still maintains mutual exclusion, as at most one work item can be executing at a given time","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"higher-priority work will be executed first, with lower-priority work following later"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Main actor","type":"heading","anchor":"Main-actor","level":2},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"abstracts over an existing notion of the system main thread","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"the main thread is disjoint from the threads in the cooperative pool"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"await"},{"type":"text","text":"ing to and from main actor requires a (thread) context switch"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"structure your code so that work for the main actor is batched up, do not jump from\/to the main actor continuously (a.k.a. avoid frequently context switching)","type":"text"}]}]}],"type":"unorderedList"},{"text":"Written By","type":"heading","anchor":"Written-By","level":2},{"type":"row","numberOfColumns":5,"columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"donnywals"}]}]},{"size":4,"content":[{"type":"heading","anchor":"Donny-Wals","text":"Donny Wals","level":3},{"inlineContent":[{"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/donnywals","isActive":true,"overridingTitle":"Contributed Notes","type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/donnywals","isActive":true,"type":"reference"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/www.donnywals.com","isActive":true,"type":"reference"}],"type":"paragraph"}]}]},{"type":"row","numberOfColumns":5,"columns":[{"content":[{"inlineContent":[{"type":"image","identifier":"zntfdr"}],"type":"paragraph"}],"size":1},{"content":[{"type":"heading","anchor":"Federico-Zanetello","text":"Federico Zanetello","level":3},{"inlineContent":[{"type":"reference","isActive":true,"overridingTitle":"Contributed Notes","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}]},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/zntfdr"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/zntfdr.dev"}],"type":"paragraph"}],"size":4}]},{"inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference"}],"type":"paragraph"},{"text":"Related Sessions","type":"heading","anchor":"Related-Sessions","level":2},{"items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10164-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10248-Analyze-hangs-with-Instruments","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10192-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC17-706-Modernizing-Grand-Central-Dispatch-Usage"],"type":"links","style":"list"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Legal Notice"}]}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright ¬© 2012 ‚Äì 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}],"kind":"content"}],"abstract":[{"type":"text","text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We‚Äôll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps."}],"variants":[{"paths":["\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes"],"traits":[{"interfaceLanguage":"swift"}]}],"sampleCodeDownload":{"action":{"isActive":true,"type":"reference","overridingTitle":"Watch Video (39 min)","identifier":"https:\/\/developer.apple.com\/wwdc21\/10254"},"kind":"sampleDownload"},"sections":[],"schemaVersion":{"major":0,"patch":0,"minor":3},"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10194-Swift-concurrency-Update-a-sample-app":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","type":"topic","kind":"article","abstract":[{"type":"text","text":"Discover Swift concurrency in action: Follow along as we update an existing sample app. Get real-world experience with async\/await, actors, and continuations. We‚Äôll also explore techniques for migrating existing code to Swift concurrency over time."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10194-swift-concurrency-update-a-sample-app","title":"Swift concurrency: Update a sample app"},"WWDC21-10254-gcd-timeline":{"identifier":"WWDC21-10254-gcd-timeline","variants":[{"url":"\/images\/WWDC21-10254-gcd-timeline.png","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10248-Analyze-hangs-with-Instruments":{"url":"\/documentation\/wwdcnotes\/wwdc23-10248-analyze-hangs-with-instruments","kind":"article","role":"sampleCode","title":"Analyze hangs with Instruments","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10248-Analyze-hangs-with-Instruments","abstract":[{"text":"User interface elements often mimic real-world interactions, including real-time responses. Apps with a noticeable delay in user interaction ‚Äî a hang ‚Äî can break that illusion and create frustration. We‚Äôll show you how to use Instruments to analyze, understand, and fix hangs in your apps on all Apple platforms. Discover how you can efficiently navigate an Instruments trace document, interpret trace data, and record additional profiling data to better understand your specific hang.","type":"text"}],"type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","type":"topic","title":"WWDC Notes","role":"collection","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","url":"\/documentation\/wwdcnotes"},"WWDC21.jpeg":{"identifier":"WWDC21.jpeg","variants":[{"url":"\/images\/WWDC21.jpeg","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10133-Protect-mutable-state-with-Swift-actors":{"abstract":[{"text":"Data races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug.","type":"text"}],"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","title":"Protect mutable state with Swift actors","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10133-protect-mutable-state-with-swift-actors","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110350-Visualize-and-optimize-Swift-concurrency":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","type":"topic","kind":"article","abstract":[{"type":"text","text":"Learn how you can optimize your app with the Swift Concurrency template in Instruments. We‚Äôll discuss common performance issues and show you how to use Instruments to find and resolve these problems. Learn how you can keep your UI responsive, maximize parallel performance, and analyze Swift concurrency activity within your app."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc22-110350-visualize-and-optimize-swift-concurrency","title":"Visualize and optimize Swift concurrency"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10170-Beyond-the-basics-of-structured-concurrency":{"url":"\/documentation\/wwdcnotes\/wwdc23-10170-beyond-the-basics-of-structured-concurrency","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","kind":"article","role":"sampleCode","abstract":[{"text":"It‚Äôs all about the task tree: Find out how structured concurrency can help your apps manage automatic task cancellation, task priority propagation, and useful task-local value patterns. Learn how to manage resources in your app with useful patterns and the latest task group APIs. We‚Äôll show you how you can leverage the power of the task tree and task-local values to gain insight into distributed systems.","type":"text"}],"title":"Beyond the basics of structured concurrency"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21":{"url":"\/documentation\/wwdcnotes\/wwdc21","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21","title":"WWDC21","kind":"article","images":[{"type":"icon","identifier":"WWDC21-Icon.png"},{"type":"card","identifier":"WWDC21.jpeg"}],"role":"collectionGroup","abstract":[{"text":"Xcode 13, Swift 5.5, iOS 15, macOS 12 (Monterey), tvOS 15, watchOS 8.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"MusicKit","type":"codeVoice"},{"text":", ","type":"text"},{"code":"DocC","type":"codeVoice"},{"text":", ","type":"text"},{"code":"StoreKit 2","type":"codeVoice"},{"type":"text","text":", and more."}],"type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"url":"\/documentation\/wwdcnotes\/zntfdr","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","title":"Federico Zanetello (332 notes)","kind":"article","images":[{"identifier":"zntfdr.jpeg","type":"card"},{"identifier":"zntfdr.jpeg","type":"icon"}],"role":"sampleCode","abstract":[{"text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more.","type":"text"}],"type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC17-706-Modernizing-Grand-Central-Dispatch-Usage":{"kind":"article","url":"\/documentation\/wwdcnotes\/wwdc17-706-modernizing-grand-central-dispatch-usage","abstract":[{"text":"macOS 10.13 and iOS 11 have reinvented how Grand Central Dispatch and the Darwin kernel collaborate, enabling your applications to run concurrent workloads more efficiently. Learn how to modernize your code to take advantage of these improvements and make optimal use of hardware resources.","type":"text"}],"role":"sampleCode","type":"topic","title":"Modernizing Grand Central Dispatch Usage","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC17-706-Modernizing-Grand-Central-Dispatch-Usage"},"https://en.wikipedia.org/wiki/Call_stack":{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Call_stack","titleInlineContent":[{"text":"stack","type":"text"}],"type":"link","url":"https:\/\/en.wikipedia.org\/wiki\/Call_stack","title":"stack"},"https://www.donnywals.com":{"identifier":"https:\/\/www.donnywals.com","titleInlineContent":[{"text":"Blog","type":"text"}],"type":"link","url":"https:\/\/www.donnywals.com","title":"Blog"},"https://developer.apple.com/wwdc21/10254":{"identifier":"https:\/\/developer.apple.com\/wwdc21\/10254","checksum":null,"type":"download","url":"https:\/\/developer.apple.com\/wwdc21\/10254"},"WWDC21-10254-swift-concurrency-timeline":{"identifier":"WWDC21-10254-swift-concurrency-timeline","variants":[{"url":"\/images\/WWDC21-10254-swift-concurrency-timeline.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://github.com/donnywals":{"identifier":"https:\/\/github.com\/donnywals","titleInlineContent":[{"text":"GitHub","type":"text"}],"type":"link","url":"https:\/\/github.com\/donnywals","title":"GitHub"},"donnywals.jpeg":{"identifier":"donnywals.jpeg","variants":[{"url":"\/images\/donnywals.jpeg","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10134-Explore-structured-concurrency-in-Swift":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","type":"topic","kind":"article","abstract":[{"type":"text","text":"When you have code that needs to run at the same time as other code, it‚Äôs important to choose the right tool for the job. We‚Äôll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We‚Äôll also provide guidance on when you may want to use unstructured tasks."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10134-explore-structured-concurrency-in-swift","title":"Explore structured concurrency in Swift"},"https://github.com/zntfdr":{"identifier":"https:\/\/github.com\/zntfdr","titleInlineContent":[{"text":"GitHub","type":"text"}],"type":"link","url":"https:\/\/github.com\/zntfdr","title":"GitHub"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10132-Meet-asyncawait-in-Swift":{"abstract":[{"text":"Swift now supports asynchronous functions ‚Äî a pattern commonly known as async\/await. Discover how the new syntax can make your code easier to read and understand. Learn what happens when a function suspends, and find out how to adapt existing completion handlers to asynchronous functions.","type":"text"}],"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","title":"Meet async\/await in Swift","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10132-meet-asyncawait-in-swift","role":"sampleCode"},"WWDCNotes.png":{"identifier":"WWDCNotes.png","variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://zntfdr.dev":{"identifier":"https:\/\/zntfdr.dev","titleInlineContent":[{"text":"Blog","type":"text"}],"type":"link","url":"https:\/\/zntfdr.dev","title":"Blog"},"zntfdr.jpeg":{"identifier":"zntfdr.jpeg","variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"alt":null,"type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/donnywals":{"url":"\/documentation\/wwdcnotes\/donnywals","kind":"article","role":"sampleCode","images":[{"identifier":"donnywals.jpeg","type":"card"},{"identifier":"donnywals.jpeg","type":"icon"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/donnywals","title":"Donny Wals (3 notes)","abstract":[{"text":"No Bio on GitHub","type":"text"}],"type":"topic"},"zntfdr":{"identifier":"zntfdr","variants":[{"url":"\/images\/zntfdr.jpeg","traits":["1x","light"]}],"alt":"Profile image of Federico Zanetello","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","abstract":[{"type":"text","text":"Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We‚Äôll take you through Swift‚Äôs approach to eliminating data races and its effect on app architecture. We‚Äôll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system."}],"type":"topic","kind":"article","title":"Eliminate data races using Swift Concurrency","url":"\/documentation\/wwdcnotes\/wwdc22-110351-eliminate-data-races-using-swift-concurrency","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10192-Whats-new-in-Swift":{"abstract":[{"type":"text","text":"Join us for an update on Swift. Discover the latest language advancements that make your code easier to read and write. Explore the growing number of APIs available as Swift packages. And we‚Äôll introduce you to Swift‚Äôs async\/await syntax, structured concurrency, and actors."}],"type":"topic","title":"What‚Äòs new in Swift","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10192-whats-new-in-swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10192-Whats-new-in-Swift","kind":"article"},"donnywals":{"identifier":"donnywals","variants":[{"url":"\/images\/donnywals.jpeg","traits":["1x","light"]}],"alt":"Profile image of Donny Wals","type":"image"},"https://en.wikipedia.org/w/index.php?title=Heap_(memory_management)":{"identifier":"https:\/\/en.wikipedia.org\/w\/index.php?title=Heap_(memory_management)","titleInlineContent":[{"text":"heap","type":"text"}],"type":"link","url":"https:\/\/en.wikipedia.org\/w\/index.php?title=Heap_(memory_management)","title":"heap"},"https://en.wikipedia.org/wiki/Priority_inversion":{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Priority_inversion","titleInlineContent":[{"text":"priority inversion situation","type":"text"}],"type":"link","url":"https:\/\/en.wikipedia.org\/wiki\/Priority_inversion","title":"priority inversion situation"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"type":"link","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10164-Whats-new-in-Swift":{"title":"What‚Äôs new in Swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10164-Whats-new-in-Swift","kind":"article","type":"topic","role":"sampleCode","abstract":[{"text":"Join us for an update on Swift. We‚Äôll show you how APIs are becoming more extensible and expressive with features like parameter packs and macros. We‚Äôll also take you through improvements to interoperability and share how we‚Äôre expanding Swift‚Äôs performance and safety benefits everywhere from Foundation to large-scale distributed programs on the server.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc23-10164-whats-new-in-swift"},"https://en.wikipedia.org/wiki/Context_switch":{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Context_switch","titleInlineContent":[{"text":"full thread context switch","type":"text"}],"type":"link","url":"https:\/\/en.wikipedia.org\/wiki\/Context_switch","title":"full thread context switch"},"WWDC21-Icon.png":{"identifier":"WWDC21-Icon.png","variants":[{"url":"\/images\/WWDC21-Icon.png","traits":["1x","light"]}],"alt":null,"type":"image"},"https://en.wikipedia.org/wiki/Time-sharing":{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Time-sharing","titleInlineContent":[{"text":"timesharing of threads","type":"text"}],"type":"link","url":"https:\/\/en.wikipedia.org\/wiki\/Time-sharing","title":"timesharing of threads"}}}