{"schemaVersion":{"minor":3,"major":0,"patch":0},"kind":"article","metadata":{"role":"sampleCode","roleHeading":"WWDC21","modules":[{"name":"WWDC Notes"}],"title":"Explore structured concurrency in Swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc21-10134-explore-structured-concurrency-in-swift"]}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21"]]},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10134-Explore-structured-concurrency-in-Swift","interfaceLanguage":"swift"},"sections":[],"primaryContentSections":[{"content":[{"text":"Tasks","level":2,"anchor":"Tasks","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can create additional tasks to add concurrency to a program"}]}]},{"content":[{"inlineContent":[{"text":"A task provides a fresh execution context to run asynchronous code","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Each task runs concurrently with respect to other execution contexts"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Calling an ","type":"text"},{"code":"async","type":"codeVoice"},{"text":" function does not create a new task","type":"text"}]}]}],"type":"unorderedList"},{"text":"Async-let tasks","level":2,"anchor":"Async-let-tasks","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"When the process encounter an ","type":"text"},{"code":"async let","type":"codeVoice"},{"type":"text","text":" statement, a child task is created, while the main\/parent task continues running"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The parent task will suspend (if needed) only when it needs to get the result from the ","type":"text"},{"type":"codeVoice","code":"async let"},{"text":" child task, and it does so by using the (","type":"text"},{"type":"codeVoice","code":"try"},{"text":") ","type":"text"},{"type":"codeVoice","code":"await"},{"text":" keyword. In other words, the parent task might suspend when it start using the variables that are concurrently bound","type":"text"}]}]}],"type":"unorderedList"},{"code":["func fetchOneThumbnail(withID id: String) async throws -> UIImage {","  let imageReq = imageRequest(for: id), metadataReq = metadataRequest(for: id)","  async let (data, _) = URLSession.shared.data(for: imageReq) \/\/ 👈🏻 async","  async let (metadata, _) = URLSession.shared.data(for: metadataReq) \/\/ 👈🏻 async","  guard let size = parseSize(from: try await metadata), \/\/ 👈🏻 await","        let image = try await UIImage(data: data)?.byPreparingThumbnail(ofSize: size) \/\/ 👈🏻 await","  else {","    throw ThumbnailFailedError()","  }","  return image","}"],"syntax":"swift","type":"codeListing"},{"text":"Task Tree","level":3,"anchor":"Task-Tree","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"keeps track of tasks and their children"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"influences the attributes of your tasks like cancellation, priority, and task-local variables","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"a child\/sub task inherits all attributes of the parent task"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"whenever you make a call from one async function to another, the same task is used to execute the call"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Tasks are not the child of a specific function, but their lifetime may be scoped to it"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"A task parent-child link enforces a rule that says a parent task can only finish its work if all of its child tasks have finished"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"let’s say that we have two child tasks and one of them errors out, causing the parent, which was "},{"type":"codeVoice","code":"try await"},{"type":"text","text":"ing on it, to throw an error: the tree is responsible to cancel other child tasks and then await for them to finish before the parent task function can exit\/throw"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Marking a task as canceled does not stop the task. It simply informs the task that its results are no longer needed","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"When a task is canceled, all subtasks that are decedents of that task will be automatically canceled, too","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"text":"Task cancellation is cooperative","level":4,"anchor":"Task-cancellation-is-cooperative","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Tasks are not stopped immediately when cancelled","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Cancellation can be checked from anywhere (async or not)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Design your code with cancellation in mind","type":"text"}]}]}],"type":"unorderedList"},{"code":["func fetchThumbnails(for ids: [String]) async throws -> [String: UIImage] {","  var thumbnails: [String: UIImage] = [:]","  for id in ids {","    try Task.checkCancellation() \/\/ 👈🏻 cancellation check, this call throws an error if the current task has been canceled","    thumbnails[id] = try await fetchOneThumbnail(withID: id)","  }","  return thumbnails","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"You can also check for cancellation without throwing:","type":"text"}],"type":"paragraph"},{"code":["func fetchThumbnails(for ids: [String]) async throws -> [String: UIImage] {","  var thumbnails: [String: UIImage] = [:]","  for id in ids {","    if Task.isCancelled { break } \/\/ 👈🏻 cancellation check","    thumbnails[id] = try await fetchOneThumbnail(withID: id)","  }","  return thumbnails \/\/ 👈🏻 In case of cancellation, we return a partial result","}"],"syntax":"swift","type":"codeListing"},{"text":"Group tasks","level":2,"anchor":"Group-tasks","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"A task group is a form of structured concurrency that is designed to provide a dynamic amount of concurrency"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"You can introduce a task group by calling the ","type":"text"},{"code":"withThrowingTaskGroup","type":"codeVoice"},{"text":" function","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"This function gives you a scoped group object to create child tasks that are allowed to throw errors","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Tasks added to a group cannot outlive the scope of the block in which the group is defined"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"You create child tasks in a group by invoking its ","type":"text"},{"type":"codeVoice","code":"async(_:)"},{"text":" method","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Child tasks added this way will begin executing immediately and in any order"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"When the group object goes out of scope, the completion of all tasks within it will be implicitly awaited","type":"text"}]}]}],"type":"unorderedList"},{"code":["func fetchThumbnails(for ids: [String]) async throws -> [String: UIImage] {","  var thumbnails: [String: UIImage] = [:]","  try await withThrowingTaskGroup(of: Void.self) { group in \/\/ 👈🏻","    for id in ids {","      group.async {","        \/\/ Error: Mutation of captured var 'thumbnails' in concurrently executing code","        thumbnails[id] = try await fetchOneThumbnail(withID: id)","      }","    }","  }","  return thumbnails","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In the sample code above we have a data race issue:","type":"text"},{"text":"\n","type":"text"},{"text":"the ","type":"text"},{"code":"thumbnails","type":"codeVoice"},{"text":" dictionary cannot handle more than one access at a time, and if two child tasks tried to insert thumbnails simultaneously, that could cause a crash or data corruption.","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you create a new task, the work that the task performs is within a new closure type called a "},{"code":"@Sendable","type":"codeVoice"},{"type":"text","text":" closure."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The body of a "},{"type":"codeVoice","code":"@Sendable"},{"type":"text","text":" closure is restricted from capturing mutable variables in its lexical context, because those variables could be modified after the task is launched."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This means that the values you capture in a task must be safe to share. E.g., value types, or objects designed to be accessed from multiple threads, like actors, and classes that implement their own synchronization."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"A way to solve this in our example, is to have each child task return a value:"},{"type":"text","text":"\n"},{"type":"text","text":"this design gives the parent task the sole responsibility of processing the results."}],"type":"paragraph"},{"code":["func fetchThumbnails(for ids: [String]) async throws -> [String: UIImage] {","  var thumbnails: [String: UIImage] = [:]","  try await withThrowingTaskGroup(of: (String, UIImage).self) { group in","    for id in ids {","      group.async {","        return (id, try await fetchOneThumbnail(withID: id)) \/\/ 👈🏻 return only","      }","    }","    \/\/ Obtain results from the child tasks, sequentially, in order of completion.","    for try await (id, thumbnail) in group {","      thumbnails[id] = thumbnail \/\/ 👈🏻 assign to the dictionary from the parent task","    }","  }","  return thumbnails","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Task tree differences from async let tasks:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"when your group goes out of scope through a normal exit from the block. Then, cancellation for child tasks is not implicit"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This behavior makes it easier for you to express the fork-join pattern using a task group, because the jobs will only be awaited, not canceled"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"You can also manually cancel all tasks before exiting the block using the group’s "},{"type":"codeVoice","code":"cancelAll"},{"type":"text","text":" method"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Unstructured Tasks","level":2,"anchor":"Unstructured-Tasks","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"give you a lot more flexibility at the expense of needing a lot more manual management","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Useful when:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"some tasks need to launch from non-async contexts"}]}]},{"content":[{"inlineContent":[{"text":"some tasks live beyond the confines of a single scope","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Characteristics:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Inherit actor isolation and priority of the origin context","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Lifetime is not confined to any scope"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Can be launched anywhere, even non-async functions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Must be manually cancelled or awaited"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Example:"}],"type":"paragraph"},{"code":["@MainActor","class MyDelegate: UICollectionViewDelegate {","  var thumbnailTasks: [IndexPath: Task<Void, Never>] = [:]","  ","  func collectionView(_ view: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt item: IndexPath) {","    let ids = getThumbnailIDs(for: item)","    thumbnailTasks[item] = Task { \/\/ 👈🏻 create and store unstructured tasks","      defer { thumbnailTasks[item] = nil } \/\/ 👈🏻 we remove the task when it's finished, so we don't cancel it when it's finished already","      let thumbnails = await fetchThumbnails(for: ids)","      display(thumbnails, in: cell)","    }","  }","  ","  func collectionView(_ view: UICollectionView, didEndDisplay cell: UICollectionViewCell, forItemAt item: IndexPath) {","    thumbnailTasks[item]?.cancel() \/\/ 👈🏻 we cancel said task when that cell is no longer displayed","  }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note here that we can access the same dictionary inside and outside of that async task without getting a data race flagged by the compiler. Our delegate class is bound to the main actor, and the new task inherits that, so they’ll never run together in parallel."}],"type":"paragraph"},{"text":"Detached Tasks","level":2,"anchor":"Detached-Tasks","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Unstructured tasks inherit traits from that task’s originating context, detached tasks don’t.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"maximum flexibility"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Unscoped lifetime, manually cancelled and awaited"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Do not inherit anything from their originating context - e.g., they’re not constrained to the same actor and don’t have to run at the same priority as where they were launched"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Detached tasks run independently with generic defaults for things like priority, but they can also be launched with optional parameters to control how and where the new task gets executed"}],"type":"paragraph"}]}],"type":"unorderedList"},{"text":"Task Cheat sheet","level":2,"anchor":"Task-Cheat-sheet","type":"heading"},{"header":"row","rows":[[[{"inlineContent":[],"type":"paragraph"}],[{"inlineContent":[{"text":"Launched by","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Launchable from","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Lifetime"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Cancellation"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Inherits from origin","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"async-let tasks"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"asvnc let x"}],"type":"paragraph"}],[{"inlineContent":[{"code":"async","type":"codeVoice"},{"text":" functions","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"scoped to statement","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"automatic","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"priority, task-local values"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Group tasks","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"group.async"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"withTaskGroup"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"scoped to task group"}],"type":"paragraph"}],[{"inlineContent":[{"text":"automatic","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"priority, task-local values","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Unstructured tasks"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"Task"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"anywhere"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"unscoped"}],"type":"paragraph"}],[{"inlineContent":[{"text":"via ","type":"text"},{"code":"Task","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"priority, task-local values, actor","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Detached tasks","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"code":"Task.detached","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"anywhere"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"unscoped"}],"type":"paragraph"}],[{"inlineContent":[{"text":"via ","type":"text"},{"code":"Task","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"nothing"}],"type":"paragraph"}]]],"type":"table"},{"text":"Written By","level":2,"anchor":"Written-By","type":"heading"},{"numberOfColumns":5,"columns":[{"size":1,"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"zntfdr"}]}]},{"size":4,"content":[{"level":3,"text":"Federico Zanetello","type":"heading","anchor":"Federico-Zanetello"},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"isActive":true,"overridingTitle":"Contributed Notes"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/github.com\/zntfdr","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"type":"reference","identifier":"https:\/\/zntfdr.dev","isActive":true}]}]}],"type":"row"},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference","isActive":true}],"type":"paragraph"},{"text":"Related Sessions","level":2,"anchor":"Related-Sessions","type":"heading"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10019-Discover-concurrency-in-SwiftUI","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10058-Meet-AsyncSequence","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10192-Whats-new-in-Swift","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes"],"type":"links"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}],"kind":"content"}],"sampleCodeDownload":{"kind":"sampleDownload","action":{"type":"reference","overridingTitle":"Watch Video (27 min)","identifier":"https:\/\/developer.apple.com\/wwdc21\/10134","isActive":true}},"abstract":[{"text":"When you have code that needs to run at the same time as other code, it’s important to choose the right tool for the job. We’ll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We’ll also provide guidance on when you may want to use unstructured tasks.","type":"text"}],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10192-Whats-new-in-Swift":{"abstract":[{"type":"text","text":"Join us for an update on Swift. Discover the latest language advancements that make your code easier to read and write. Explore the growing number of APIs available as Swift packages. And we’ll introduce you to Swift’s async\/await syntax, structured concurrency, and actors."}],"type":"topic","title":"What‘s new in Swift","role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10192-whats-new-in-swift","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10192-Whats-new-in-Swift","kind":"article"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10194-Swift-concurrency-Update-a-sample-app":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10194-Swift-concurrency-Update-a-sample-app","type":"topic","kind":"article","abstract":[{"type":"text","text":"Discover Swift concurrency in action: Follow along as we update an existing sample app. Get real-world experience with async\/await, actors, and continuations. We’ll also explore techniques for migrating existing code to Swift concurrency over time."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10194-swift-concurrency-update-a-sample-app","title":"Swift concurrency: Update a sample app"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"url":"\/documentation\/wwdcnotes\/zntfdr","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","title":"Federico Zanetello (332 notes)","kind":"article","images":[{"identifier":"zntfdr.jpeg","type":"card"},{"identifier":"zntfdr.jpeg","type":"icon"}],"role":"sampleCode","abstract":[{"text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more.","type":"text"}],"type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10019-Discover-concurrency-in-SwiftUI":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10019-Discover-concurrency-in-SwiftUI","type":"topic","kind":"article","abstract":[{"type":"text","text":"Discover how you can use Swift’s concurrency features to build even better SwiftUI apps. We’ll show you how concurrent workflows interact with your ObservableObjects, and explore how you can use them directly in your SwiftUI views and models. Find out how to use await to make your app run smoothly on the SwiftUI runloop, and learn how to fetch remote images quickly with the AsyncImage API. And we’ll take you through the process of enabling additional asynchronous flows in your custom views."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10019-discover-concurrency-in-swiftui","title":"Discover concurrency in SwiftUI"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10058-Meet-AsyncSequence":{"role":"sampleCode","title":"Meet AsyncSequence","abstract":[{"text":"Iterating over a sequence of values over time is now as easy as writing a “for” loop. Find out how the new AsyncSequence protocol enables a natural, simple syntax for iterating over anything from notifications to bytes being streamed from a server. We’ll also show you how to adapt existing code to provide asynchronous sequences of your own.","type":"text"}],"type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10058-meet-asyncsequence","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10058-Meet-AsyncSequence","kind":"article"},"doc://WWDCNotes/documentation/WWDCNotes":{"kind":"symbol","type":"topic","title":"WWDC Notes","role":"collection","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"abstract":[{"type":"text","text":"Session notes shared by the community for the community."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","url":"\/documentation\/wwdcnotes"},"https://developer.apple.com/wwdc21/10134":{"checksum":null,"url":"https:\/\/developer.apple.com\/wwdc21\/10134","identifier":"https:\/\/developer.apple.com\/wwdc21\/10134","type":"download"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","abstract":[{"type":"text","text":"Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We’ll take you through Swift’s approach to eliminating data races and its effect on app architecture. We’ll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system."}],"type":"topic","kind":"article","title":"Eliminate data races using Swift Concurrency","url":"\/documentation\/wwdcnotes\/wwdc22-110351-eliminate-data-races-using-swift-concurrency","role":"sampleCode"},"WWDCNotes.png":{"alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"identifier":"WWDCNotes.png","type":"image"},"zntfdr.jpeg":{"alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}],"identifier":"zntfdr.jpeg","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110350-Visualize-and-optimize-Swift-concurrency":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110350-Visualize-and-optimize-Swift-concurrency","type":"topic","kind":"article","abstract":[{"type":"text","text":"Learn how you can optimize your app with the Swift Concurrency template in Instruments. We’ll discuss common performance issues and show you how to use Instruments to find and resolve these problems. Learn how you can keep your UI responsive, maximize parallel performance, and analyze Swift concurrency activity within your app."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc22-110350-visualize-and-optimize-swift-concurrency","title":"Visualize and optimize Swift concurrency"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"titleInlineContent":[{"type":"text","text":"Contributions are welcome!"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","title":"Contributions are welcome!"},"WWDC21-Icon.png":{"alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC21-Icon.png"}],"identifier":"WWDC21-Icon.png","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10132-Meet-asyncawait-in-Swift":{"abstract":[{"text":"Swift now supports asynchronous functions — a pattern commonly known as async\/await. Discover how the new syntax can make your code easier to read and understand. Learn what happens when a function suspends, and find out how to adapt existing completion handlers to asynchronous functions.","type":"text"}],"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","title":"Meet async\/await in Swift","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10132-meet-asyncawait-in-swift","role":"sampleCode"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21":{"url":"\/documentation\/wwdcnotes\/wwdc21","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21","title":"WWDC21","kind":"article","images":[{"type":"icon","identifier":"WWDC21-Icon.png"},{"type":"card","identifier":"WWDC21.jpeg"}],"role":"collectionGroup","abstract":[{"text":"Xcode 13, Swift 5.5, iOS 15, macOS 12 (Monterey), tvOS 15, watchOS 8.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"MusicKit","type":"codeVoice"},{"text":", ","type":"text"},{"code":"DocC","type":"codeVoice"},{"text":", ","type":"text"},{"code":"StoreKit 2","type":"codeVoice"},{"type":"text","text":", and more."}],"type":"topic"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC23-10170-Beyond-the-basics-of-structured-concurrency":{"url":"\/documentation\/wwdcnotes\/wwdc23-10170-beyond-the-basics-of-structured-concurrency","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC23-10170-Beyond-the-basics-of-structured-concurrency","kind":"article","role":"sampleCode","abstract":[{"text":"It’s all about the task tree: Find out how structured concurrency can help your apps manage automatic task cancellation, task priority propagation, and useful task-local value patterns. Learn how to manage resources in your app with useful patterns and the latest task group APIs. We’ll show you how you can leverage the power of the task tree and task-local values to gain insight into distributed systems.","type":"text"}],"title":"Beyond the basics of structured concurrency"},"WWDC21.jpeg":{"alt":null,"variants":[{"traits":["1x","light"],"url":"\/images\/WWDC21.jpeg"}],"identifier":"WWDC21.jpeg","type":"image"},"zntfdr":{"alt":"Profile image of Federico Zanetello","variants":[{"traits":["1x","light"],"url":"\/images\/zntfdr.jpeg"}],"identifier":"zntfdr","type":"image"},"https://github.com/zntfdr":{"titleInlineContent":[{"type":"text","text":"GitHub"}],"url":"https:\/\/github.com\/zntfdr","identifier":"https:\/\/github.com\/zntfdr","type":"link","title":"GitHub"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10254-Swift-concurrency-Behind-the-scenes":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10254-Swift-concurrency-Behind-the-scenes","type":"topic","kind":"article","abstract":[{"type":"text","text":"Dive into the details of Swift concurrency and discover how Swift provides greater safety from data races and thread explosion while simultaneously improving performance. We’ll explore how Swift tasks differ from Grand Central Dispatch, how the new cooperative threading model works, and how to ensure the best performance for your apps."}],"role":"sampleCode","url":"\/documentation\/wwdcnotes\/wwdc21-10254-swift-concurrency-behind-the-scenes","title":"Swift concurrency: Behind the scenes"},"https://zntfdr.dev":{"titleInlineContent":[{"type":"text","text":"Blog"}],"url":"https:\/\/zntfdr.dev","identifier":"https:\/\/zntfdr.dev","type":"link","title":"Blog"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10133-Protect-mutable-state-with-Swift-actors":{"abstract":[{"text":"Data races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug.","type":"text"}],"kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10133-Protect-mutable-state-with-Swift-actors","title":"Protect mutable state with Swift actors","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc21-10133-protect-mutable-state-with-swift-actors","role":"sampleCode"}}}