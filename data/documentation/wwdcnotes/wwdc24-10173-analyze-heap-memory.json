{"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24-10173-Analyze-heap-memory","interfaceLanguage":"swift"},"metadata":{"roleHeading":"WWDC24","title":"Analyze heap memory","modules":[{"name":"WWDC Notes"}],"role":"sampleCode"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc24-10173-analyze-heap-memory"]}],"sections":[],"primaryContentSections":[{"content":[{"anchor":"overview","text":"Overview","type":"heading","level":2},{"style":"note","content":[{"inlineContent":[{"text":"Any memory allocated by ","type":"text"},{"code":"malloc","type":"codeVoice"},{"type":"text","text":", either directly or indirectly"}],"type":"paragraph"}],"type":"aside","name":"Heap memory"},{"anchor":"Measurement","text":"Measurement","type":"heading","level":1},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"At startup, a process gets its own empty address space of virtual memory","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"System loads main executable, libraries, frameworks, and other read-only resources","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"At runtime, a process uses the ","type":"text"},{"inlineContent":[{"type":"text","text":"stack"}],"type":"strong"},{"text":" for ","type":"text"},{"inlineContent":[{"type":"text","text":"local"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"type":"text","text":"temporary"}],"type":"emphasis"},{"text":" variables","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"strong","inlineContent":[{"type":"text","text":"heap"}]},{"type":"text","text":" is used at runtime for "},{"type":"emphasis","inlineContent":[{"text":"dynamic","type":"text"}]},{"type":"text","text":" and other types of "},{"type":"emphasis","inlineContent":[{"text":"long-lived","type":"text"}]},{"type":"text","text":" memory"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Focus of this session"}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"process-memory"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Heap consists of multiple "},{"type":"strong","inlineContent":[{"text":"regions","type":"text"}]},{"type":"text","text":" as well"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Each region is broken up into ","type":"text"},{"inlineContent":[{"type":"text","text":"heap allocations"}],"type":"strong"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Each of them is made up of 16KB ","type":"text"},{"inlineContent":[{"text":"memory pages","type":"text"}],"type":"strong"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Note: generally, the memory page size is SoC dependent","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Individual allocations can be bigger or smaller"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Memory pages can be of 3 types:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"text":"Clean","type":"text"}],"type":"strong"},{"text":" pages are memory that hasn’t been written to","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Allocated but unused"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Files mapped read-only from disk"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Dirty","type":"text"}],"type":"strong"},{"text":" pages have been written to recently by the process","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Can be "},{"inlineContent":[{"type":"text","text":"swapped"}],"type":"emphasis"},{"type":"text","text":" under memory pressure"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Swapped","type":"text"}],"type":"strong"},{"text":" pages are memory compressed or written to disk","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When needed, can be decompressed or faulted from disk again"}]}]}]}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Only ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"dirty"}]},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"swapped"}]},{"text":" pages count towards ","type":"text"},{"type":"strong","inlineContent":[{"text":"memory footprint","type":"text"}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"heap-breakdown"}]},{"anchor":"malloc","text":"malloc","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Allow memory to outlive current scope until "},{"type":"codeVoice","code":"free"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"16-byte minimum allocation size","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Most small allocations are 0’ed when ","type":"text"},{"code":"free","type":"codeVoice"},{"text":"d","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Debugging features"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Stack logging","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Track when memory was allocated"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Enabled in Scheme Diagnostics tab in Xcode"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Xcode memory report"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Shows footprint over time"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Does not show causes for memory footprint growth"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Memory Graph Debugger"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Useful for focusing on a specific allocation","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Includes backtraces for each allocation when ","type":"text"},{"code":"malloc","type":"codeVoice"},{"text":" stack logging is enabled","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Located in Xcode debug bar"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"CLI"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"leaks"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"heap"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"vmmap"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"malloc_history","type":"codeVoice"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"Instruments","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Allocations","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"History of all allocation and "},{"code":"free","type":"codeVoice"},{"type":"text","text":" events over time"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Leaks"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Detects memory leaks"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}]},{"anchor":"Transient-growth","text":"Transient growth","type":"heading","level":1},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Memory spikes are one type of transient growth","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Can mean memory pressure and termination of the process","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Can cause fragmentation in heap memory"}]}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Allocations template in Instruments is useful for diagnosing memory spikes"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"identifier":"transient-memory-growth","type":"image"}]},{"anchor":"Autorelease-Pools","text":"Autorelease Pools","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Can be a common reason for memory spikes"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Used by Objective-C to extend object lifetimes"}]}]},{"content":[{"inlineContent":[{"text":"Autorelease pools delay release of return values until later","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Calling into Objective-C APIs from Swift can produce autorelease pools"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A loop enclosed in an autorelease pool can autorelease a lot of objects"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Lots of objects will be released at once, when the pool is ","type":"text"},{"inlineContent":[{"type":"text","text":"drained"}],"type":"emphasis"}]}]}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Could define a local autorelease pool for each iteration of the loop"}],"type":"paragraph"}]}]},{"code":["\/\/ The outer autorelease pool can autorelease a lot of objects:","autoreleasepool {","    for _ in 1...1000 {","        \/\/ Autoreleases into nested pool, preventing outer pool from bloating.","        autoreleasepool {","            print(\"Now is \\(Date.now)\")","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Persistent-growth","text":"Persistent growth","type":"heading","level":1},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Memory that doesn’t get deallocated","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Increasing footprint over time","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"In Instruments, use the Mark Generation button to break down memory growth by timespan","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Subsequent generations collect persistent allocations made after the previous generation"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Snapshots can be viewed in Memory Graph Debugger"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"type":"paragraph","inlineContent":[{"identifier":"persistent-memory-growth","type":"image"}]},{"anchor":"Memory-leaks","text":"Memory leaks","type":"heading","level":1},{"anchor":"Reachability","text":"Reachability","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Memory must be reachable from somewhere in program to be used in future","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"3 kinds of memory on the heap:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Useful"}],"type":"strong"},{"type":"text","text":" memory is reachable using non-weak references and can be used again"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Abandoned","type":"text"}],"type":"strong"},{"text":" memory is reachable but ","type":"text"},{"inlineContent":[{"text":"won’t","type":"text"}],"type":"emphasis"},{"text":" be used again","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Excessive caching or singletons"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Still counts towards the footprint","type":"text"}],"type":"paragraph"}]}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Leaked","type":"text"}]},{"type":"text","text":" memory is unreachable and can’t ever be used again"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Loss of a pointer through a manually managed allocation","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"A reference cycle","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Leaked memory can be identified using Memory Graph Debugger"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Marked automatically"}],"type":"paragraph"}]}],"type":"unorderedList"}]}]},{"anchor":"Closure-context","text":"Closure context","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Swift closures capture values by allocating memory on the heap"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Closure metadata shows up as "},{"code":"[capture]","type":"codeVoice"},{"type":"text","text":" – names are not included"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Captured references are "},{"type":"codeVoice","code":"strong"},{"type":"text","text":" by default"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"If this is a cause for a leak, use ","type":"text"},{"code":"weak","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"unowned","type":"codeVoice"},{"text":" instead","type":"text"}],"type":"paragraph"}]}]},{"anchor":"Runtime-speed","text":"Runtime speed","type":"heading","level":1},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Reducing memory can improve performance","type":"text"}]}]}]},{"anchor":"Weak-references","text":"Weak references","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Always valid to use","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Always an optional","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Come with overhead: weak reference storage table needs to be allocated"}],"type":"paragraph"}]}]},{"anchor":"Unowned-references","text":"Unowned references","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Force-unwrapped "},{"type":"codeVoice","code":"weak"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-optional and constant"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"More efficient than "},{"type":"codeVoice","code":"weak"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Not always valid to use"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Destination won’t be deallocated while an "},{"type":"codeVoice","code":"unowned"},{"type":"text","text":" reference exists"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"type":"codeVoice","code":"weak"},{"text":" if unknown how long destination will live","type":"text"}]}]}],"type":"unorderedList"}]}]},{"rows":[[[{"inlineContent":[{"text":"-","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"code":"weak","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"unowned"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Accessing when destination has been deinitialized"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"nil"},{"text":" (safe)","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Crash","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Memory cost","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"32 bytes per destination","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"None"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Runtime cost compared to ","type":"text"},{"type":"codeVoice","code":"strong"}],"type":"paragraph"}],[{"inlineContent":[{"text":"~10x","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"~4x"}],"type":"paragraph"}]]],"type":"table","header":"row"},{"anchor":"Performance-tips","text":"Performance tips","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Managing memory manually or moving to an unsafe language is not always the answer"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Turn on whole module optimization to use inlining more aggressively"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Ensure struct copies are cheap","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Use fewer ","type":"text"},{"type":"codeVoice","code":"any"},{"text":" boxes and reference types in structs","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"text":"In Objective-C code:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Turning off ARC is not always the answer: bugs can be hard to debug"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"__attribute__(objc_direct)"},{"type":"text","text":" to allow inlining"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"__attribute__(objc_externally_retained)"},{"type":"text","text":" to eliminate "},{"type":"codeVoice","code":"retain"},{"type":"text","text":" and "},{"type":"codeVoice","code":"release"},{"type":"text","text":" when parameter lifetimes are guaranteed"}]}]}]}]}]},{"anchor":"Written-By","text":"Written By","type":"heading","level":2},{"numberOfColumns":5,"type":"row","columns":[{"content":[{"inlineContent":[{"type":"image","identifier":"philptr"}],"type":"paragraph"}],"size":1},{"content":[{"anchor":"Phil-Zakharchenko","type":"heading","level":3,"text":"Phil Zakharchenko"},{"type":"paragraph","inlineContent":[{"isActive":true,"overridingTitle":"Contributed Notes","type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/philptr","overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/philptr"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/x.com\/philzet"},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"isActive":true,"type":"reference","identifier":"https:\/\/"}]}],"size":4}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","isActive":true}]},{"anchor":"Related-Sessions","text":"Related Sessions","type":"heading","level":2},{"style":"list","type":"links","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10106-Profile-and-optimize-your-games-memory","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10180-Detect-and-diagnose-memory-issues","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24-10217-Explore-Swift-performance","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24-10170-Consume-noncopyable-types-in-Swift"]},{"type":"small","inlineContent":[{"inlineContent":[{"text":"Legal Notice","type":"text"}],"type":"strong"}]},{"type":"small","inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}]}],"kind":"content"}],"kind":"article","sampleCodeDownload":{"kind":"sampleDownload","action":{"overridingTitle":"Watch Video","identifier":"https:\/\/developer.apple.com\/wwdc24\/10173","isActive":true,"type":"reference"}},"schemaVersion":{"major":0,"patch":0,"minor":3},"abstract":[{"text":"Dive into the basis for your app’s dynamic memory: the heap! Explore how to use Instruments and Xcode to measure, analyze, and fix common heap issues. We’ll also cover some techniques and best practices for diagnosing transient growth, persistent growth, and leaks in your app.","type":"text"}],"references":{"doc://WWDCNotes/documentation/WWDCNotes/WWDC24-10170-Consume-noncopyable-types-in-Swift":{"type":"topic","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24-10170-Consume-noncopyable-types-in-Swift","title":"Consume noncopyable types in Swift","url":"\/documentation\/wwdcnotes\/wwdc24-10170-consume-noncopyable-types-in-swift","abstract":[{"text":"Get started with noncopyable types in Swift. Discover what copying means in Swift, when you might want to use a noncopyable type, and how value ownership lets you state your intentions clearly.","type":"text"}],"role":"sampleCode"},"heap-breakdown":{"variants":[{"traits":["1x","light"],"url":"\/images\/heap-breakdown.jpg"}],"alt":"The breakdown of the heap memory","identifier":"heap-breakdown","type":"image"},"philptr":{"variants":[{"traits":["1x","light"],"url":"\/images\/philptr.jpeg"}],"alt":"Profile image of Phil Zakharchenko","identifier":"philptr","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10180-Detect-and-diagnose-memory-issues":{"title":"Detect and diagnose memory issues","role":"sampleCode","type":"topic","kind":"article","abstract":[{"text":"Discover how you can understand and diagnose memory performance problems with Xcode. We’ll take you through the latest updates to Xcode’s tools, explore Metrics, check out the memgraph collection feature in XCTest, and learn how to catch regressions using a Performance XCTest.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10180-Detect-and-diagnose-memory-issues","url":"\/documentation\/wwdcnotes\/wwdc21-10180-detect-and-diagnose-memory-issues"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC24":{"title":"WWDC24","images":[{"identifier":"WWDC24-Icon.png","type":"icon"},{"identifier":"WWDC24.jpeg","type":"card"}],"kind":"article","abstract":[{"text":"Xcode 16, Swift 6, iOS 18, macOS 15 (Sequoia), tvOS 18, visionOS 2, watchOS 11.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: Swift Testing, ","type":"text"},{"type":"codeVoice","code":"FinanceKit"},{"text":", ","type":"text"},{"type":"codeVoice","code":"TabletopKit"},{"type":"text","text":", and more."}],"role":"collectionGroup","url":"\/documentation\/wwdcnotes\/wwdc24","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24"},"WWDCNotes.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/WWDCNotes.png"}],"alt":null,"identifier":"WWDCNotes.png","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes":{"role":"collection","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"title":"WWDC Notes","type":"topic","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"kind":"symbol","url":"\/documentation\/wwdcnotes"},"https://":{"url":"https:\/\/","title":"Blog","titleInlineContent":[{"text":"Blog","type":"text"}],"identifier":"https:\/\/","type":"link"},"doc://WWDCNotes/documentation/WWDCNotes/philptr":{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/philptr","url":"\/documentation\/wwdcnotes\/philptr","abstract":[{"type":"text","text":"macOS UI & Frameworks | previously AppKit @ Apple"}],"images":[{"identifier":"philptr.jpeg","type":"card"},{"identifier":"philptr.jpeg","type":"icon"}],"kind":"article","type":"topic","role":"sampleCode","title":"Phil Zakharchenko (5 notes)"},"https://developer.apple.com/wwdc24/10173":{"url":"https:\/\/developer.apple.com\/wwdc24\/10173","checksum":null,"identifier":"https:\/\/developer.apple.com\/wwdc24\/10173","type":"download"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC24-10217-Explore-Swift-performance":{"kind":"article","title":"Explore Swift performance","type":"topic","role":"sampleCode","abstract":[{"type":"text","text":"Discover how Swift balances abstraction and performance. Learn what elements of performance to consider and how the Swift optimizer affects them. Explore the different features of Swift and how they’re implemented to further understand  the tradeoffs available that can impact performance."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC24-10217-Explore-Swift-performance","url":"\/documentation\/wwdcnotes\/wwdc24-10217-explore-swift-performance"},"WWDC24-Icon.png":{"alt":null,"identifier":"WWDC24-Icon.png","type":"image","variants":[{"url":"\/images\/WWDC24-Icon.png","traits":["1x","light"]}]},"persistent-memory-growth":{"alt":"A memory footprint graph depicting a typical example of persistent growth.","identifier":"persistent-memory-growth","type":"image","variants":[{"traits":["1x","light"],"url":"\/images\/persistent-memory-growth.jpg"}]},"WWDC24.jpeg":{"alt":null,"identifier":"WWDC24.jpeg","type":"image","variants":[{"url":"\/images\/WWDC24.jpeg","traits":["1x","light"]}]},"https://github.com/philptr":{"identifier":"https:\/\/github.com\/philptr","type":"link","titleInlineContent":[{"text":"GitHub","type":"text"}],"title":"GitHub","url":"https:\/\/github.com\/philptr"},"process-memory":{"alt":"Types of memory in a running process","identifier":"process-memory","type":"image","variants":[{"url":"\/images\/process-memory.jpg","traits":["1x","light"]}]},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"title":"Contributions are welcome!","url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"philptr.jpeg":{"alt":null,"identifier":"philptr.jpeg","type":"image","variants":[{"url":"\/images\/philptr.jpeg","traits":["1x","light"]}]},"https://x.com/philzet":{"identifier":"https:\/\/x.com\/philzet","type":"link","titleInlineContent":[{"text":"X\/Twitter","type":"text"}],"title":"X\/Twitter","url":"https:\/\/x.com\/philzet"},"transient-memory-growth":{"alt":"A memory footprint graph depicting a typical example of transient growth.","identifier":"transient-memory-growth","type":"image","variants":[{"url":"\/images\/transient-memory-growth.jpg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-10106-Profile-and-optimize-your-games-memory":{"type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-10106-Profile-and-optimize-your-games-memory","role":"sampleCode","title":"Profile and optimize your game’s memory","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc22-10106-profile-and-optimize-your-games-memory","abstract":[{"type":"text","text":"Learn how Apple platforms calculate and allocate memory for your game. We’ll show you how to use Instruments and the Game Memory template to profile your game, take a memory graph to monitor current memory use, and analyze it using Xcode Memory Debugger and command line tools. We’ll also explore Metal resources in Metal Debugger and provide tips and tricks to further help you optimize memory usage."}]}}}