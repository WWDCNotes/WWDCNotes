{"kind":"article","identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110370-Debug-Swift-debugging-with-LLDB","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc22-110370-debug-swift-debugging-with-lldb"]}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"What-does-LLDB-need-in-order-to-show-source-code","text":"What does LLDB need in order to show source code?","type":"heading"},{"items":[{"content":[{"inlineContent":[{"text":"When the compiler compiles a function in a ","type":"text"},{"text":".swift","type":"text"},{"text":" file, it generates machine code (store in ","type":"text"},{"text":".o","type":"text"},{"text":" object files)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"on debug builds, "},{"type":"text","text":".o"},{"type":"text","text":" files come with a "},{"type":"codeVoice","code":"__debug_info"},{"type":"text","text":" segment, which contains addresses in the executable that can be mapped to a source file and line number, and vice versa"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"for archiving and distribution, debug info can be linked into ","type":"text"},{"text":".dSYM","type":"text"},{"text":" bundles","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the debug info linker is called "},{"type":"codeVoice","code":"dsymutil"}]}]}],"type":"unorderedList"},{"level":2,"anchor":"image-and-path-remap","text":"`image` and path remap","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"use "},{"type":"codeVoice","code":"image list nameOfFramework"},{"type":"text","text":" to check whether LLDB has found the debug dSYM of a third party framework embedded in our app"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"use ","type":"text"},{"type":"codeVoice","code":"image lookup 0xMemoryAddressHere"},{"text":" to get more info about the current address","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"to remap source "},{"type":"text","text":".dSYM"},{"type":"text","text":" paths, use "},{"type":"codeVoice","code":"settings set target.source-map old\/path new\/path"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"tip: instead of doing this at each session, create a lldb init file that is run at the beginning of each session (point to this file in your scheme)"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"text":"alternatively, each ","type":"text"},{"text":".dSYM","type":"text"},{"text":" bundle comes with a ","type":"text"},{"text":"UUID.plist","type":"text"},{"text":" where we can set a ","type":"text"},{"code":"DBGSourcePathRemapping","type":"codeVoice"},{"text":" dictionary","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":2,"anchor":"Source-path-canonicalization","text":"Source path canonicalization","type":"heading"},{"items":[{"content":[{"inlineContent":[{"text":"We can instruct the compiler to canonicalize source paths before putting them into the debug info","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"This is done using the ","type":"text"},{"code":"-debug-prefix-map","type":"codeVoice"},{"text":" option","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This way the machine-specific path prefix can be replaced by a unique, canonical placeholder name that can then be remapped to the local path in LLDB"}]}]}],"type":"unorderedList"},{"syntax":"shell","code":["\/\/ Clang:","-fdebug-prefix-map $PWD=\/BUILDROOT","","\/\/ Swift:","-debug-prefix-map $PWD=\/BUILDROOT"],"type":"codeListing"},{"level":3,"anchor":"popexpr-vs-v-frame","text":"po,p,expr vs v, frame","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"LLDB is both a debugger and a compiler","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"based on whether our LLDB command sides in the debugger or compiler side of LLDB, they might or or not fail"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"(debugger side) ","type":"text"},{"code":"v","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"frame","type":"codeVoice"},{"text":" get their type information from LLDB Debug Info (which in turn gets types from Swift reflection metadata_","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"(compiler side) ","type":"text"},{"type":"codeVoice","code":"p"},{"text":", ","type":"text"},{"type":"codeVoice","code":"po"},{"text":", ","type":"text"},{"type":"codeVoice","code":"expr"},{"text":" get type information from Modules","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Modules are how the compiler organizes type declarations","type":"text"}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"How do we start diagnosing an issue that is happening on the compiler side?","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"new in Xcode 14, we have "},{"type":"codeVoice","code":"swift-healthcheck"},{"type":"text","text":" LLDB command"}]}]},{"content":[{"inlineContent":[{"text":"it helps understanding if and why a module import failed","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it saves a "},{"type":"text","text":".log"},{"type":"text","text":" of the Swift expression evaluator configuration"}]}]}],"type":"unorderedList"},{"level":2,"anchor":"How-LLDBs-compiler-finds-Swift-modules","text":"How LLDB’s compiler finds Swift modules?","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"It’s the build system’s job to package up the modules so LLDB can find them"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Modules from system frameworks stay in the SDK (anyone can find them via "},{"code":"$ xcrun --show-sdk-path","type":"codeVoice"},{"type":"text","text":"), LLDB will find a matching SDK to read them from as it’s attaching to your program"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"when debugging straight from the "},{"type":"text","text":".o"},{"type":"text","text":" object files, LLDB will find all non-SDK modules where they were at build time"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"dsymutil","type":"codeVoice"},{"text":" can package a debug info archive (","type":"text"},{"text":".dSYM","type":"text"},{"text":" bundle) for every dynamic library, framework or dylib, and executable","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"each .dSYM bundle can contain binary Swift modules, which may contain bridging headers "},{"type":"text","text":".h"},{"type":"text","text":", textual Swift interface files "},{"type":"text","text":".swiftinterface"},{"type":"text","text":", and most importantly, debug info."}]}]},{"content":[{"inlineContent":[{"text":"for static archives, a Swift module needs to be registered with the linker (","type":"text"},{"code":"ld ... -add-ast-path \/path\/to\/My.swiftmodule","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"for dynamic libraries and executables, the build system will do this automatically for you. But for static archives, this is needed because static archives are not produced by the linker","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Xcode’s build system should do this for you, but you need to be aware if you have your own build system","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"You can check your build log to verify that that everything is linked, or use ","type":"text"},{"code":"dsymutil","type":"codeVoice"},{"text":" to dump the symbol table of your executable and grep for “swiftmodule”:","type":"text"}],"type":"paragraph"},{"syntax":"shell","code":["dsymutil -s MyApp | grep .swiftmodule"],"type":"codeListing"},{"inlineContent":[{"text":"In Linux the swift driver supports a ","type":"text"},{"code":"-modulewrap","type":"codeVoice"},{"text":" flag that converts binary Swift module files into objects that you can link into your binary together with the rest of the debug info. LLDB will find it there","type":"text"}],"type":"paragraph"},{"syntax":"shell","code":["swiftc -modulewrap My.swiftmodule -o My.swiftmodule.o"],"type":"codeListing"},{"level":2,"anchor":"Avoiding-serialized-search-paths-in-Swift-modules","text":"Avoiding serialized search paths in Swift modules","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"The Swift compiler will serialize Clang header search paths and other related options into the binary "},{"type":"text","text":".swiftmodule"},{"type":"text","text":" files"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This is great, because it makes importing their Clang module dependencies just work during the build"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"But when building on a different machine, these local paths can be detrimental"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Before shipping a binary "},{"type":"text","text":".swiftmodule"},{"type":"text","text":" to another machine, set the "},{"code":"-no-serialize-debugging-options","type":"codeVoice"},{"type":"text","text":" compiler flag"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"In Xcode this is controlled via the ","type":"text"},{"type":"codeVoice","code":"SWIFT_SERIALIZE_DEBUGGING_OPTIONS"},{"text":" setting","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"you can then reintroduce these search paths in LLDB with one of the following settings:"}],"type":"paragraph"}]}],"type":"unorderedList"},{"syntax":"shell","code":["settings set target.swift-extra-clang-flags …","settings set target.swift-framework-search-paths …","settings set target.swift-module-search-paths …"],"type":"codeListing"},{"level":2,"anchor":"Written-By","text":"Written By","type":"heading"},{"numberOfColumns":5,"columns":[{"size":1,"content":[{"inlineContent":[{"type":"image","identifier":"zntfdr"}],"type":"paragraph"}]},{"size":4,"content":[{"level":3,"text":"Federico Zanetello","type":"heading","anchor":"Federico-Zanetello"},{"inlineContent":[{"overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"isActive":true,"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","overridingTitle":"Contributed Notes"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/zntfdr"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/zntfdr.dev"}],"type":"paragraph"}]}],"type":"row"},{"type":"thematicBreak"},{"inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"reference","isActive":true}],"type":"paragraph"},{"level":2,"anchor":"Related-Sessions","text":"Related Sessions","type":"heading"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10209-Discover-breakpoint-improvements","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10211-Symbolication-Beyond-the-basics","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-429-LLDB-Beyond-po","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-412-Advanced-Debugging-with-Xcode-and-LLDB"],"type":"links"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2025 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}]}],"metadata":{"title":"Debug Swift debugging with LLDB","role":"sampleCode","roleHeading":"WWDC22","modules":[{"name":"WWDC Notes"}]},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22"]]},"sampleCodeDownload":{"kind":"sampleDownload","action":{"identifier":"https:\/\/developer.apple.com\/wwdc22\/110370","isActive":true,"type":"reference","overridingTitle":"Watch Video (20 min)"}},"abstract":[{"text":"Learn how you can set up complex Swift projects for debugging. We’ll take you on a deep dive into the internals of LLDB and debug info. We’ll also share best practices for complex scenarios such as debugging code built on build servers or code from custom build systems.","type":"text"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"references":{"https://zntfdr.dev":{"title":"Blog","type":"link","identifier":"https:\/\/zntfdr.dev","titleInlineContent":[{"type":"text","text":"Blog"}],"url":"https:\/\/zntfdr.dev"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"type":"topic","images":[{"type":"card","identifier":"zntfdr.jpeg"},{"type":"icon","identifier":"zntfdr.jpeg"}],"title":"Federico Zanetello (332 notes)","url":"\/documentation\/wwdcnotes\/zntfdr","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","kind":"article","abstract":[{"type":"text","text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more."}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22":{"url":"\/documentation\/wwdcnotes\/wwdc22","kind":"article","abstract":[{"text":"Xcode 14, Swift 5.7, iOS 16, macOS 13 (Ventura), tvOS 16, watchOS 9.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"code":"WeatherKit","type":"codeVoice"},{"text":", ","type":"text"},{"code":"ScreenCaptureKit","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Swift Regex","type":"codeVoice"},{"text":", and more.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22","title":"WWDC22","images":[{"type":"icon","identifier":"WWDC22-Icon.png"},{"type":"card","identifier":"WWDC22.jpeg"}],"role":"collectionGroup","type":"topic"},"WWDC22.jpeg":{"identifier":"WWDC22.jpeg","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC22.jpeg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes":{"url":"\/documentation\/wwdcnotes","kind":"symbol","abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","title":"WWDC Notes","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"role":"collection","type":"topic"},"https://developer.apple.com/wwdc22/110370":{"checksum":null,"url":"https:\/\/developer.apple.com\/wwdc22\/110370","type":"download","identifier":"https:\/\/developer.apple.com\/wwdc22\/110370"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10209-Discover-breakpoint-improvements":{"title":"Discover breakpoint improvements","url":"\/documentation\/wwdcnotes\/wwdc21-10209-discover-breakpoint-improvements","kind":"article","abstract":[{"text":"Breakpoints can help you debug issues by allowing you to pause and inspect problems in the middle of a process. Discover the latest improvements to breakpoints in Xcode including column and unresolved breakpoints. We’ll also go over best practices for general breakpoints and LLDB tips and tricks.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10209-Discover-breakpoint-improvements","type":"topic","role":"sampleCode"},"WWDC22-Icon.png":{"identifier":"WWDC22-Icon.png","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC22-Icon.png","traits":["1x","light"]}]},"zntfdr":{"alt":"Profile image of Federico Zanetello","type":"image","identifier":"zntfdr","variants":[{"url":"\/images\/WWDCNotes\/zntfdr.jpeg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC19-429-LLDB-Beyond-po":{"url":"\/documentation\/wwdcnotes\/wwdc19-429-lldb-beyond-po","kind":"article","abstract":[{"type":"text","text":"LLDB is a powerful tool for exploring and debugging your app at runtime. Discover the various ways to display values in your app, how to format custom data types, and how to extend LLDB using your own Python 3 scripts."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC19-429-LLDB-Beyond-po","title":"LLDB: Beyond “po”","role":"sampleCode","type":"topic"},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"title":"Contributions are welcome!","type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10211-Symbolication-Beyond-the-basics":{"kind":"article","url":"\/documentation\/wwdcnotes\/wwdc21-10211-symbolication-beyond-the-basics","title":"Symbolication: Beyond the basics","abstract":[{"type":"text","text":"Discover how you can achieve maximum performance and insightful debugging with your app. Symbolication is at the center of tools such as Instruments and LLDB to help bridge the layers between your application’s runtime and your source code. Learn how this process works and the steps you can take to gain the most insight into your app."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10211-Symbolication-Beyond-the-basics","type":"topic","role":"sampleCode"},"https://github.com/zntfdr":{"title":"GitHub","type":"link","identifier":"https:\/\/github.com\/zntfdr","titleInlineContent":[{"text":"GitHub","type":"text"}],"url":"https:\/\/github.com\/zntfdr"},"WWDCNotes.png":{"variants":[{"url":"\/images\/WWDCNotes\/WWDCNotes.png","traits":["1x","light"]}],"type":"image","identifier":"WWDCNotes.png","alt":null},"zntfdr.jpeg":{"identifier":"zntfdr.jpeg","type":"image","alt":null,"variants":[{"url":"\/images\/WWDCNotes\/zntfdr.jpeg","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC18-412-Advanced-Debugging-with-Xcode-and-LLDB":{"url":"\/documentation\/wwdcnotes\/wwdc18-412-advanced-debugging-with-xcode-and-lldb","kind":"article","abstract":[{"text":"Discover advanced techniques, and tips and tricks for enhancing your Xcode debugging workflows. Learn how to take advantage of LLDB and custom breakpoints for more powerful debugging. Get the most out of Xcode’s view debugging tools to solve UI issues in your app more efficiently.","type":"text"}],"title":"Advanced Debugging with Xcode and LLDB","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC18-412-Advanced-Debugging-with-Xcode-and-LLDB","role":"sampleCode","type":"topic"}}}