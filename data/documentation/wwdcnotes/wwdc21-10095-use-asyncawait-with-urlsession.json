{"schemaVersion":{"major":0,"patch":0,"minor":3},"metadata":{"title":"Use async\/await with URLSession","modules":[{"name":"WWDC Notes"}],"roleHeading":"WWDC21","role":"sampleCode"},"abstract":[{"type":"text","text":"Discover how you can adopt Swift concurrency in URLSession using async\/await and AsyncSequence, and how you can apply Swift concurrency concepts to improve your networking code."}],"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/wwdcnotes\/wwdc21-10095-use-asyncawait-with-urlsession"]}],"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21"]]},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Fetching data","anchor":"Fetching-data"},{"type":"paragraph","inlineContent":[{"text":"Two main methods:","type":"text"}]},{"type":"codeListing","code":["func data(from url: URL) async throws -> (Data, URLResponse)","func data(for request: URLRequest) async throws -> (Data, URLResponse)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Example:"}]},{"type":"codeListing","code":["\/\/ Fetch photo with async\/await","","func fetchPhoto(url: URL) async throws -> UIImage {","  let (data, response) = try await URLSession.shared.data(from: url)","","  guard let httpResponse = response as? HTTPURLResponse,","        httpResponse.statusCode == 200 else {","    throw MyNetworkingError.invalidServerResponse","  }","","  guard let image = UIImage(data: data) else {","    throw MyNetworkingError.unsupportedImage","  }","","  return image","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Upload data","anchor":"Upload-data"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Two main methods:"}]},{"type":"codeListing","code":["func upload(for request: URLRequest, from data: Data) async throws -> (Data, URLResponse)","func upload(for request: URLRequest, fromFile url: URL) async throws -> (Data, URLResponse)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Example:","type":"text"}]},{"type":"codeListing","code":["var request = URLRequest(url: url)","request.httpMethod = \"POST\"","","let (data, response) = try await URLSession.shared.upload(for: request, fromFile: fileURL)","guard let httpResponse = response as? HTTPURLResponse,","      httpResponse.statusCode == 201 \/* Created *\/ else {","  throw MyNetworkingError.invalidServerResponse","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"Download data","anchor":"Download-data"},{"type":"paragraph","inlineContent":[{"text":"Methods:","type":"text"}]},{"type":"codeListing","code":["func download(from url: URL) async throws -> (URL, URLResponse)","func download(for request: URLRequest) async throws -> (URL, URLResponse)","func download(resumeFrom resumeData: Data) async throws -> (URL, URLResponse)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Unlike download task convenience methods, these new methods do not automatically delete the file: don’t forget to do so yourself.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Example:"}]},{"type":"codeListing","code":["let (location, response) = try await URLSession.shared.download(from: url)","guard let httpResponse = response as? HTTPURLResponse,","      httpResponse.statusCode == 200 \/* OK *\/ else {","  throw MyNetworkingError.invalidServerResponse","}","","try FileManager.default.moveItem(at: location, to: newLocation)"],"syntax":"swift"},{"type":"heading","level":2,"text":"Cancellation","anchor":"Cancellation"},{"type":"paragraph","inlineContent":[{"text":"Swift concurrency’s cancellation works with URLSession async methods: calling ","type":"text"},{"code":"cancel()","type":"codeVoice"},{"text":" on a task that contains running network operations will cancel such operations.","type":"text"}]},{"type":"codeListing","code":["let task = Task {","  let (data1, response1) = try await URLSession.shared.data(from: url1)","  let (data2, response2) = try await URLSession.shared.data(from: url2)","}","","task.cancel()"],"syntax":"swift"},{"type":"heading","level":2,"text":"Increment download `URLSession.bytes`","anchor":"Increment-download-URLSessionbytes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"URLSession.bytes methods return when the response headers have been received and deliver the response body as an AsyncSequence of bytes."}]},{"type":"paragraph","inlineContent":[{"text":"Example:","type":"text"}]},{"type":"codeListing","code":["let (bytes, response) = try await URLSession.shared.bytes(from: Self.eventStreamURL)","","guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {","  throw WoofError.invalidServerResponse","}","","for try await line in bytes.lines {","  let photoMetadata = try JSONDecoder().decode(PhotoMetadata.self, from: Data(line.utf8))","  await updateFavoriteCount(with: photoMetadata) \/\/ 👈🏻 need to execute in the main actor","}"],"syntax":"swift"},{"type":"heading","level":2,"text":"URLSessionTask-specific delegate","anchor":"URLSessionTask-specific-delegate"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"URLSession"},{"type":"text","text":" is designed around a delegate model which provides callbacks for events such as authentication challenges, metrics, and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new async methods no longer expose the underlying "},{"type":"codeVoice","code":"URLSession.task"},{"type":"text","text":", instead, we specify a delegate via an optional argument, a task-specific delegate, allowing you to provide an object to handle delegate messages specific to this data upload, download, or bytes operation."}]},{"type":"codeListing","code":["func data(from url: URL, delegate: URLSessionTaskDelegate?)","func data(for request: URLRequest, delegate: URLSessionTaskDelegate?)","func upload(for request: URLRequest, fromFile url: URL, delegate: URLSessionTaskDelegate?)","func upload(for request: URLRequest, from data: Data, delegate: URLSessionTaskDelegate?)","func download(from url: URL, delegate: URLSessionTaskDelegate?)","func download(for request: URLRequest, delegate: URLSessionTaskDelegate?)","func download(resumeFrom resumeData: Data, delegate: URLSessionTaskDelegate?)","func bytes(from url: URL, delegate: URLSessionTaskDelegate?)","func bytes(for request: URLRequest, delegate: URLSessionTaskDelegate?)"],"syntax":"swift"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"the same task is supported in Objective-C"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"the task is strongly held by a task until it completes or fails"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"task-specific delegate is not supported by background URLSession"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a method is implemented on both session delegate and task delegate, the one on task delegate will be called"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Example:"}]},{"type":"codeListing","code":["class AuthenticationDelegate: NSObject, URLSessionTaskDelegate {","  private let signInController: SignInController","  ","  init(signInController: SignInController) {","    self.signInController = signInController","  }","  ","  func urlSession(","  \t_ session: URLSession,","    task: URLSessionTask,","    didReceive challenge: URLAuthenticationChallenge","  ) async -> (URLSession.AuthChallengeDisposition, URLCredential?) {","    if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodHTTPBasic {","      do {","        let (username, password) = try await signInController.promptForCredential()","        return (.useCredential, URLCredential(user: username, password: password, persistence: .forSession))","      } catch {","        return (.cancelAuthenticationChallenge, nil)","      }","    } else {","      return (.performDefaultHandling, nil)","    }","  }","}","","...","","let (bytes, response) = try await URLSession.shared.bytes(","\tfrom: Self.eventStreamURL, ","\tdelegate: AuthenticationDelegate()",")"],"syntax":"swift"},{"type":"heading","level":2,"text":"Written By","anchor":"Written-By"},{"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"identifier":"donnywals","type":"image"}],"type":"paragraph"}]},{"size":4,"content":[{"text":"Donny Wals","level":3,"anchor":"Donny-Wals","type":"heading"},{"inlineContent":[{"overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/donnywals","type":"reference","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"https:\/\/github.com\/donnywals","type":"reference","isActive":true},{"type":"text","text":" "},{"type":"text","text":"|"},{"type":"text","text":" "},{"identifier":"https:\/\/www.donnywals.com","type":"reference","isActive":true}],"type":"paragraph"}]}],"numberOfColumns":5},{"type":"row","columns":[{"size":1,"content":[{"inlineContent":[{"identifier":"zntfdr","type":"image"}],"type":"paragraph"}]},{"size":4,"content":[{"text":"Federico Zanetello","level":3,"anchor":"Federico-Zanetello","type":"heading"},{"inlineContent":[{"overridingTitle":"Contributed Notes","overridingTitleInlineContent":[{"type":"text","text":"Contributed Notes"}],"type":"reference","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/zntfdr","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"type":"reference","identifier":"https:\/\/zntfdr.dev","isActive":true}],"type":"paragraph"}]}],"numberOfColumns":5},{"type":"thematicBreak"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Missing anything? Corrections? "},{"type":"reference","isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}]},{"type":"heading","level":2,"text":"Related Sessions","anchor":"Related-Sessions"},{"type":"links","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10058-Meet-AsyncSequence","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10094-Accelerate-networking-with-HTTP3-and-QUIC","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift"],"style":"list"},{"type":"small","inlineContent":[{"type":"strong","inlineContent":[{"text":"Legal Notice","type":"text"}]}]},{"type":"small","inlineContent":[{"text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved.","type":"text"},{"text":" ","type":"text"},{"text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries.","type":"text"},{"text":" ","type":"text"},{"text":"This website is not made by, affiliated with, nor endorsed by Apple.","type":"text"}]}]}],"kind":"article","sampleCodeDownload":{"kind":"sampleDownload","action":{"overridingTitle":"Watch Video (13 min)","identifier":"https:\/\/developer.apple.com\/wwdc21\/10095","isActive":true,"type":"reference"}},"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10095-Use-asyncawait-with-URLSession","interfaceLanguage":"swift"},"references":{"WWDCNotes.png":{"alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDCNotes.png","traits":["1x","light"]}],"identifier":"WWDCNotes.png","type":"image"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10058-Meet-AsyncSequence":{"abstract":[{"text":"Iterating over a sequence of values over time is now as easy as writing a “for” loop. Find out how the new AsyncSequence protocol enables a natural, simple syntax for iterating over anything from notifications to bytes being streamed from a server. We’ll also show you how to adapt existing code to provide asynchronous sequences of your own.","type":"text"}],"url":"\/documentation\/wwdcnotes\/wwdc21-10058-meet-asyncsequence","title":"Meet AsyncSequence","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10058-Meet-AsyncSequence","type":"topic","role":"sampleCode","kind":"article"},"WWDC21.jpeg":{"identifier":"WWDC21.jpeg","type":"image","variants":[{"url":"\/images\/WWDCNotes\/WWDC21.jpeg","traits":["1x","light"]}],"alt":null},"donnywals":{"identifier":"donnywals","alt":"Profile image of Donny Wals","variants":[{"url":"\/images\/WWDCNotes\/donnywals.jpeg","traits":["1x","light"]}],"type":"image"},"https://zntfdr.dev":{"titleInlineContent":[{"text":"Blog","type":"text"}],"url":"https:\/\/zntfdr.dev","title":"Blog","identifier":"https:\/\/zntfdr.dev","type":"link"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10094-Accelerate-networking-with-HTTP3-and-QUIC":{"abstract":[{"type":"text","text":"The web is changing, and the next major version of HTTP is here. Learn how HTTP\/3 reduces latency and improves reliability for your app and discover how its underlying transport, QUIC, unlocks new innovations in your own custom protocols using new transport functionality and multi-streaming connection groups."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10094-Accelerate-networking-with-HTTP3-and-QUIC","kind":"article","role":"sampleCode","type":"topic","title":"Accelerate networking with HTTP\/3 and QUIC","url":"\/documentation\/wwdcnotes\/wwdc21-10094-accelerate-networking-with-http3-and-quic"},"zntfdr.jpeg":{"identifier":"zntfdr.jpeg","type":"image","variants":[{"url":"\/images\/WWDCNotes\/zntfdr.jpeg","traits":["1x","light"]}],"alt":null},"doc://WWDCNotes/documentation/WWDCNotes":{"role":"collection","images":[{"identifier":"WWDCNotes.png","type":"icon"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","title":"WWDC Notes","type":"topic","kind":"symbol","url":"\/documentation\/wwdcnotes","abstract":[{"type":"text","text":"Session notes shared by the community for the community."}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21-10132-Meet-asyncawait-in-Swift":{"title":"Meet async\/await in Swift","type":"topic","role":"sampleCode","abstract":[{"type":"text","text":"Swift now supports asynchronous functions — a pattern commonly known as async\/await. Discover how the new syntax can make your code easier to read and understand. Learn what happens when a function suspends, and find out how to adapt existing completion handlers to asynchronous functions."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21-10132-Meet-asyncawait-in-Swift","kind":"article","url":"\/documentation\/wwdcnotes\/wwdc21-10132-meet-asyncawait-in-swift"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC21":{"title":"WWDC21","type":"topic","role":"collectionGroup","abstract":[{"type":"text","text":"Xcode 13, Swift 5.5, iOS 15, macOS 12 (Monterey), tvOS 15, watchOS 8."},{"type":"text","text":" "},{"type":"text","text":"New APIs: "},{"code":"MusicKit","type":"codeVoice"},{"type":"text","text":", "},{"code":"DocC","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"StoreKit 2"},{"text":", and more.","type":"text"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC21","kind":"article","images":[{"type":"icon","identifier":"WWDC21-Icon.png"},{"type":"card","identifier":"WWDC21.jpeg"}],"url":"\/documentation\/wwdcnotes\/wwdc21"},"zntfdr":{"identifier":"zntfdr","alt":"Profile image of Federico Zanetello","variants":[{"url":"\/images\/WWDCNotes\/zntfdr.jpeg","traits":["1x","light"]}],"type":"image"},"WWDC21-Icon.png":{"alt":null,"variants":[{"url":"\/images\/WWDCNotes\/WWDC21-Icon.png","traits":["1x","light"]}],"identifier":"WWDC21-Icon.png","type":"image"},"https://github.com/zntfdr":{"identifier":"https:\/\/github.com\/zntfdr","title":"GitHub","type":"link","titleInlineContent":[{"text":"GitHub","type":"text"}],"url":"https:\/\/github.com\/zntfdr"},"doc://WWDCNotes/documentation/WWDCNotes/zntfdr":{"title":"Federico Zanetello (332 notes)","type":"topic","role":"sampleCode","abstract":[{"type":"text","text":"Software engineer with a strong passion for well-written code, thought-out composable architectures, automation, tests, and more."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/zntfdr","kind":"article","images":[{"type":"card","identifier":"zntfdr.jpeg"},{"type":"icon","identifier":"zntfdr.jpeg"}],"url":"\/documentation\/wwdcnotes\/zntfdr"},"doc://WWDCNotes/documentation/WWDCNotes/donnywals":{"kind":"article","abstract":[{"type":"text","text":"No Bio on GitHub"}],"url":"\/documentation\/wwdcnotes\/donnywals","images":[{"type":"card","identifier":"donnywals.jpeg"},{"type":"icon","identifier":"donnywals.jpeg"}],"title":"Donny Wals (3 notes)","type":"topic","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/donnywals","role":"sampleCode"},"https://github.com/donnywals":{"identifier":"https:\/\/github.com\/donnywals","titleInlineContent":[{"text":"GitHub","type":"text"}],"url":"https:\/\/github.com\/donnywals","title":"GitHub","type":"link"},"https://developer.apple.com/wwdc21/10095":{"url":"https:\/\/developer.apple.com\/wwdc21\/10095","checksum":null,"identifier":"https:\/\/developer.apple.com\/wwdc21\/10095","type":"download"},"donnywals.jpeg":{"identifier":"donnywals.jpeg","type":"image","variants":[{"url":"\/images\/WWDCNotes\/donnywals.jpeg","traits":["1x","light"]}],"alt":null},"https://www.donnywals.com":{"titleInlineContent":[{"text":"Blog","type":"text"}],"url":"https:\/\/www.donnywals.com","title":"Blog","identifier":"https:\/\/www.donnywals.com","type":"link"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency":{"role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC22-110351-Eliminate-data-races-using-Swift-Concurrency","title":"Eliminate data races using Swift Concurrency","kind":"article","type":"topic","url":"\/documentation\/wwdcnotes\/wwdc22-110351-eliminate-data-races-using-swift-concurrency","abstract":[{"type":"text","text":"Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We’ll take you through Swift’s approach to eliminating data races and its effect on app architecture. We’ll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system."}]},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}],"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","type":"link"}}}