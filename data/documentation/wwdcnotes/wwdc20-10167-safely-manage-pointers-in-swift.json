{"metadata":{"role":"sampleCode","roleHeading":"WWDC20","title":"Safely manage pointers in Swift","modules":[{"name":"WWDC Notes"}]},"schemaVersion":{"major":0,"patch":0,"minor":3},"variants":[{"paths":["\/documentation\/wwdcnotes\/wwdc20-10167-safely-manage-pointers-in-swift"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10167-Safely-manage-pointers-in-Swift","interfaceLanguage":"swift"},"sections":[],"kind":"article","primaryContentSections":[{"content":[{"level":2,"type":"heading","anchor":"overview","text":"Overview"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":"To get the most out of it, you should be familiar with Swift and the C programming language."}],"type":"paragraph"}],"type":"aside","name":"Note"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"C programming language, pointer and array arithmetic in C, data representation in bit-level and run-time memory."}]}],"type":"aside","name":"You should at least have these pre-knowledge to understand this session"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":"I recommend you to read the note and watch this session again."}],"type":"paragraph"}],"type":"aside","name":"Note"},{"style":"note","content":[{"inlineContent":[{"text":"This topic is not the kind of details that app developers typically need to worry about.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Note"},{"inlineContent":[{"text":"Managing pointers safely means knowing all the different ways they can be unsafe.","type":"text"}],"type":"paragraph"},{"level":2,"type":"heading","anchor":"Levels-of-safety","text":"Levels of safety"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-levels_of_safety"}],"type":"paragraph"},{"header":"row","type":"table","rows":[[[{"inlineContent":[{"text":"Level of safety","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Swift API"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Description","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Safe"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"collections"},{"type":"text","text":", "},{"type":"codeVoice","code":"slices"},{"type":"text","text":", "},{"type":"codeVoice","code":"iterators"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Safe code. It’s recommended write code at the highest safety level possible. "},{"type":"strong","inlineContent":[{"type":"text","text":"Not using pointers at all is a great strategy for code safety."}]}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Unsafe"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"UnsafePointer<T>"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"UnsafePointer lets use pointers without worrying about type safety."}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Raw"}],"type":"paragraph"}],[{"inlineContent":[{"code":"UnsafeRawPointer","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"UnsafeRawPointer lets you work with raw memory as a sequence of bytes.","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Mutable type"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Memory-binding APIs","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Swift provides a few APIs for binding memory to types.                                                                     You’re taking all the responsibility for pointer type safety.","type":"text"}],"type":"paragraph"}]]]},{"level":3,"type":"heading","anchor":"Safe-Swift-code","text":"Safe Swift code"},{"inlineContent":[{"identifier":"WWDC20-10167-safe_swift_code","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Safe code isn’t necessarily correct code but it does behave predictably."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The compiler will catch the error if a programming error can lead to unpredictable behavior."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Runtime checks guarantee the error will make the program crashes immediately.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Safe code is really about error enforcement."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Unsafe-Swift-code","text":"Unsafe Swift code"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-unsafe_swift_code"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Testing provides helpful diagnostics, but depends on the level of safety."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Unsafe standard library APIs have assertions and debug builds that catch certain kinds of invalid input."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Adding own preconditions to verify unsafe assumptions is a good practice."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Sanitizer Diagnostics are great to pinpoint bugs, but don’t catch all undefined behavior.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"When errors are not uncovered during testing they can lead to unexpected runtime behavior, the worst thing is corrupting or losing data.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":2,"type":"heading","anchor":"Pointer-Safety","text":"Pointer Safety"},{"level":3,"type":"heading","anchor":"Pointers-unsafe-reason-1","text":"Pointer’s unsafe reason 1"},{"inlineContent":[{"identifier":"WWDC20-10167-pointer_lifetime_1","type":"image"},{"text":" ","type":"text"},{"identifier":"WWDC20-10167-pointer_lifetime_2","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"It needs a stable memory location before creating a pointer.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The stable memory location has a limited lifetime - the memory location might not in the current stack frame or the memory gets deallocated directly."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Any behavior is undefined, if a pointer accesses an invalid memory address.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Pointers-unsafe-reason-2","text":"Pointer’s unsafe reason 2"},{"inlineContent":[{"identifier":"WWDC20-10167-pointer_object_boundary","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"A memory location can fit in multiple objects. For example, a 64-bit memory can fit in two ","type":"text"},{"code":"Int32","type":"codeVoice"},{"text":" type objects.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Pointers are allowed to move to different memory addresses by adding offsets to the pointer.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Adding or subtracting too large to the pointer, might access to the different object.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Accessing a pointer that has exceeded its object’s boundary is undefined."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Pointers-unsafe-reason-3","text":"Pointer’s unsafe reason 3"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-pointer_type_1"},{"text":" ","type":"text"},{"type":"image","identifier":"WWDC20-10167-pointer_type_2"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Pointers have their own types, they’re different from the types of values in memory.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the pointer we have is a type of "},{"type":"codeVoice","code":"Int16"},{"type":"text","text":", then we overwrite the memory location to store a "},{"type":"codeVoice","code":"Int32"},{"type":"text","text":" object, the pointer type will be inconsistent."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Accessing the old pointer of type "},{"type":"codeVoice","code":"Int16"},{"type":"text","text":" is undefined behavior."}]}]}],"type":"unorderedList"},{"level":4,"type":"heading","anchor":"Pointer-type-bugs","text":"Pointer type bugs"},{"items":[{"content":[{"inlineContent":[{"text":"Different versions of complier can cause different program behavior.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"May cause unexpected behavior."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"May remain hidden for a long time.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"May be exposed at surprising times:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"By safe-looking source change.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"By a compiler update."}],"type":"paragraph"}]}]}]}],"type":"unorderedList"},{"level":2,"type":"heading","anchor":"Swift-type-safe-pointers","text":"Swift type-safe pointers"},{"level":3,"type":"heading","anchor":"Pointer-type-rules-for-Swift-and-C","text":"Pointer type rules for Swift and C"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"C has rules for “strict aliasing” and “type punning”.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Swift pointers can be used safely without knowing C rules.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Swift pointers safely interoperate with C because they are, at minimum, as safe as C pointers."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"In exchange, you need to take responsibility for object lifetime and object boundaries.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"You can learn more in the ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/skhillon\/WWDC-Notes\/blob\/safe-pointers\/content\/notes\/10648"},{"text":" talk.","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"UnsafePointer<T>-is-a-typed-pointer","text":"`UnsafePointer<T>` is a typed pointer"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-type_safe_pointer"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In C, it’s common to cast pointers to different types with both pointers continuing to refer to the same memory."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"UnsafePointer<T>","type":"codeVoice"},{"text":" only reads values of that type from memory.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"UnsafeMutablePointer<T>"},{"type":"text","text":" only reads or writes values of that type."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"It’s undefined behavior in Swift to access a pointer whose type parameter does not match its memory location’s bound type."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Pointer types are enforced at compile time by Swift’s type system.","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Pointers-to-variables","text":"Pointers to variables"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-pointer_to_variables"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Declare a variable of type int, then ask for a pointer, will get back a pointer to int.","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Pointers-to-arrays","text":"Pointers to arrays"},{"inlineContent":[{"identifier":"WWDC20-10167-pointer_to_arrays","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Array storage is bound to the array element type.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Asking for a pointer into array storage gives back a pointer to the arrays element type."}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Type-safe-direct-memory-allocation","text":"Type-safe direct memory allocation"},{"code":["func directAllocation<T>(t: T, count: Int) {","    let tPtr = UnsafeMutablePointer<T>.allocate(capacity: count)","    tPtr.initialize(repeating: t, count: count)","    tPtr.assign(repeating: t, count: count)","    tPtr.deinitialize(count: count)","    tPtr.deallocate()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-type_safe_memory_allocation"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Allocate memory directly by calling the static allocate method on "},{"type":"codeVoice","code":"UnsafeMutablePointer"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Allocation binds memory to its type parameter and returns a typed pointer to the new memory."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use the pointer to initialize memory only to the correct type.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"In the initialized state, memory can be reassigned.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"De-initialize memory using the same typed pointer. Then can be safe to de-allocate."}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Composite-types-in-memory","text":"Composite types in memory"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-composite_type"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Generally won’t have two active pointers to the same memory location that disagree on the type.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It’s able to either get a pointer to the outer struct or a pointer to its property, they are both valid at the same time.","type":"text"}]}]}],"type":"unorderedList"},{"level":2,"type":"heading","anchor":"Swift-raw-pointers","text":"Swift raw pointers"},{"items":[{"content":[{"inlineContent":[{"code":"UnsafeRawPointer","type":"codeVoice"},{"type":"text","text":" lets you refer to a sequence of bytes without specifying the type."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"You take control over memory layout.","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Loading-bytes-with-UnsafeRawPointer","text":"Loading bytes with `UnsafeRawPointer`"},{"inlineContent":[{"identifier":"WWDC20-10167-loading_bytes_with_raw","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"It’s able to interpret bytes as typed values."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"It’s always possible to cast from a typed pointer down to a raw pointer.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Operations on raw pointer only see the sequence of bytes in memory."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"It’s able to ask that raw pointer to load any type."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":4,"type":"heading","anchor":"Example","text":"Example"},{"inlineContent":[{"identifier":"WWDC20-10167-loading_bytes_with_raw_example","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Call ","type":"text"},{"code":".load(as: UInt32.self)","type":"codeVoice"},{"text":" on a ","type":"text"},{"code":"Int64","type":"codeVoice"},{"text":" pointer.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It loads the lower 4 bytes from the memory location."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Then it interprets the 4 bytes as a ","type":"text"},{"type":"codeVoice","code":"UInt32"},{"text":" value.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"From a two’s compliment number to an unsigned number.","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Storing-bytes-with-UnsafeMutableRawPointer","text":"Storing bytes with `UnsafeMutableRawPointer`"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-storing_bytes_with_raw"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Storing bytes is asymmetric with loading because it modifies the in-memory value.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Storing raw bytes does not de-initialize the previous value in memory.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To make sure the memory doesn’t contain any object references."}]}]}],"type":"unorderedList"},{"level":4,"type":"heading","anchor":"Example","text":"Example"},{"inlineContent":[{"identifier":"WWDC20-10167-storing_bytes_with_raw_example","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Call "},{"type":"codeVoice","code":".storeBytes(of: u, as: UInt32.self)"},{"type":"text","text":" extracts 4 bytes from a "},{"type":"codeVoice","code":"UInt32"},{"type":"text","text":" value "},{"type":"codeVoice","code":"u"},{"type":"text","text":", writing them into the upper 4 bytes of an in-memory "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":" value."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The typed pointer "},{"type":"codeVoice","code":"iBytes"},{"type":"text","text":" that already points to the in-memory value can still be used to access it, but with different value."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Cannot cast a raw pointer back into a typed pointer because it conflicts with the memories bound type."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"In this case, "},{"type":"codeVoice","code":"Int64"},{"type":"text","text":" pointer overlaps with "},{"type":"codeVoice","code":"UInt32"},{"type":"text","text":" pointer."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Raw-pointers-to-variables","text":"Raw pointers to variables"},{"inlineContent":[{"identifier":"WWDC20-10167-raw_pointer_to_variables","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"code":"UnsafeRawBufferPointer","type":"codeVoice"},{"text":" is a collection of bytes, just like ","type":"text"},{"code":"UnsafeBufferPointer","type":"codeVoice"},{"text":" is a collection of typed values.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Buffer count is the size and bytes of the variables type."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The collection index is a byte offset. (It’s same as array arithmetic in C.)","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Raw-pointers-to-mutable-storage","text":"Raw pointers to mutable storage"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-raw_pointers_to_mutable"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withUnsafeMutableBytes"},{"type":"text","text":" gives a collection of mutable bytes, so you can store "},{"type":"codeVoice","code":"UInt"},{"type":"text","text":" values and specific byte offsets."}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Raw-pointers-to-arrays","text":"Raw pointers to arrays"},{"inlineContent":[{"identifier":"WWDC20-10167-raw_pointers_to_arrays","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withUnsafeBytes"},{"type":"text","text":" method exposes the raw storage for the array elements."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The buffer size is the array’s count multiplied by the element stride."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Some of those bytes could be padding for element alignment. (Data alignment)","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Raw-pointers-to-Data","text":"Raw pointers to `Data`"},{"code":["import Foundation","","func readUInt32(data: Data) -> UInt32 {","    data.withUnsafeBytes { (buffer: UnsafeRawBufferPointer) in","        buffer.load(fromByteOffset: 4, as: UInt32.self)","    }","}","","let data = Data(Array<UInt8>([0, 0, 0, 0, 1, 0, 0, 0]))","print(readUInt32(data: data))"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Foundation’s "},{"type":"codeVoice","code":"data"},{"type":"text","text":" type is a collection of bytes."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withUnsafeBytes"},{"type":"text","text":" method exposes the underlying raw pointer for the duration of a closure."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Here we read the bytes start from offset 4, interprets as ","type":"text"},{"code":"UInt32","type":"codeVoice"},{"text":".","type":"text"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Allocating-raw-storage","text":"Allocating raw storage"},{"code":["func rawAllocate<T>(t: T, numValues: Int) -> UnsafeMutablePointer<T> {","    let rawPtr = UnsafeMutableRawPointer.allocate(","            byteCount: MemoryLayout<T>.stride * numValues,","            alignment: MemoryLayout<T>.alignment)","    let tPtr = rawPtr.initializeMemory(as: T.self, repeating: t, count: numValues)","    \/\/ Must use the typed pointer ‘tPtr’ to deinitialize.","    return tPtr","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"identifier":"WWDC20-10167-allocate_raw_strorage","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"code":"UsafeMutableRawPointer.allocate","type":"codeVoice"},{"type":"text","text":" to directly allocate raw memory."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Should compute the memory size and alignment in bytes.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Memory state is neither initialized nor bound to a type after raw allocation."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Specify the type of values to initialize memory."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"tPtr"},{"type":"text","text":" is a typed pointer."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use typed pointer to de-initialize.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"There’s no way to de-initialize with a raw pointer.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"The allocation doesn’t care if memory is bound to a type or not."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":4,"type":"heading","anchor":"Example-Contiguous-storage-for-different-types","text":"Example: Contiguous storage for different types"},{"code":["func contiguousAllocate<Header>(header: Header, numValues: Int) -> (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Int32>) {","    let offset = MemoryLayout<Header>.stride","    let byteCount = offset + MemoryLayout<Int32>.stride * numValues","    assert(MemoryLayout<Header>.alignment >= MemoryLayout<Int32>.alignment)","    let bufferPtr = UnsafeMutableRawPointer.allocate(","            byteCount: byteCount, alignment: MemoryLayout<Header>.alignment)","    let headerPtr = bufferPtr.initializeMemory(as: Header.self, repeating: header, count: 1)","    let elementPtr = (bufferPtr + offset).initializeMemory(as: Int32.self, repeating: 0, count: numValues)","    return (headerPtr, elementPtr)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-allocate_raw_storage_example_1"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"We want to store unrelated types in the same contiguous block of memory. (As the image shows, we have type named ","type":"text"},{"type":"codeVoice","code":"Header"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Int32"},{"text":".)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"bufferPtr"},{"text":" is a raw pointer to a contiguous block of bytes. (It points to the first byte of the memory space.)","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"identifier":"WWDC20-10167-allocate_raw_storage_example_2","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Initialize first few bytes of memory to the type of ","type":"text"},{"type":"codeVoice","code":"Header"},{"text":".","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"identifier":"WWDC20-10167-allocate_raw_storage_example_3","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Initialize the remaining bytes to "},{"type":"codeVoice","code":"Int32"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"This storage allocation technique is great for implementing standard library types like "},{"type":"codeVoice","code":"set"},{"type":"text","text":" and "},{"type":"codeVoice","code":"dictionary"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In general raw pointers are a kind of power tool that are good for implementing high-performance data structures, but we don’t want to expose them too much."}],"type":"paragraph"},{"level":4,"type":"heading","anchor":"Use-case-decoding-byte-buffers","text":"Use case: decoding byte buffers"},{"inlineContent":[{"text":"The more likely case where you want to use a raw pointer is when you have a buffer of bytes that’s externally generated, and you want to decode those bytes into Swift types.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"WWDC20-10167-raw_pointer_use_case"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Read a descriptor to determine the sizes and types of subsequent data."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Load the following data then decode to whatever type we want."}]}]}],"type":"unorderedList"},{"level":2,"type":"heading","anchor":"Mutable-type","text":"Mutable type"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"API names refer to the memory’s ‘bound type’:"}]},{"items":[{"content":[{"inlineContent":[{"code":"assumingMemoryBound(to:)","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"bindMemory(to:capacity:)","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"code":"withMemoryRebound(to:capacity:)","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"content":[{"inlineContent":[{"type":"text","text":"Can introduce undefined behavior or existing uses of typed pointers."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Rule: every typed pointer access must agree with memory’s bound type.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"assumingMemoryBoundto","text":"`assumingMemoryBound(to:)`"},{"level":4,"type":"heading","anchor":"Recovering-a-typed-pointer","text":"Recovering a typed pointer"},{"code":["func takesIntPointer(_: UnsafePointer<Int>) { \/* elided *\/ }","","struct RawContainer {","    var rawPtr: UnsafeRawPointer","    var pointsToInt: Bool","}","","func testContainer(numValues: Int) {","    let intPtr = UnsafeMutablePointer<Int>.allocate(capacity: numValues)","    let rc = RawContainer(rawPtr: intPtr, pointsToInt: true)","    \/\/ ...","    if rc.pointsToInt {","        takesIntPointer(rc.rawPtr.assumingMemoryBound(to: Int.self))","    }","}"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"RawContainer.rawPtr"},{"type":"text","text":" holds raw memory."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"⚠️ Use "},{"code":"assumingMemoryBound(to: T.self)","type":"codeVoice"},{"type":"text","text":" when memory is already bound to ‘T’ by a previous operation."}]}]}],"type":"unorderedList"},{"level":4,"type":"heading","anchor":"Pointing-to-tuple-elements","text":"Pointing to tuple elements"},{"code":["func takesIntPointer(_: UnsafePointer<Int>) { \/* elided *\/ }","","func testPointingToTuple() {","    let tuple = (0, 1, 2)","    withUnsafePointer(to: tuple) { (tuplePtr: UnsafePointer<(Int, Int, Int)>) in","        takesIntPointer(UnsafeRawPointer(tuplePtr).assumingMemoryBound(to: Int.self))","    }","}"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withUnsafePointer"},{"type":"text","text":" gives back a pointer "},{"type":"codeVoice","code":"tuplePtr"},{"type":"text","text":" to the tuple type which is incompatible with "},{"type":"codeVoice","code":"UnsafePointer<Int>"},{"type":"text","text":" type."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Memory bound to a tuple is also bound to its element types.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Construct a raw pointer deliberately erasing the type of tuple pointer."}]}]},{"content":[{"inlineContent":[{"text":"Use ","type":"text"},{"type":"codeVoice","code":"assumingMemoryBound"},{"text":" to create a pointer to ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Homogeneous tuples have guaranteed layout. (one value after another)"}]}]}],"type":"unorderedList"},{"level":4,"type":"heading","anchor":"Pointing-to-struct-properties","text":"Pointing to struct properties"},{"code":["func takesIntPointer(_: UnsafePointer<Int>) { \/* elided *\/ }","","struct MyStruct {","    var status: Bool","    var value: Int","}","","func testPointingToStructProperty() {","    let myStruct = MyStruct(status: true, value: 0)","    withUnsafePointer(to: myStruct) { (ptr: UnsafePointer<MyStruct>) in","        let rawValuePtr =","                (UnsafeRawPointer(ptr) + MemoryLayout<MyStruct>.offset(of: \\MyStruct.value)!)","        takesIntPointer(rawValuePtr.assumingMemoryBound(to: Int.self))","    }","}"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"code":"MyStruct","type":"codeVoice"},{"text":" has an integer property.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withUnsafePointer"},{"text":" gives a typed pointer to ","type":"text"},{"type":"codeVoice","code":"myStruct"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"By casting the struct pointer down to a raw pointer and adding that byte offset, we get a raw pointer to the value property."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A property’s memory is always bound to the properties declared type so it’s safe to call "},{"code":"assumingMemoryBound","type":"codeVoice"},{"type":"text","text":" to to get a pointer to an "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"text":"⚠️ Struct layout is not guaranteed - rawValuePtr only points to a single pointee.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Simple alternative way:"}]}],"type":"paragraph"},{"code":["func takesIntPointer(_: UnsafePointer<Int>) { \/* elided *\/ }","","struct MyStruct {","    var status: Bool","    var value: Int","}","","let myStruct = MyStruct(status: true, value: 0)","    takesIntPointer(&myStruct.value)","}",""],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","anchor":"bindMemorytocapacity","text":"`bindMemory(to:capacity:)`"},{"items":[{"content":[{"inlineContent":[{"code":"bindMemory","type":"codeVoice"},{"text":" API lets you change memories bound type.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the memory location was not already bound to a type, It just binds the type for the first time."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"If the memory is already bound to a type then it rebinds the type.","type":"text"}]}]}],"type":"unorderedList"},{"code":["func testBindMemory() {","    let uint16Ptr = UnsafeMutablePointer<UInt16>.allocate(capacity: 2)","    uint16Ptr.initialize(repeating: 0, count: 2)","    let int32Ptr = UnsafeMutableRawPointer(uint16Ptr).bindMemory(to: Int32.self, capacity: 1)","    \/\/ Accessing uint16Ptr is now undefined","    int32Ptr.deallocate()","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"inlineContent":[{"text":"Changing the bound type of a memory region:","type":"text"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Modifies the abstract memory state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reinterprets the memory region’s raw bytes in place"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Invalidates existing typed pointers"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Can be undefined for variable, array, and collection storage","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Facilitates low-level implementation of Swift - note application code"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"withMemoryreboundtocapacity","text":"`withMemoryrebound(to:capacity)`"},{"inlineContent":[{"type":"text","text":"Temporarily changing the bound type."}],"type":"paragraph"},{"code":["func takesUInt8Pointer(_: UnsafePointer<UInt8>) { \/* elided *\/ }","","func testWithMemoryRebound(int8Ptr: UnsafePointer<Int8>, count: Int) {","    int8Ptr.withMemoryRebound(to: UInt8.self, capacity: count) {","        (uint8Ptr: UnsafePointer<UInt8>) in","        \/\/ int8Ptr cannot be used within this closure","        takesUInt8Pointer(uint8Ptr)","    }","    \/\/ uint8Ptr cannot be used outside this closure","}"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"withMemoryrebound(to:capacity)"},{"type":"text","text":" gives a pointer that’s guaranteed to be valid for the scope of its closure."}],"type":"paragraph"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Using-bindMemorytocapacity-safely","text":"Using `bindMemory(to:capacity:)` safely"},{"items":[{"content":[{"inlineContent":[{"code":"withMemoryrebound(to:capacity)","type":"codeVoice"},{"text":" limitations:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Requires a pointer to the original type"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Both types require the same stride"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"To call ","type":"text"},{"type":"codeVoice","code":"bindMemory(to:capacity:)"},{"text":" directly, follow the same principles:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Limit pointer use to a controlled scope"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Rebind memory back to the original type when the scope ends","type":"text"}]}]}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Memory-binding-APIs","text":"Memory-binding APIs"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"assumingMemoryBound(to:)","type":"codeVoice"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Recover a type-erased pointer type"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"⚠️ Requires prior knowledge of the memory’s bound type state"}],"type":"paragraph"}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"bindMemory(to:capacity:)","type":"codeVoice"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Global change to the memory’s bound type state"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"⚠️ Low-level operation that invalidates existing typed pointers","type":"text"}]}]}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"withMemoryrebound(to:capacity)"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Temporarily change memory’s bound type state","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"⚠️ Useful for calling C APIs that disagree on types"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Safely-reinterpreting-bytes","text":"Safely reinterpreting bytes"},{"code":["❌","let uint32Ptr = rawPtr.bindMemory(to: UInt32.self)","return uint32Ptr.pointee"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"inlineContent":[{"text":"Call ","type":"text"},{"code":"bindMemory","type":"codeVoice"},{"text":" to get a pointer of the type it wants to read.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"But in the process of creating that pointer we’ve changed memory state and probably invalidated other pointers."}],"type":"paragraph"}]}],"type":"unorderedList"},{"code":["✅","return rawPtr.load(as: UInt32.self)"],"type":"codeListing","syntax":"swift"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Avoids changing the in-memory type and invalidating other pointers","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Type-safe: only layout compatibility matters"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"A typed pointer can be cast to a raw pointer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"withUnsafeBytes"},{"type":"text","text":" provides a raw buffer for variables, arrays, or Data objects"}]}]}],"type":"unorderedList"},{"level":3,"type":"heading","anchor":"Layering-types-on-top-of-raw-memory","text":"Layering types on top of raw memory"},{"inlineContent":[{"type":"text","text":"Let’s say you want to view a region of memory as a sequence of elements with a specific element type, but the underlying storage is exposed as a raw pointer and may be viewed as different types by different parts of the code."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You could easily create a wrapper around that raw pointer to preserve your element type."}],"type":"paragraph"},{"code":["struct UnsafeBufferView<Element>: RandomAccessCollection {","    let rawBytes: UnsafeRawBufferPointer","    let count: Int","","    init(reinterpret rawBytes: UnsafeRawBufferPointer, as: Element.Type) {","        self.rawBytes = rawBytes","        self.count = rawBytes.count \/ MemoryLayout<Element>.stride","        precondition(self.count * MemoryLayout<Element>.stride == rawBytes.count)","        precondition(Int(bitPattern: rawBytes.baseAddress).isMultiple(of: MemoryLayout<Element>.alignment))","    }","","    var startIndex: Int { 0 }","","    var endIndex: Int { count }","","    subscript(index: Int) -> Element {","        rawBytes.load(fromByteOffset: index * MemoryLayout<Element>.stride, as: Element.self)","    }","}","","func testBufferView() {","    let array = [0,1,2,3]","    array.withUnsafeBytes {","        let view = UnsafeBufferView(reinterpret: $0, as: UInt.self)","        for val in view {","            print(val)","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","anchor":"Summary","text":"Summary"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Try to avoid using pointers"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Avoid using typed pointers to reinterpret memory as different types"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"code":"UnsafeRawBufferPointer","type":"codeVoice"},{"text":" to:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Reinterpret raw bytes as different types","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Decode Swift types from a byte stream","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Implement a container to hold different types in contiguous memory","type":"text"}]}]}],"type":"unorderedList"}]}],"type":"unorderedList"},{"level":2,"type":"heading","anchor":"Written-By","text":"Written By"},{"type":"row","numberOfColumns":5,"columns":[{"content":[{"type":"paragraph","inlineContent":[{"type":"image","identifier":"dasautoooo"}]}],"size":1},{"content":[{"level":3,"type":"heading","text":"DasAuto","anchor":"DasAuto"},{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/dasautoooo","overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"type":"reference","isActive":true,"overridingTitle":"Contributed Notes"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/dasautoooo","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/x.com\/DasAutoooo","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/wut.im","type":"reference","isActive":true}]}],"size":4}]},{"type":"row","numberOfColumns":5,"columns":[{"content":[{"inlineContent":[{"identifier":"skhillon","type":"image"}],"type":"paragraph"}],"size":1},{"content":[{"level":3,"type":"heading","text":"Sarthak Khillon","anchor":"Sarthak-Khillon"},{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","type":"reference","isActive":true,"overridingTitleInlineContent":[{"text":"Contributed Notes","type":"text"}],"overridingTitle":"Contributed Notes"},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/github.com\/skhillon","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","type":"reference","isActive":true},{"text":" ","type":"text"},{"text":"|","type":"text"},{"text":" ","type":"text"},{"identifier":"https:\/\/x.com\/SarthakKhillon","type":"reference","isActive":true}]}],"size":4}]},{"inlineContent":[{"text":"Missing anything? Corrections? ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing"}],"type":"paragraph"},{"level":2,"type":"heading","anchor":"Related-Sessions","text":"Related Sessions"},{"style":"list","items":["doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10648-Unsafe-Swift"],"type":"links"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Legal Notice"}],"type":"strong"}],"type":"small"},{"inlineContent":[{"type":"text","text":"All content copyright © 2012 – 2024 Apple Inc. All rights reserved."},{"type":"text","text":" "},{"type":"text","text":"Swift, the Swift logo, Swift Playgrounds, Xcode, Instruments, Cocoa Touch, Touch ID, FaceID, iPhone, iPad, Safari, Apple Vision, Apple Watch, App Store, iPadOS, watchOS, visionOS, tvOS, Mac, and macOS are trademarks of Apple Inc., registered in the U.S. and other countries."},{"type":"text","text":" "},{"type":"text","text":"This website is not made by, affiliated with, nor endorsed by Apple."}],"type":"small"}],"kind":"content"}],"sampleCodeDownload":{"action":{"type":"reference","overridingTitle":"Watch Video (27 min)","identifier":"https:\/\/developer.apple.com\/wwdc20\/10167","isActive":true},"kind":"sampleDownload"},"hierarchy":{"paths":[["doc:\/\/WWDCNotes\/documentation\/WWDCNotes","doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20"]]},"abstract":[{"text":"Come with us as we delve into unsafe pointer types in Swift. Discover the requirements for each type and how to use it correctly. We’ll discuss typed pointers, drop down to raw pointers, and finally circumvent pointer type safety entirely by binding memory.","type":"text"}],"references":{"WWDC20-10167-pointer_type_1":{"type":"image","identifier":"WWDC20-10167-pointer_type_1","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_type_1.png","traits":["1x","light"]}]},"WWDC20-10167-raw_pointer_to_variables":{"type":"image","identifier":"WWDC20-10167-raw_pointer_to_variables","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-raw_pointer_to_variables.png","traits":["1x","light"]}]},"dasautoooo":{"type":"image","identifier":"dasautoooo","alt":"Profile image of DasAuto","variants":[{"url":"\/images\/dasautoooo.jpeg","traits":["1x","light"]}]},"WWDC20-10167-raw_pointer_use_case":{"type":"image","identifier":"WWDC20-10167-raw_pointer_use_case","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-raw_pointer_use_case.png","traits":["1x","light"]}]},"https://github.com/skhillon/WWDC-Notes/blob/safe-pointers/content/notes/10648":{"url":"https:\/\/github.com\/skhillon\/WWDC-Notes\/blob\/safe-pointers\/content\/notes\/10648","type":"link","identifier":"https:\/\/github.com\/skhillon\/WWDC-Notes\/blob\/safe-pointers\/content\/notes\/10648","title":"Unsafe Swift","titleInlineContent":[{"text":"Unsafe Swift","type":"text"}]},"skhillon":{"type":"image","identifier":"skhillon","alt":"Profile image of Sarthak Khillon","variants":[{"url":"\/images\/skhillon.jpeg","traits":["1x","light"]}]},"dasautoooo.jpeg":{"type":"image","identifier":"dasautoooo.jpeg","alt":null,"variants":[{"url":"\/images\/dasautoooo.jpeg","traits":["1x","light"]}]},"skhillon.jpeg":{"type":"image","identifier":"skhillon.jpeg","alt":null,"variants":[{"url":"\/images\/skhillon.jpeg","traits":["1x","light"]}]},"https://x.com/DasAutoooo":{"url":"https:\/\/x.com\/DasAutoooo","type":"link","identifier":"https:\/\/x.com\/DasAutoooo","title":"X\/Twitter","titleInlineContent":[{"text":"X\/Twitter","type":"text"}]},"https://wut.im":{"url":"https:\/\/wut.im","type":"link","identifier":"https:\/\/wut.im","title":"Blog","titleInlineContent":[{"text":"Blog","type":"text"}]},"WWDC20-10167-allocate_raw_storage_example_1":{"type":"image","identifier":"WWDC20-10167-allocate_raw_storage_example_1","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-allocate_raw_storage_example_1.png","traits":["1x","light"]}]},"WWDC20-10167-loading_bytes_with_raw":{"type":"image","identifier":"WWDC20-10167-loading_bytes_with_raw","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-loading_bytes_with_raw.png","traits":["1x","light"]}]},"https://developer.apple.com/wwdc20/10167":{"url":"https:\/\/developer.apple.com\/wwdc20\/10167","type":"download","identifier":"https:\/\/developer.apple.com\/wwdc20\/10167","checksum":null},"doc://WWDCNotes/documentation/WWDCNotes/dasautoooo":{"type":"topic","images":[{"type":"card","identifier":"dasautoooo.jpeg"},{"type":"icon","identifier":"dasautoooo.jpeg"}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/dasautoooo","url":"\/documentation\/wwdcnotes\/dasautoooo","role":"sampleCode","abstract":[{"type":"text","text":"💻 Programmer | 🕹 Lifetime Gamer"}],"kind":"article","title":"DasAuto (6 notes)"},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20-10648-Unsafe-Swift":{"abstract":[{"type":"text","text":"What exactly makes code “unsafe”? Join the Swift team as we take a look at the programming language’s safety precautions — and when you might need to reach for unsafe operations. We’ll take a look at APIs that can cause unexpected states if not used correctly, and how you can write code more specifically to avoid undefined behavior. Learn how to work with C APIs that use pointers and the steps to take when you want to use Swift’s unsafe pointer APIs."}],"identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20-10648-Unsafe-Swift","url":"\/documentation\/wwdcnotes\/wwdc20-10648-unsafe-swift","title":"Unsafe Swift","role":"sampleCode","type":"topic","kind":"article"},"WWDC20-10167-pointer_lifetime_2":{"type":"image","identifier":"WWDC20-10167-pointer_lifetime_2","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_lifetime_2.png","traits":["1x","light"]}]},"WWDC20-10167-storing_bytes_with_raw_example":{"type":"image","identifier":"WWDC20-10167-storing_bytes_with_raw_example","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-storing_bytes_with_raw_example.png","traits":["1x","light"]}]},"WWDC20-10167-composite_type":{"type":"image","identifier":"WWDC20-10167-composite_type","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-composite_type.png","traits":["1x","light"]}]},"WWDC20-Icon.png":{"type":"image","identifier":"WWDC20-Icon.png","alt":null,"variants":[{"url":"\/images\/WWDC20-Icon.png","traits":["1x","light"]}]},"WWDC20-10167-loading_bytes_with_raw_example":{"type":"image","identifier":"WWDC20-10167-loading_bytes_with_raw_example","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-loading_bytes_with_raw_example.png","traits":["1x","light"]}]},"WWDC20-10167-storing_bytes_with_raw":{"type":"image","identifier":"WWDC20-10167-storing_bytes_with_raw","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-storing_bytes_with_raw.png","traits":["1x","light"]}]},"WWDC20-10167-pointer_type_2":{"type":"image","identifier":"WWDC20-10167-pointer_type_2","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_type_2.png","traits":["1x","light"]}]},"https://www.linkedin.com/in/sarthakkhillon/":{"url":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","type":"link","identifier":"https:\/\/www.linkedin.com\/in\/sarthakkhillon\/","title":"Blog","titleInlineContent":[{"text":"Blog","type":"text"}]},"WWDC20.jpeg":{"type":"image","identifier":"WWDC20.jpeg","alt":null,"variants":[{"url":"\/images\/WWDC20.jpeg","traits":["1x","light"]}]},"WWDC20-10167-raw_pointers_to_arrays":{"type":"image","identifier":"WWDC20-10167-raw_pointers_to_arrays","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-raw_pointers_to_arrays.png","traits":["1x","light"]}]},"WWDC20-10167-safe_swift_code":{"type":"image","identifier":"WWDC20-10167-safe_swift_code","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-safe_swift_code.png","traits":["1x","light"]}]},"WWDC20-10167-allocate_raw_storage_example_2":{"type":"image","identifier":"WWDC20-10167-allocate_raw_storage_example_2","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-allocate_raw_storage_example_2.png","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/WWDC20":{"abstract":[{"text":"Xcode 12, Swift 5.3, iOS 14, macOS 11 (Big Sur), tvOS 14, watchOS 7.","type":"text"},{"text":" ","type":"text"},{"text":"New APIs: ","type":"text"},{"type":"codeVoice","code":"WidgetKit"},{"type":"text","text":", "},{"type":"codeVoice","code":"StoreKit Testing"},{"type":"text","text":", and more."}],"type":"topic","url":"\/documentation\/wwdcnotes\/wwdc20","kind":"article","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/WWDC20","images":[{"identifier":"WWDC20-Icon.png","type":"icon"},{"identifier":"WWDC20.jpeg","type":"card"}],"title":"WWDC20","role":"collectionGroup"},"WWDC20-10167-type_safe_memory_allocation":{"type":"image","identifier":"WWDC20-10167-type_safe_memory_allocation","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-type_safe_memory_allocation.png","traits":["1x","light"]}]},"WWDC20-10167-allocate_raw_strorage":{"type":"image","identifier":"WWDC20-10167-allocate_raw_strorage","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-allocate_raw_strorage.png","traits":["1x","light"]}]},"WWDC20-10167-raw_pointers_to_mutable":{"type":"image","identifier":"WWDC20-10167-raw_pointers_to_mutable","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-raw_pointers_to_mutable.png","traits":["1x","light"]}]},"WWDCNotes.png":{"type":"image","identifier":"WWDCNotes.png","alt":null,"variants":[{"url":"\/images\/WWDCNotes.png","traits":["1x","light"]}]},"WWDC20-10167-levels_of_safety":{"type":"image","identifier":"WWDC20-10167-levels_of_safety","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-levels_of_safety.png","traits":["1x","light"]}]},"WWDC20-10167-pointer_to_arrays":{"type":"image","identifier":"WWDC20-10167-pointer_to_arrays","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_to_arrays.png","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes/skhillon":{"images":[{"type":"card","identifier":"skhillon.jpeg"},{"type":"icon","identifier":"skhillon.jpeg"}],"kind":"article","title":"Sarthak Khillon (19 notes)","abstract":[{"type":"text","text":"No Bio on GitHub"}],"type":"topic","role":"sampleCode","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes\/skhillon","url":"\/documentation\/wwdcnotes\/skhillon"},"WWDC20-10167-pointer_to_variables":{"type":"image","identifier":"WWDC20-10167-pointer_to_variables","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_to_variables.png","traits":["1x","light"]}]},"WWDC20-10167-unsafe_swift_code":{"type":"image","identifier":"WWDC20-10167-unsafe_swift_code","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-unsafe_swift_code.png","traits":["1x","light"]}]},"WWDC20-10167-pointer_lifetime_1":{"type":"image","identifier":"WWDC20-10167-pointer_lifetime_1","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_lifetime_1.png","traits":["1x","light"]}]},"doc://WWDCNotes/documentation/WWDCNotes":{"abstract":[{"text":"Session notes shared by the community for the community.","type":"text"}],"type":"topic","url":"\/documentation\/wwdcnotes","kind":"symbol","identifier":"doc:\/\/WWDCNotes\/documentation\/WWDCNotes","images":[{"type":"icon","identifier":"WWDCNotes.png"}],"title":"WWDC Notes","role":"collection"},"WWDC20-10167-allocate_raw_storage_example_3":{"type":"image","identifier":"WWDC20-10167-allocate_raw_storage_example_3","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-allocate_raw_storage_example_3.png","traits":["1x","light"]}]},"https://github.com/skhillon":{"url":"https:\/\/github.com\/skhillon","type":"link","identifier":"https:\/\/github.com\/skhillon","title":"GitHub","titleInlineContent":[{"text":"GitHub","type":"text"}]},"https://github.com/dasautoooo":{"url":"https:\/\/github.com\/dasautoooo","type":"link","identifier":"https:\/\/github.com\/dasautoooo","title":"GitHub","titleInlineContent":[{"text":"GitHub","type":"text"}]},"https://x.com/SarthakKhillon":{"url":"https:\/\/x.com\/SarthakKhillon","type":"link","identifier":"https:\/\/x.com\/SarthakKhillon","title":"X\/Twitter","titleInlineContent":[{"text":"X\/Twitter","type":"text"}]},"https://wwdcnotes.com/documentation/wwdcnotes/contributing":{"url":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","type":"link","identifier":"https:\/\/wwdcnotes.com\/documentation\/wwdcnotes\/contributing","title":"Contributions are welcome!","titleInlineContent":[{"text":"Contributions are welcome!","type":"text"}]},"WWDC20-10167-type_safe_pointer":{"type":"image","identifier":"WWDC20-10167-type_safe_pointer","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-type_safe_pointer.png","traits":["1x","light"]}]},"WWDC20-10167-pointer_object_boundary":{"type":"image","identifier":"WWDC20-10167-pointer_object_boundary","alt":null,"variants":[{"url":"\/images\/WWDC20-10167-pointer_object_boundary.png","traits":["1x","light"]}]}}}